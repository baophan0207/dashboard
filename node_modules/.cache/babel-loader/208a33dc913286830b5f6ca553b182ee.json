{"ast":null,"code":"var _jsxFileName = \"D:\\\\Task\\\\dashboard\\\\src\\\\assets\\\\components\\\\PopupComponents\\\\BasicComponents\\\\CommonMethods.js\";\nimport React, { Component } from 'react';\nimport DuoIconV2 from \"../../../IconLibrary/DuoIcon\";\nimport Icon from \"../../../IconLibrary/Icon\";\nimport Popup from \"reactjs-popup\";\nimport \"./FeatureStore.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst uuidv4 = require('uuid').v4;\nlet userInfo = {};\nlet isAdminUser = false;\nlet isSuperAdmin = false;\nlet checkboxWidth = 50;\nlet patentIDWidth = 200;\nlet titleWidth = 150;\nlet descriptionWidth = 200;\nlet multiLabelSeparator = \";\";\nlet clientBasedFeatures = [];\nexport const IN_PROGRESS = \"in progress\";\nexport const SUCCESS = \"success\";\nexport const MIX_STATUS = \"success_fail\";\nexport const FAIL = \"fail\";\nexport const TRAINING_KEYWORD = \"training\";\nexport const getInstanceID = () => {\n  return \"00000000-0000-0000-0000-000000000000\";\n};\nexport const CreateUUID = () => {\n  return uuidv4();\n};\n_c = CreateUUID;\nexport const isValidData = input => {\n  return input !== undefined && input !== null && input !== \"\";\n};\nexport const checkEmpty = inputArr => {\n  let empty = true;\n  if (inputArr !== undefined && inputArr !== null && inputArr.length > 0) {\n    empty = false;\n  }\n  return empty;\n};\nexport const hasDataList = inputArr => {\n  let hasData = false;\n  if (inputArr !== undefined && inputArr !== null && inputArr.length > 0) {\n    hasData = true;\n  }\n  return hasData;\n};\nexport const getSortingDataByNameAndOrder = (currentData, name, order) => {\n  currentData.sort(function (a, b) {\n    let nameA = a[name].toLowerCase(); // ignore upper and lowercase\n    let nameB = b[name].toLowerCase(); // ignore upper and lowercase\n    if (order === \"desc\") {\n      if (nameA > nameB) {\n        return -1;\n      }\n      if (nameA < nameB) {\n        return 1;\n      }\n    } else {\n      if (nameA < nameB) {\n        return -1;\n      }\n      if (nameA > nameB) {\n        return 1;\n      }\n    }\n    return 0;\n  });\n  return currentData;\n};\nexport const binarySearch = (data, target, startIndex, endIndex) => {\n  const middle = Math.floor((startIndex + endIndex) / 2);\n  if (target === data[middle]) return data[middle];\n  if (endIndex - 1 === startIndex) {\n    return Math.abs(data[startIndex] - target) > Math.abs(data[endIndex] - target) ? data[endIndex] : data[startIndex];\n  } else if (target > data[middle]) {\n    return binarySearch(data, target, middle, endIndex);\n  } else if (target < data[middle]) {\n    return binarySearch(data, target, startIndex, middle);\n  }\n};\nexport const getCurrentTimeStamp = () => {\n  return Math.floor(new Date().getTime()); //by milliseconds, (if want for second, divide by 1000)\n};\nexport const convertArrayToHashMap = (inputArr, columnKey) => {\n  let hashMap = {};\n  if (isValidData(columnKey)) {\n    inputArr.map(eachInput => {\n      if (isValidData(eachInput[columnKey])) {\n        hashMap[eachInput[columnKey]] = eachInput;\n      } else {\n        console.log(\"key is not included in the pass data\");\n      }\n    });\n  } else {\n    //for true/false case\n    inputArr.map(eachInput => {\n      hashMap[eachInput] = true;\n    });\n  }\n  return hashMap;\n};\nexport const getCurrentUTCDateTime = () => {\n  let currentDate = new Date();\n  let utcTimeParse = new Date(currentDate.toUTCString());\n  let year = utcTimeParse.getFullYear();\n  let month = utcTimeParse.getMonth() + 1;\n  if (month.toString().length === 1) {\n    month = \"0\" + month.toString();\n  }\n  let date = utcTimeParse.getDate();\n  if (date.toString().length === 1) {\n    date = \"0\" + date.toString();\n  }\n  let utcDate = year + \"-\" + month + \"-\" + date;\n  let hour = utcTimeParse.getUTCHours();\n  if (hour < 10) {\n    hour = \"0\" + hour;\n  }\n  let minute = utcTimeParse.getUTCMinutes();\n  if (minute < 10) {\n    minute = \"0\" + minute;\n  }\n  let second = utcTimeParse.getUTCSeconds();\n  if (second < 10) {\n    second = \"0\" + second;\n  }\n  let utcTime = hour + \":\" + minute + \":\" + second;\n\n  // for direct hours //TODO to remove after tested\n  // let utcDate2 = year + \"-\" + month + \"-\" + date\n  // let hour2 = utcTimeParse.getHours()\n  // if (hour2 < 10) {\n  //     hour2 = \"0\" + hour2\n  // }\n  // let minute2 = utcTimeParse.getMinutes()\n  // if (minute2 < 10) {\n  //     minute2 = \"0\" + minute2\n  // }\n  // let second2 = utcTimeParse.getSeconds()\n  // if (second2 < 10) {\n  //     second2 = \"0\" + second2\n  // }\n  // let utcTime2 = hour2 + \":\" + minute2 + \":\" + second2\n  // let dateValue2 = utcDate2 + \"T\" + utcTime2 + \"Z\"\n  // let dateValue1 = utcDate + \"T\" + utcTime + \"Z\"\n  //\n  // console.log(\"#Converted UTC time1: \", dateValue1, \"=> \", convertUtcToCurrentDateAndTime(dateValue1))\n  // console.log(\"#Converted UTC time2: \", dateValue2, \"=> \", convertUtcToCurrentDateAndTime(dateValue2))\n\n  return utcDate + \"T\" + utcTime + \"Z\";\n};\nexport const convertSimpleDateTotUTCDateTime = inputDate => {\n  let currentDate = new Date(inputDate);\n  let utcTimeParse = new Date(currentDate.toUTCString());\n  let year = utcTimeParse.getFullYear();\n  let month = utcTimeParse.getMonth() + 1;\n  if (month.toString().length === 1) {\n    month = \"0\" + month.toString();\n  }\n  let date = utcTimeParse.getDate();\n  if (date.toString().length === 1) {\n    date = \"0\" + date.toString();\n  }\n  let utcDate = year + \"-\" + month + \"-\" + date;\n  let hour = utcTimeParse.getUTCHours();\n  if (hour < 10) {\n    hour = \"0\" + hour;\n  }\n  let minute = utcTimeParse.getUTCMinutes();\n  if (minute < 10) {\n    minute = \"0\" + minute;\n  }\n  let second = utcTimeParse.getUTCSeconds();\n  if (second < 10) {\n    second = \"0\" + second;\n  }\n  let utcTime = hour + \":\" + minute + \":\" + second;\n  return utcDate + \"T\" + utcTime + \"Z\";\n};\nexport const CommonLoadingPopup = input => {\n  let open = input.open;\n  let content = input.content;\n  return /*#__PURE__*/_jsxDEV(Popup, {\n    contentStyle: {\n      background: 'transparent',\n      width: 'auto',\n      height: 'auto',\n      textAlign: 'center',\n      border: 'none'\n    },\n    open: open,\n    closeOnDocumentClick: false,\n    position: \"top right\",\n    lockScroll: true,\n    children: /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"loadingContainer\",\n      children: [content, \" \\u2003\", /*#__PURE__*/_jsxDEV(\"span\", {\n        className: \"loading-icon\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 214,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 212,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 201,\n    columnNumber: 9\n  }, this);\n};\n_c2 = CommonLoadingPopup;\nexport class MultiColumnsSearchBox extends Component {\n  constructor(props) {\n    super(props);\n    this.prepareInitialData = (searchColumnName, searchValue, disableSearchBtn, itemList) => {\n      let itemHashMap = {};\n      itemList.map(eachItem => {\n        itemHashMap[eachItem.Value] = eachItem;\n      });\n      this.setState({\n        searchColumnName,\n        searchValue,\n        itemList,\n        itemHashMap,\n        disableSearchBtn\n      });\n    };\n    this.handleChangeSearchColumnName = itemName => {\n      if (this.props.handleChangeSearchColumnName !== undefined && this.props.handleChangeSearchColumnName !== null) {\n        this.props.handleChangeSearchColumnName(itemName);\n      }\n    };\n    this.handleChangeSearchValue = event => {\n      if (this.props.handleChangeSearchValue !== undefined && this.props.handleChangeSearchValue !== null) {\n        this.props.handleChangeSearchValue(event);\n      }\n    };\n    this.getActiveInfo = searchColumnName => {\n      let activeColumnInfo = \"\";\n      let {\n        itemList\n      } = this.state;\n      if (isValidData(this.state.itemHashMap[searchColumnName])) {\n        activeColumnInfo = this.state.itemHashMap[searchColumnName];\n      } else {\n        for (let index = 0; index < itemList.length; index++) {\n          if (itemList[index].Value === searchColumnName) {\n            activeColumnInfo = itemList[index];\n          }\n        }\n      }\n      return activeColumnInfo;\n    };\n    this.keyPress = e => {\n      if (e.keyCode === 13) {\n        e.preventDefault();\n        this.searchBtnRef.current.focus();\n        if (this.props.onKeyDown !== undefined && this.props.onKeyDown !== null) {\n          this.props.onKeyDown();\n        } else if (this.props.handleSearchOnClick !== undefined && this.props.handleSearchOnClick !== null) {\n          this.props.handleSearchOnClick();\n        }\n      } else if (e.keyCode === 38) {\n        e.preventDefault();\n        this.searchValueRef.current.focus();\n      }\n    };\n    this.state = {\n      searchColumnName: \"\",\n      searchValue: \"\",\n      itemHashMap: {},\n      itemList: [{\n        DisplayName: \"item name\",\n        Value: \"item\",\n        DuoIconName: \"feature_store\"\n      }, {\n        DisplayName: \"variable/operator name\",\n        Value: \"variable\",\n        DuoIconName: \"column\"\n      }],\n      disableSearchBtn: true\n    };\n    this.searchBtnRef = /*#__PURE__*/React.createRef();\n    this.searchValueRef = /*#__PURE__*/React.createRef();\n  }\n  componentDidMount() {\n    const {\n      searchColumnName,\n      searchValue,\n      disableSearchBtn,\n      itemList\n    } = this.props;\n    this.prepareInitialData(searchColumnName, searchValue, disableSearchBtn, itemList);\n  }\n  componentWillReceiveProps(nextProps, nextContext) {\n    const {\n      searchColumnName,\n      searchValue,\n      disableSearchBtn,\n      itemList\n    } = nextProps;\n    this.prepareInitialData(searchColumnName, searchValue, disableSearchBtn, itemList);\n  }\n  render() {\n    const {\n      searchColumnName,\n      searchValue,\n      disableSearchBtn,\n      itemList\n    } = this.state;\n    const {\n      onKeyDown,\n      handleSearchOnClick,\n      width\n    } = this.props;\n    let activeInfo = this.getActiveInfo(searchColumnName);\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"feature-store-feature-search-box\",\n      style: {\n        width: width\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"feature-search-box\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"feature-search-box-left\",\n          style: {\n            width: \"100%\"\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"feature-search-icon\",\n            children: activeInfo.DuoIconName ? /*#__PURE__*/_jsxDEV(DuoIconV2, {\n              name: activeInfo.DuoIconName,\n              size: 16\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 314,\n              columnNumber: 37\n            }, this) : activeInfo.IconName ? /*#__PURE__*/_jsxDEV(Icon, {\n              icon: activeInfo.IconName,\n              size: 14\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 318,\n              columnNumber: 41\n            }, this) : null\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 311,\n            columnNumber: 25\n          }, this), onKeyDown !== undefined && onKeyDown !== null || handleSearchOnClick !== undefined && handleSearchOnClick !== null ? /*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"text\",\n            ref: this.searchValueRef,\n            onKeyDown: event => this.keyPress(event),\n            placeholder: activeInfo.DisplayName,\n            value: searchValue,\n            onChange: event => this.handleChangeSearchValue(event),\n            style: {\n              paddingRight: \"20px\"\n            },\n            className: \"feature-search-input-box\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 326,\n            columnNumber: 33\n          }, this) : /*#__PURE__*/_jsxDEV(\"input\", {\n            type: \"text\",\n            ref: this.searchValueRef,\n            placeholder: activeInfo.DisplayName,\n            value: searchValue,\n            onChange: event => this.handleChangeSearchValue(event),\n            style: {\n              paddingRight: \"20px\"\n            },\n            className: \"feature-search-input-box\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 335,\n            columnNumber: 33\n          }, this), /*#__PURE__*/_jsxDEV(Icon, {\n            icon: \"search\",\n            size: \"14\",\n            className: \"filter-popup-search-icon\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 344,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"feature-search-dropdown\",\n            children: [/*#__PURE__*/_jsxDEV(Icon, {\n              icon: \"drop_down\",\n              size: \"small\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 347,\n              columnNumber: 29\n            }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"feature-search-box-drop-down-list\",\n              children: itemList.map((eachItemInfo, index) => /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"feature-search-box-drop-down-item\",\n                onClick: () => this.handleChangeSearchColumnName(eachItemInfo.Value),\n                children: [eachItemInfo.DuoIconName ? /*#__PURE__*/_jsxDEV(DuoIconV2, {\n                  name: eachItemInfo.DuoIconName,\n                  size: 14,\n                  className: \"feature-search-box-drop-down-icon\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 357,\n                  columnNumber: 53\n                }, this) : eachItemInfo.IconName ? /*#__PURE__*/_jsxDEV(Icon, {\n                  icon: eachItemInfo.IconName,\n                  size: 14,\n                  className: \"feature-search-box-drop-down-icon\"\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 362,\n                  columnNumber: 57\n                }, this) : null, \"Search by \" + eachItemInfo.DisplayName, searchColumnName === eachItemInfo.Value && /*#__PURE__*/_jsxDEV(\"div\", {\n                  className: \"feature-search-box-drop-down-check\",\n                  children: /*#__PURE__*/_jsxDEV(Icon, {\n                    icon: \"check_circle_outline\",\n                    size: 14\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 373,\n                    columnNumber: 53\n                  }, this)\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 372,\n                  columnNumber: 49\n                }, this)]\n              }, index, true, {\n                fileName: _jsxFileName,\n                lineNumber: 352,\n                columnNumber: 41\n              }, this))\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 349,\n              columnNumber: 29\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 345,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 310,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: this.props.handleSearchOnClick,\n          ref: this.searchBtnRef,\n          disabled: disableSearchBtn,\n          className: \"feature-search-box-btn\",\n          children: \"Search\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 382,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 309,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 308,\n      columnNumber: 13\n    }, this);\n  }\n}\nMultiColumnsSearchBox.defaultProps = {\n  width: \"unset\"\n};\nexport const prepareInitialPredictionParameters = inputTrainingParameters => {\n  let parameterInfoList = [];\n  let languageSelectedNeeded = false;\n  let newTrainingParameters = JSON.parse(JSON.stringify(inputTrainingParameters));\n  if (newTrainingParameters.length !== 0) {\n    newTrainingParameters.map(eachTrainingParameter => {\n      let disabledChanges = false;\n      if (eachTrainingParameter.Name === \"source_language\") {\n        languageSelectedNeeded = true;\n        disabledChanges = true;\n      } else if (eachTrainingParameter.Name === \"target_language\") {\n        languageSelectedNeeded = true;\n      }\n      let rangeCheck = false;\n      let possibleValues = [];\n      let multiInputCase = false;\n      let inputPossibleValues = [];\n      let inputValue = \"\";\n      let minValue = \"\";\n      let maxValue = \"\";\n      let selectedValue = eachTrainingParameter.DefaultValue;\n      if (eachTrainingParameter.Name === \"Labels\") {\n        // may need to check with domain name\n        multiInputCase = true;\n      } else {\n        if (isValidData(eachTrainingParameter.MinValue) && isValidData(eachTrainingParameter.MaxValue)) {\n          rangeCheck = true;\n          if (eachTrainingParameter.Type === \"int\") {\n            minValue = parseInt(eachTrainingParameter.MinValue);\n            if (eachTrainingParameter.MaxValue !== \"inf\") {\n              maxValue = parseInt(eachTrainingParameter.MaxValue);\n            } else {\n              maxValue = eachTrainingParameter.MaxValue;\n            }\n          } else if (eachTrainingParameter.Type === \"float\") {\n            minValue = parseFloat(eachTrainingParameter.MinValue);\n            if (eachTrainingParameter.MaxValue !== \"inf\") {\n              maxValue = parseFloat(eachTrainingParameter.MaxValue);\n            } else {\n              maxValue = eachTrainingParameter.MaxValue;\n            }\n          }\n        }\n      }\n      if (isValidData(eachTrainingParameter.PossibleValue)) {\n        possibleValues = eachTrainingParameter.PossibleValue.split(\",\");\n        selectedValue = possibleValues[0];\n        if (multiInputCase) {\n          inputPossibleValues = possibleValues;\n          inputValue = \"\";\n        }\n      }\n\n      //to add selected value\n      parameterInfoList = parameterInfoList.concat({\n        Name: eachTrainingParameter.Name,\n        Description: eachTrainingParameter.Description,\n        DefaultValue: eachTrainingParameter.DefaultValue,\n        PossibleValue: possibleValues,\n        Type: eachTrainingParameter.Type,\n        MinValue: minValue,\n        MaxValue: maxValue,\n        SelectedValue: selectedValue,\n        // for single selected case\n        InputPossibleValues: inputPossibleValues,\n        //for multiple input case\n        InputValue: inputValue,\n        checkValid: true,\n        rangeCheck: rangeCheck,\n        multiInputCase: multiInputCase,\n        disabledChanges: disabledChanges\n      });\n      return parameterInfoList;\n    });\n  }\n\n  // console.log(\"Prepared parameter info list : \", parameterInfoList)\n  return {\n    parameterInfoList,\n    languageSelectedNeeded\n  };\n};\nexport const getMlDataTypeSafety = dataType => {\n  //check if it is scaled or not\n  dataType = dataType.toLowerCase();\n  let mlDataType = dataType;\n  switch (dataType) {\n    case \"string\":\n      mlDataType = \"str\";\n      break;\n    case \"nlp\":\n      mlDataType = \"int\";\n      break;\n    case \"image\":\n      mlDataType = \"int\";\n      break;\n    case \"audio\":\n      mlDataType = \"int\";\n      break;\n    case \"video\":\n      mlDataType = \"int\";\n      break;\n    case \"tinyint\":\n      mlDataType = \"int\";\n      break;\n    case \"real\":\n      mlDataType = \"float\";\n      break;\n    case \"enum\":\n      mlDataType = \"int\";\n      break;\n    case \"integer\":\n      mlDataType = \"int\";\n      break;\n    case \"number\":\n      mlDataType = \"int\";\n      break;\n    case \"int32\":\n      mlDataType = \"int\";\n      break;\n    case \"int64\":\n      mlDataType = \"int\";\n      break;\n    case \"float32\":\n      mlDataType = \"float\";\n      break;\n    case \"float64\":\n      mlDataType = \"float\";\n      break;\n    case \"double\":\n      mlDataType = \"float\";\n      break;\n    case \"varchar\":\n      mlDataType = \"string\";\n      break;\n    case \"complex\":\n      mlDataType = \"float\";\n      break;\n    case \"varchar2\":\n      mlDataType = \"string\";\n      break;\n    case \"text\":\n      mlDataType = \"string\";\n      break;\n    case \"char varying\":\n      mlDataType = \"string\";\n      break;\n  }\n  return mlDataType;\n};\nexport const checkAllItemsUnSelected = items => {\n  let allUnSelected = true;\n  for (let index = 0; index < items.length; index++) {\n    if (items[index].isSelected === true) {\n      allUnSelected = false;\n      break;\n    }\n  }\n  return allUnSelected;\n};\nexport const checkAllItemsSelected = items => {\n  let allSelected = true;\n  for (let index = 0; index < items.length; index++) {\n    if (items[index].isSelected === false) {\n      allSelected = false;\n      break;\n    }\n  }\n  return allSelected;\n};\nexport const checkAndUpdateSelectAllItems = (selectAllItems, itemInfoList, itemSelected) => {\n  if (selectAllItems === true) {\n    if (itemSelected === false) {\n      // check all cards are false or not if the current info is unselected\n      let allUnSelected = checkAllItemsUnSelected(itemInfoList);\n      if (allUnSelected === true) {\n        selectAllItems = false;\n      }\n    } // else => it is clear that all items are not unselected, because current card is selected\n  } else {\n    if (itemSelected === true) {\n      let allSelected = checkAllItemsSelected(itemInfoList);\n      if (allSelected === true) {\n        selectAllItems = true;\n      }\n    } // else => all items cannot be selected case, because current item is un selected\n  }\n  return selectAllItems;\n};\nexport const getDataTypeTag = dataType => {\n  if (isValidData(dataType)) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"default-data-type-tag \" + dataType,\n      children: dataType.charAt(0).toUpperCase() + dataType.slice(1)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 596,\n      columnNumber: 13\n    }, this);\n  } else {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"default-data-type-tag\",\n      style: {\n        background: \"transparent\"\n      },\n      children: \"-\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 602,\n      columnNumber: 13\n    }, this);\n  }\n};\nconst checkAndAppendUniqueIDs = (allIDs, inputID) => {\n  if (isValidData(inputID)) {\n    if (!allIDs.includes(inputID)) {\n      allIDs.push(inputID);\n    }\n  }\n  return allIDs;\n};\nconst checkAndAppendUniqueIDsForMultiLabels = (allIDs, inputIDs) => {\n  if (hasDataList(inputIDs)) {\n    inputIDs.map(eachID => {\n      if (!allIDs.includes(eachID)) {\n        allIDs.push(eachID);\n      }\n    });\n  }\n  return allIDs;\n};\nexport const convertPredictionResults = (predictionResults, multiLabelModel, multiOutputModel, outputColumnList, multiClass, patentIDs, classificationIDs, historyTab, pageNumber, pageSize, patentInsight, showRelevanceValue) => {\n  if (multiOutputModel === true) {\n    let checkedData = convertPredictionResultsForMultiOutputColumns(predictionResults, multiLabelModel, outputColumnList, multiClass, patentIDs, classificationIDs, historyTab, pageNumber, pageSize, patentInsight, showRelevanceValue);\n    return {\n      tableRowCount: checkedData.tableRowCount,\n      patentIDs: checkedData.patentIDs,\n      predictionIDs: checkedData.predictionIDs,\n      specificPatentIDs: checkedData.specificPatentIDs,\n      classificationIDs: checkedData.classificationIDs,\n      predictionResults: checkedData.predictionResults,\n      patentIDsHashmapByPredictionID: checkedData.patentIDsHashmapByPredictionID\n    };\n  }\n  let specificPatentIDs = [];\n  let patentIDsHashmapByPredictionID = {};\n  let predictionIDs = [];\n  let rowCountForMultiLabelModel = 0;\n  if (hasDataList(predictionResults)) {\n    predictionResults.map((eachPatent, patentIndex) => {\n      eachPatent[\"no\"] = getSerialRowNumber(pageNumber, pageSize, patentIndex);\n      if (patentInsight === true) {\n        // prepare for nested hashmap\n        let patentID = eachPatent.PatentID;\n        let predictionID = eachPatent.PredictionID;\n        if (patentIDsHashmapByPredictionID[predictionID] !== undefined) {\n          let includedPatentIDs = patentIDsHashmapByPredictionID[predictionID];\n          if (!includedPatentIDs.includes(patentID)) {\n            includedPatentIDs.push(patentID);\n            patentIDsHashmapByPredictionID[predictionID] = includedPatentIDs;\n          }\n        } else {\n          patentIDsHashmapByPredictionID[predictionID] = [patentID];\n        }\n        if (!predictionIDs.includes(predictionID)) {\n          predictionIDs.push(predictionID);\n        }\n      }\n      if (!patentIDs.includes(eachPatent.PatentID)) {\n        patentIDs.push(eachPatent.PatentID);\n      }\n      if (!specificPatentIDs.includes(eachPatent.PatentID)) {\n        specificPatentIDs.push(eachPatent.PatentID);\n      }\n      if (isValidData(eachPatent.Output)) {\n        eachPatent.Output = eachPatent.Output.toString();\n        let eachPatentOutput;\n        if (historyTab === true) {\n          eachPatentOutput = eachPatent.Output.slice(0, eachPatent.Output.length);\n        } else {\n          // check if output is included double quote or not\n          if (eachPatent.Output.includes(\"\\\"\")) {\n            eachPatentOutput = eachPatent.Output.slice(1, eachPatent.Output.length - 1);\n          } else {\n            eachPatentOutput = eachPatent.Output.slice(0, eachPatent.Output.length);\n          }\n        }\n        if (eachPatentOutput.includes(\",\")) {\n          let splitArr = eachPatentOutput.split(\",\");\n          let outputArr = [];\n          splitArr.map(eachClass => {\n            eachClass = eachClass.replaceAll(\"\\\"\", \"\");\n            if (historyTab !== true) {\n              if (isValidData(eachClass)) {\n                if (eachClass && eachClass.includes(\"\\\"\")) {\n                  eachClass = eachClass.replaceAll(\"\\\"\", \"\");\n                }\n                let jsonStr = '{\"Output\":\"' + eachClass + '\"}';\n                let jsonParsed = JSON.parse(jsonStr);\n                eachClass = jsonParsed.Output;\n              }\n            }\n            if (eachClass.startsWith(\"[\")) {\n              let innerSplitArr = eachClass.split(\"[\");\n              eachClass = innerSplitArr[innerSplitArr.length - 1];\n            } else if (eachClass.endsWith(\"]\")) {\n              let innerSplitArr = eachClass.split(\"]\");\n              eachClass = innerSplitArr[0];\n            }\n            outputArr.push(eachClass);\n            classificationIDs = checkAndAppendUniqueIDs(classificationIDs, eachClass);\n          });\n          eachPatent.Output = outputArr;\n        } else {\n          if (historyTab !== true) {\n            if (isValidData(eachPatentOutput)) {\n              if (eachPatentOutput && eachPatentOutput.includes(\"\\\"\")) {\n                eachPatentOutput = eachPatentOutput.replaceAll(\"\\\"\", \"\");\n              }\n              let jsonStr = '{\"Output\":\"' + eachPatentOutput + '\"}';\n              let jsonParsed = JSON.parse(jsonStr);\n              eachPatentOutput = jsonParsed.Output;\n            }\n          }\n          if (multiLabelModel === true) {\n            let newClassIDs = eachPatentOutput.split(multiLabelSeparator);\n            eachPatent.Output = newClassIDs;\n            classificationIDs = checkAndAppendUniqueIDsForMultiLabels(classificationIDs, newClassIDs);\n            let eachRowCount = 1;\n            if (newClassIDs.length > 0) {\n              eachRowCount = newClassIDs.length;\n            }\n            rowCountForMultiLabelModel += eachRowCount;\n          } else {\n            if (multiClass === true) {\n              eachPatent.Output = [eachPatentOutput];\n            } else {\n              eachPatent.Output = eachPatentOutput;\n            }\n            classificationIDs = checkAndAppendUniqueIDs(classificationIDs, eachPatentOutput);\n          }\n        }\n      } else {\n        if (multiClass === true) {\n          eachPatent.Output = [];\n        } else {\n          if (multiLabelModel === true) {\n            eachPatent.Output = [];\n            rowCountForMultiLabelModel += 1;\n          } else {\n            eachPatent.Output = \"\";\n          }\n        }\n      }\n\n      // check for score value\n      if (showRelevanceValue === true) {\n        if (isValidData(eachPatent[\"Score\"])) {\n          eachPatent.Score = eachPatent.Score.toString();\n          // console.log(\"#eachPatent.Score: \", historyTab, \", \", eachPatent.Score)\n          let eachPatentScoreValue;\n          if (historyTab === true) {\n            eachPatentScoreValue = eachPatent.Score.slice(0, eachPatent.Score.length);\n          } else {\n            // check if output is included double quote or not\n            if (eachPatent.Score.includes(\"\\\"\")) {\n              eachPatentScoreValue = eachPatent.Score.slice(1, eachPatent.Score.length - 1);\n            } else {\n              eachPatentScoreValue = eachPatent.Score.slice(0, eachPatent.Score.length);\n            }\n          }\n\n          // checking for multiple class case\n          if (eachPatentScoreValue.includes(\",\")) {\n            let splitArr = eachPatentScoreValue.split(\",\");\n            // console.log(\"#patent split arr: \", splitArr)\n            let scoreValueArr = [];\n            let originalValueArr = [];\n            splitArr.map(eachScoreValue => {\n              eachScoreValue = eachScoreValue.replaceAll(\"\\\"\", \"\");\n              eachScoreValue = eachScoreValue.replaceAll(\"[\", \"\");\n              if (historyTab !== true) {\n                if (isValidData(eachScoreValue)) {\n                  let jsonStr = '{\"Score\":\"' + eachScoreValue + '\"}';\n                  let jsonParsed = JSON.parse(jsonStr);\n                  eachScoreValue = jsonParsed.Score;\n                }\n              }\n              originalValueArr.push(parseFloat(eachScoreValue));\n              let eachFixedScore = getFixedNumber(eachScoreValue, 4, 4);\n              scoreValueArr.push(eachFixedScore);\n            });\n            eachPatent.Confidence = \"\";\n            eachPatent.OriginalRelevanceValue = 0;\n            eachPatent.RelevanceValueArr = scoreValueArr; // multiple case\n            eachPatent.OriginalRelevanceValueArr = originalValueArr; // for number value\n          } else {\n            if (historyTab !== true) {\n              if (isValidData(eachPatentScoreValue)) {\n                let jsonStr = '{\"Score\":\"' + eachPatentScoreValue + '\"}';\n                let jsonParsed = JSON.parse(jsonStr);\n                eachPatentScoreValue = jsonParsed.Score;\n              }\n            }\n            if (multiLabelModel === true) {\n              let scoreValueArr = eachPatentScoreValue.split(multiLabelSeparator);\n              let relevanceArr = [];\n              scoreValueArr.map(eachScoreValue => {\n                relevanceArr.push(getFixedNumber(eachScoreValue, 4, 4));\n              });\n              eachPatent.Confidence = \"\";\n              eachPatent.RelevanceValueArr = relevanceArr;\n              eachPatent.OriginalRelevanceValue = scoreValueArr;\n            } else {\n              eachPatentScoreValue = getFixedNumber(eachPatentScoreValue, 4, 4);\n              if (multiClass === true) {\n                eachPatent.Confidence = \"\";\n                eachPatent.RelevanceValueArr = [eachPatentScoreValue];\n                eachPatent.OriginalRelevanceValue = [parseFloat(eachPatentScoreValue)];\n              } else {\n                eachPatent.Confidence = eachPatentScoreValue;\n                eachPatent.OriginalRelevanceValue = parseFloat(eachPatentScoreValue);\n              }\n            }\n          }\n        } else {\n          if (multiLabelModel === true) {\n            eachPatent.Confidence = \"\";\n            eachPatent.RelevanceValueArr = [];\n            eachPatent.OriginalRelevanceValue = [];\n          } else {\n            if (multiClass === true) {\n              eachPatent.RelevanceValueArr = [];\n              eachPatent.OriginalRelevanceValueArr = [];\n            } else {\n              eachPatent.Confidence = \"\";\n              eachPatent.OriginalRelevanceValue = 0;\n            }\n          }\n        }\n      }\n    });\n  }\n\n  // console.log(\"#patentIDsHashmapByPredictionID: \", patentIDsHashmapByPredictionID)\n  // console.log(\"#predictionIDs: \", predictionIDs)\n  // console.log(\"#converted predictionResults: \", predictionResults)\n  let tableRowCount = multiLabelModel === true ? rowCountForMultiLabelModel : predictionResults.length;\n  return {\n    tableRowCount,\n    patentIDs,\n    predictionIDs,\n    specificPatentIDs,\n    classificationIDs,\n    predictionResults,\n    patentIDsHashmapByPredictionID\n  };\n};\nexport const convertPredictionResultsForMultiOutputColumns = (predictionResults, multiLabelModel, outputColumnList, multiClass, patentIDs, classificationIDs, historyTab, pageNumber, pageSize, patentInsight, showRelevanceValue) => {\n  let specificPatentIDs = [];\n  let patentIDsHashmapByPredictionID = {};\n  let predictionIDs = [];\n  let rowCountForMultiLabelModel = 0;\n  if (hasDataList(predictionResults)) {\n    predictionResults.map((eachPatent, patentIndex) => {\n      eachPatent[\"no\"] = getSerialRowNumber(pageNumber, pageSize, patentIndex);\n      if (patentInsight === true) {\n        // prepare for nested hashmap\n        let patentID = eachPatent.PatentID;\n        let predictionID = eachPatent.PredictionID;\n        if (patentIDsHashmapByPredictionID[predictionID] !== undefined) {\n          let includedPatentIDs = patentIDsHashmapByPredictionID[predictionID];\n          if (!includedPatentIDs.includes(patentID)) {\n            includedPatentIDs.push(patentID);\n            patentIDsHashmapByPredictionID[predictionID] = includedPatentIDs;\n          }\n        } else {\n          patentIDsHashmapByPredictionID[predictionID] = [patentID];\n        }\n        if (!predictionIDs.includes(predictionID)) {\n          predictionIDs.push(predictionID);\n        }\n      }\n      if (!patentIDs.includes(eachPatent.PatentID)) {\n        patentIDs.push(eachPatent.PatentID);\n      }\n      if (!specificPatentIDs.includes(eachPatent.PatentID)) {\n        specificPatentIDs.push(eachPatent.PatentID);\n      }\n      if (isValidData(eachPatent.Output)) {\n        let outputValueHashmap; // for all output columns (it will be with hashmap as string type)\n        if (historyTab === true) {\n          outputValueHashmap = eachPatent.Output.slice(0, eachPatent.Output.length);\n        } else {\n          outputValueHashmap = JSON.parse(eachPatent.Output);\n        }\n        outputColumnList.map(eachOutputColumn => {\n          let eachPatentOutput = isValidData(outputValueHashmap[eachOutputColumn]) ? outputValueHashmap[eachOutputColumn] : \"\";\n          if (Array.isArray(eachPatentOutput)) {\n            let splitArr = eachPatentOutput;\n            let outputArr = [];\n            splitArr.map(eachClass => {\n              outputArr.push(eachClass);\n              classificationIDs = checkAndAppendUniqueIDs(classificationIDs, eachClass);\n            });\n            outputValueHashmap[eachOutputColumn] = outputArr;\n          } else {\n            if (historyTab !== true) {\n              if (isValidData(eachPatentOutput)) {\n                if (eachPatentOutput && eachPatentOutput.includes(\"\\\"\")) {\n                  eachPatentOutput = eachPatentOutput.replaceAll(\"\\\"\", \"\");\n                }\n                let jsonStr = '{\"Output\":\"' + eachPatentOutput + '\"}';\n                let jsonParsed = JSON.parse(jsonStr);\n                eachPatentOutput = jsonParsed.Output;\n              }\n            }\n            if (multiLabelModel === true) {\n              let newClassIDs = eachPatentOutput.split(multiLabelSeparator);\n              outputValueHashmap[eachOutputColumn] = newClassIDs;\n              classificationIDs = checkAndAppendUniqueIDsForMultiLabels(classificationIDs, newClassIDs);\n              let eachRowCount = 1;\n              if (newClassIDs.length > 0) {\n                eachRowCount = newClassIDs.length;\n              }\n              rowCountForMultiLabelModel += eachRowCount;\n            } else {\n              if (multiClass === true) {\n                outputValueHashmap[eachOutputColumn] = [eachPatentOutput];\n              } else {\n                outputValueHashmap[eachOutputColumn] = eachPatentOutput;\n              }\n              classificationIDs = checkAndAppendUniqueIDs(classificationIDs, eachPatentOutput);\n            }\n          }\n        });\n        eachPatent.Output = outputValueHashmap;\n      } else {\n        if (multiClass === true) {\n          eachPatent.Output = {};\n        } else {\n          if (multiLabelModel === true) {\n            eachPatent.Output = {};\n            rowCountForMultiLabelModel += 1;\n          } else {\n            eachPatent.Output = {};\n          }\n        }\n      }\n\n      // check for score value\n      if (showRelevanceValue === true) {\n        if (isValidData(eachPatent[\"Score\"])) {\n          // eachPatent.Score = eachPatent.Score.toString()\n          // console.log(\"#eachPatent.Score: \", historyTab, \", \", eachPatent.Score)\n          let scoreValueHashmap;\n          if (historyTab === true) {\n            scoreValueHashmap = eachPatent.Score.slice(0, eachPatent.Score.length);\n          } else {\n            scoreValueHashmap = JSON.parse(eachPatent[\"Score\"]);\n          }\n\n          // console.log(\"#scoreValueHashmap: \", scoreValueHashmap)\n          // set initial value (defined initial value)\n          outputColumnList.map(eachColumn => {\n            let eachPatentScoreValue = scoreValueHashmap[eachColumn];\n            if (hasDataList(eachPatentScoreValue)) {\n              let splitArr = eachPatentScoreValue;\n              let scoreValueArr = [];\n              let originalValueArr = [];\n              splitArr.map(eachScoreValue => {\n                originalValueArr.push(eachScoreValue);\n                let eachFixedScore = getFixedNumber(eachScoreValue.toString(), 4, 4);\n                scoreValueArr.push(eachFixedScore);\n              });\n              eachPatent[eachColumn + \"_Confidence\"] = \"\";\n              eachPatent[eachColumn + \"_OriginalRelevanceValue\"] = 0;\n              eachPatent[eachColumn + \"_RelevanceValueArr\"] = scoreValueArr;\n              eachPatent[eachColumn + \"_OriginalRelevanceValueArr\"] = originalValueArr;\n            } else {\n              if (historyTab !== true) {\n                if (isValidData(eachPatentScoreValue)) {\n                  let jsonStr = '{\"Score\":\"' + eachPatentScoreValue + '\"}';\n                  let jsonParsed = JSON.parse(jsonStr);\n                  eachPatentScoreValue = jsonParsed.Score;\n                }\n              }\n              if (multiLabelModel === true) {\n                let scoreValueArr = eachPatentScoreValue.split(multiLabelSeparator);\n                let relevanceArr = [];\n                scoreValueArr.map(eachScoreValue => {\n                  relevanceArr.push(getFixedNumber(eachScoreValue, 4, 4));\n                });\n                eachPatent[eachColumn + \"_Confidence\"] = \"\";\n                eachPatent[eachColumn + \"_RelevanceValueArr\"] = relevanceArr;\n                eachPatent[eachColumn + \"_OriginalRelevanceValueArr\"] = scoreValueArr;\n              } else {\n                eachPatentScoreValue = eachPatentScoreValue.toString();\n                eachPatentScoreValue = getFixedNumber(eachPatentScoreValue, 4, 4);\n                if (multiClass === true) {\n                  eachPatent[eachColumn + \"_Confidence\"] = \"\";\n                  eachPatent[eachColumn + \"_RelevanceValueArr\"] = [eachPatentScoreValue];\n                  eachPatent[eachColumn + \"_OriginalRelevanceValueArr\"] = [parseFloat(eachPatentScoreValue)];\n                } else {\n                  eachPatent[eachColumn + \"_Confidence\"] = eachPatentScoreValue;\n                  eachPatent[eachColumn + \"_OriginalRelevanceValue\"] = parseFloat(eachPatentScoreValue);\n                }\n              }\n            }\n          });\n        } else {\n          if (multiLabelModel === true) {\n            outputColumnList.map(eachColumn => {\n              eachPatent[eachColumn + \"_Confidence\"] = \"\";\n              eachPatent[eachColumn + \"_RelevanceValueArr\"] = [];\n              eachPatent[eachColumn + \"_OriginalRelevanceValue\"] = [];\n            });\n          } else {\n            outputColumnList.map(eachColumn => {\n              if (multiClass === true) {\n                eachPatent[eachColumn + \"_RelevanceValueArr\"] = [];\n                eachPatent[eachColumn + \"_OriginalRelevanceValueArr\"] = [];\n              } else {\n                eachPatent[eachColumn + \"_Confidence\"] = \"\";\n                eachPatent[eachColumn + \"_OriginalRelevanceValue\"] = 0;\n              }\n            });\n          }\n        }\n      }\n    });\n  }\n\n  // console.log(\"#patentIDsHashmapByPredictionID: \", patentIDsHashmapByPredictionID)\n  // console.log(\"#predictionIDs: \", predictionIDs)\n  // console.log(\"#converted predictionResults: \", predictionResults)\n  let tableRowCount = multiLabelModel === true ? rowCountForMultiLabelModel : predictionResults.length;\n  return {\n    tableRowCount,\n    patentIDs,\n    predictionIDs,\n    specificPatentIDs,\n    classificationIDs,\n    predictionResults,\n    patentIDsHashmapByPredictionID\n  };\n};\nexport const checkPasswordValidation = inputPassword => {\n  let valid = /^(?=.*[!\"'()+,-./:;<=>?\\\\_`~@#$%^&*{}|])/.test(inputPassword); // Should include special character\n  if (valid) {\n    let PasswordValidator = require('password-validator');\n    let Schema = new PasswordValidator();\n    Schema.is().min(8) // Minimum length 8\n    .is().max(100) // Maximum length 100\n    .has().uppercase() // Must have uppercase letters\n    .has().lowercase() // Must have lowercase letters\n    .has().digits() // Must have digits\n    .has().not().spaces() // Should not have spaces\n    .is().not().oneOf(['Passw0rd', 'Password123']);\n    valid = Schema.validate(inputPassword, {\n      list: false\n    });\n  }\n  console.log(\"Valid password - \", inputPassword, \" => \", valid);\n  return valid;\n};\nexport const getPosition = (type, rowNumberWidth, includedCheckbox, includedTitle, includedAbstract, includedDescription) => {\n  let checkboxSpace = includedCheckbox ? checkboxWidth : rowNumberWidth;\n  let titleSpace = includedTitle ? titleWidth : rowNumberWidth;\n  // let abstractSpace = includedAbstract ? abstractWidth : rowNumberWidth;\n  let descriptionSpace = includedDescription ? descriptionWidth : rowNumberWidth;\n  if (type === \"checkbox\") {\n    return 0;\n  } else if (type === \"Patent ID\") {\n    return checkboxSpace;\n  } else if (type === \"Title\") {\n    return patentIDWidth + checkboxSpace;\n  } else if (type === \"Abstract\") {\n    return patentIDWidth + checkboxSpace + titleSpace;\n  } else if (type === \"Description\") {\n    return patentIDWidth + checkboxSpace + titleSpace + descriptionSpace;\n  }\n};\nexport const checkAndAssignedPatentValueForPredictionResults = (predictionResultList, patentValueHashmap) => {\n  predictionResultList.map(eachPatent => {\n    let title = \"\";\n    let description = \"\";\n    let abstract = \"\";\n    if (isValidData(patentValueHashmap[eachPatent.PatentID])) {\n      title = patentValueHashmap[eachPatent.PatentID].Title;\n      description = patentValueHashmap[eachPatent.PatentID].Description;\n      abstract = patentValueHashmap[eachPatent.PatentID].Abstract;\n    }\n    eachPatent.Title = title;\n    eachPatent.Description = description;\n    eachPatent.Abstract = abstract;\n  });\n  return predictionResultList;\n};\nexport const prepareClassificationInfoForPredictionResults = function (multiLabelModel, multiOutputModel, outputColumnList, outputAndNoOfClasses, hideClassificationHyperlink) {\n  let classificationColumnName = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"\";\n  let headerList = arguments.length > 6 ? arguments[6] : undefined;\n  let outputClassList = arguments.length > 7 ? arguments[7] : undefined;\n  let predictionResults = arguments.length > 8 ? arguments[8] : undefined;\n  let classificationNameHashmap = arguments.length > 9 ? arguments[9] : undefined;\n  let outputNodeNameHashmap = arguments.length > 10 ? arguments[10] : undefined;\n  let classifiedDateHashmap = arguments.length > 11 ? arguments[11] : undefined;\n  let showRelevanceValue = arguments.length > 12 ? arguments[12] : undefined;\n  let showCompanyName = arguments.length > 13 ? arguments[13] : undefined;\n  if (multiOutputModel === true) {\n    let checkData = prepareClassificationInfoForResultsOfMultiOutputColumns(multiLabelModel, outputColumnList, outputAndNoOfClasses, hideClassificationHyperlink, headerList, outputClassList, predictionResults, classificationNameHashmap, outputNodeNameHashmap, classifiedDateHashmap, showRelevanceValue, showCompanyName);\n    return {\n      headerList: checkData.headerList,\n      predictionResults: checkData.predictionResults\n    };\n  }\n  // for company name\n  if (showCompanyName === true) {\n    headerList.push({\n      DisplayName: \"Competitor Name\",\n      Key: \"CompanyName\",\n      NodeName: \"CompanyName\",\n      OutputColumn: false,\n      Pinned: true\n    });\n  }\n  if (hasDataList(outputClassList) && outputClassList.length > 1) {\n    let outputHeaderList = [];\n    outputClassList.map((eachClassHeader, outputClassIndex) => {\n      // header\n      outputHeaderList.push({\n        DisplayName: eachClassHeader,\n        NodeName: eachClassHeader,\n        Key: \"output\" + (outputClassIndex + 1),\n        ShowToolTip: true,\n        HideHyperlink: hideClassificationHyperlink,\n        OutputColumn: true\n      });\n    });\n\n    // to check and assign for reference data, for performance, checked condition outside\n    if (showRelevanceValue === true) {\n      if (isValidData(classificationNameHashmap)) {\n        if (hasDataList(predictionResults)) {\n          predictionResults.map(eachDataRow => {\n            if (Array.isArray(eachDataRow.Output)) {\n              let relevanceValueArr = eachDataRow.RelevanceValueArr;\n              let originalRelevanceValueArr = eachDataRow.RelevanceValueArr;\n              outputHeaderList.map((eachHeader, headerIndex) => {\n                let value = \"\";\n                if (isValidData(eachDataRow.Output[headerIndex])) {\n                  value = eachDataRow.Output[headerIndex];\n                }\n                eachDataRow[eachHeader.Key] = value; // for classification value\n\n                // for relevance value (output key _ relevance)\n                let eachRelevanceValue = \"\";\n                let eachRelevanceKey = eachHeader.Key + \"___relevance\";\n                if (isValidData(relevanceValueArr[headerIndex])) {\n                  eachRelevanceValue = relevanceValueArr[headerIndex];\n                }\n                eachDataRow[eachRelevanceKey] = eachRelevanceValue; // for relevance value\n\n                let eachOriginalRelevanceValue = 0;\n                let eachOriginalRelevanceKey = \"original___\" + eachRelevanceKey;\n                if (isValidData(originalRelevanceValueArr[headerIndex])) {\n                  eachOriginalRelevanceValue = originalRelevanceValueArr[headerIndex];\n                }\n                eachDataRow[eachOriginalRelevanceKey] = eachOriginalRelevanceValue;\n              });\n            } else {\n              // for class count = 1 case\n              outputHeaderList.map((eachHeader, headerIndex) => {\n                let value = \"\";\n                if (headerIndex === 0) {\n                  value = eachDataRow.Output;\n                }\n                eachDataRow[eachHeader.Key] = value; // for classification value\n              });\n            }\n            if (isValidData(classifiedDateHashmap)) {\n              if (classifiedDateHashmap[eachDataRow.PredictionID]) {\n                eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID];\n              } else if (eachDataRow.CreatedAt) {\n                eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt);\n              } else {\n                eachDataRow[\"ClassifiedDate\"] = \"-\";\n              }\n            }\n          });\n        }\n      } else {\n        predictionResults.map(eachDataRow => {\n          if (Array.isArray(eachDataRow.Output)) {\n            outputHeaderList.map((eachHeader, headerIndex) => {\n              let value = \"\";\n              if (isValidData(eachDataRow.Output[headerIndex])) {\n                value = eachDataRow.Output[headerIndex];\n              }\n              eachDataRow[eachHeader.Key] = value; // for classification value\n            });\n          } else {\n            outputHeaderList.map((eachHeader, headerIndex) => {\n              let value = \"\";\n              if (headerIndex === 0) {\n                value = eachDataRow.Output;\n              }\n              eachDataRow[eachHeader.Key] = value; // for classification value\n            });\n          }\n        });\n      }\n    } else {\n      if (isValidData(classificationNameHashmap)) {\n        if (hasDataList(predictionResults)) {\n          predictionResults.map(eachDataRow => {\n            if (Array.isArray(eachDataRow.Output)) {\n              outputHeaderList.map((eachHeader, headerIndex) => {\n                let value = \"\";\n                if (isValidData(eachDataRow.Output[headerIndex])) {\n                  value = eachDataRow.Output[headerIndex];\n                }\n                eachDataRow[eachHeader.Key] = value; // for classification value\n              });\n            } else {\n              outputHeaderList.map((eachHeader, headerIndex) => {\n                let value = \"\";\n                if (headerIndex === 0) {\n                  value = eachDataRow.Output;\n                }\n                eachDataRow[eachHeader.Key] = value; // for classification value\n              });\n            }\n            if (isValidData(classifiedDateHashmap)) {\n              if (classifiedDateHashmap[eachDataRow.PredictionID]) {\n                eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID];\n              } else if (eachDataRow.CreatedAt) {\n                eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt);\n              } else {\n                eachDataRow[\"ClassifiedDate\"] = \"-\";\n              }\n            }\n          });\n        }\n      } else {\n        predictionResults.map(eachDataRow => {\n          if (Array.isArray(eachDataRow.Output)) {\n            outputHeaderList.map((eachHeader, headerIndex) => {\n              let value = \"\";\n              if (isValidData(eachDataRow.Output[headerIndex])) {\n                value = eachDataRow.Output[headerIndex];\n              }\n              eachDataRow[eachHeader.Key] = value; // for classification value\n            });\n          } else {\n            outputHeaderList.map((eachHeader, headerIndex) => {\n              let value = \"\";\n              if (headerIndex === 0) {\n                value = eachDataRow.Output;\n              }\n              eachDataRow[eachHeader.Key] = value; // for classification value\n            });\n          }\n        });\n      }\n    }\n    headerList = headerList.concat(outputHeaderList);\n  } else {\n    if (hideClassificationHyperlink === true) {\n      let className = classificationColumnName !== \"\" ? classificationColumnName : \"Classification Name\";\n      headerList.push({\n        DisplayName: isValidData(outputNodeNameHashmap[className]) && isValidData(outputNodeNameHashmap[className].ColumnName) ? outputNodeNameHashmap[className].ColumnName : className,\n        Key: \"classificationID\",\n        NodeName: classificationColumnName !== \"\" ? classificationColumnName : \"Classification Name\",\n        OutputColumn: true,\n        MultiValueLabel: multiLabelModel\n      });\n    } else {\n      let classID = \"Classification ID\";\n      headerList.push({\n        DisplayName: isValidData(outputNodeNameHashmap[classID]) && isValidData(outputNodeNameHashmap[classID].ColumnName) ? outputNodeNameHashmap[classID].ColumnName : classID,\n        Key: \"classificationID\",\n        NodeName: \"Classification ID\",\n        OutputColumn: true,\n        MultiValueLabel: multiLabelModel\n      });\n      let className = \"Classification Name\";\n      headerList.push({\n        DisplayName: isValidData(outputNodeNameHashmap[className]) && isValidData(outputNodeNameHashmap[className].ColumnName) ? outputNodeNameHashmap[className].ColumnName : className,\n        Key: \"classificationName\",\n        NodeName: \"Classification Name\",\n        OutputColumn: true,\n        MultiValueLabel: multiLabelModel\n      });\n    }\n    if (hideClassificationHyperlink === true) {\n      if (isValidData(classifiedDateHashmap)) {\n        predictionResults.map(eachDataRow => {\n          if (multiLabelModel === true) {\n            let classificationIDs = [];\n            if (hasDataList(eachDataRow.Output)) {\n              classificationIDs = eachDataRow.Output;\n            }\n            eachDataRow[\"classificationID\"] = classificationIDs;\n          } else {\n            eachDataRow[\"classificationID\"] = getClassificationID(eachDataRow.Output);\n          }\n          if (classifiedDateHashmap[eachDataRow.PredictionID]) {\n            eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID];\n          } else if (eachDataRow.CreatedAt) {\n            eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt);\n          } else {\n            eachDataRow[\"ClassifiedDate\"] = \"-\";\n          }\n        });\n      } else {\n        predictionResults.map(eachDataRow => {\n          if (multiLabelModel === true) {\n            let classificationIDs = [];\n            if (hasDataList(eachDataRow.Output)) {\n              classificationIDs = eachDataRow.Output;\n            }\n            eachDataRow[\"classificationID\"] = classificationIDs;\n          } else {\n            eachDataRow[\"classificationID\"] = getClassificationID(eachDataRow.Output);\n          }\n        });\n      }\n    } else {\n      if (isValidData(classifiedDateHashmap)) {\n        predictionResults.map(eachDataRow => {\n          if (multiLabelModel === true) {\n            let classificationIDs = [];\n            let classificationNames = [];\n            if (hasDataList(eachDataRow.Output)) {\n              classificationIDs = eachDataRow.Output;\n              classificationIDs.map(eachClassID => {\n                let eachClassName = classificationNameHashmap[eachClassID];\n                classificationNames.push(eachClassName);\n              });\n            }\n            eachDataRow[\"classificationID\"] = classificationIDs;\n            eachDataRow[\"classificationName\"] = classificationNames;\n          } else {\n            let classificationID = getClassificationID(eachDataRow.Output);\n            let classificationName = classificationNameHashmap[classificationID];\n            eachDataRow[\"classificationID\"] = classificationID;\n            eachDataRow[\"classificationName\"] = classificationName;\n          }\n          if (classifiedDateHashmap[eachDataRow.PredictionID]) {\n            eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID];\n          } else if (eachDataRow.CreatedAt) {\n            eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt);\n          } else {\n            eachDataRow[\"ClassifiedDate\"] = \"-\";\n          }\n        });\n      } else {\n        predictionResults.map(eachDataRow => {\n          if (multiLabelModel === true) {\n            let classificationIDs = [];\n            let classificationNames = [];\n            if (hasDataList(eachDataRow.Output)) {\n              classificationIDs = eachDataRow.Output;\n              classificationIDs.map(eachClassID => {\n                let eachClassName = classificationNameHashmap[eachClassID];\n                classificationNames.push(eachClassName);\n              });\n            }\n            eachDataRow[\"classificationID\"] = classificationIDs;\n            eachDataRow[\"classificationName\"] = classificationNames;\n          } else {\n            let classificationID = getClassificationID(eachDataRow.Output);\n            let classificationName = classificationNameHashmap[classificationID];\n            eachDataRow[\"classificationID\"] = classificationID;\n            eachDataRow[\"classificationName\"] = classificationName;\n          }\n        });\n      }\n    }\n\n    // for single class count case\n    if (showRelevanceValue === true) {\n      let displayName = \"Confidence\";\n      if (isValidData(outputNodeNameHashmap) && isValidData(outputNodeNameHashmap[\"Confidence\"]) && outputNodeNameHashmap[\"Confidence\"].ColumnName !== undefined) {\n        displayName = outputNodeNameHashmap[\"Confidence\"].ColumnName;\n      }\n      let key = \"Confidence\";\n      if (multiLabelModel === true) {\n        key = \"RelevanceValueArr\";\n      }\n      headerList.push({\n        DisplayName: displayName,\n        Key: key,\n        NodeName: \"Confidence\",\n        OutputColumn: false,\n        Pinned: true,\n        MultiValueLabel: multiLabelModel\n      });\n    }\n  }\n\n  // console.log(\"#header list after prepared: \", headerList)\n  // console.log(\"#outputNodeNameHashmap: \", outputNodeNameHashmap)\n\n  return {\n    headerList,\n    predictionResults\n  };\n};\nexport const prepareClassificationInfoForResultsOfMultiOutputColumns = function (multiLabelModel, outputColumnList) {\n  let outputAndNoOfClasses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let hideClassificationHyperlink = arguments.length > 3 ? arguments[3] : undefined;\n  let headerList = arguments.length > 4 ? arguments[4] : undefined;\n  let outputClassList = arguments.length > 5 ? arguments[5] : undefined;\n  let predictionResults = arguments.length > 6 ? arguments[6] : undefined;\n  let classificationNameHashmap = arguments.length > 7 ? arguments[7] : undefined;\n  let outputNodeNameHashmap = arguments.length > 8 ? arguments[8] : undefined;\n  let classifiedDateHashmap = arguments.length > 9 ? arguments[9] : undefined;\n  let showRelevanceValue = arguments.length > 10 ? arguments[10] : undefined;\n  let showCompanyName = arguments.length > 11 ? arguments[11] : undefined;\n  // for company name\n  // console.log(\"#outputAndNoOfClasses: \", outputAndNoOfClasses)\n  if (showCompanyName === true) {\n    headerList.push({\n      DisplayName: \"Competitor Name\",\n      Key: \"CompanyName\",\n      NodeName: \"CompanyName\",\n      OutputColumn: false,\n      Pinned: true\n    });\n  }\n  if (hasDataList(outputClassList) && outputClassList.length > 1) {\n    let outputHeaderList = [];\n    outputClassList.map((eachClassHeader, outputClassIndex) => {\n      outputColumnList.map(eachOutput => {\n        let outputCount = outputClassList.length;\n        if (isValidData(outputAndNoOfClasses[eachOutput])) {\n          outputCount = outputAndNoOfClasses[eachOutput];\n        }\n        if (outputClassIndex < outputCount) {\n          outputHeaderList.push({\n            DisplayName: eachOutput + \" \" + eachClassHeader,\n            NodeName: eachClassHeader,\n            Key: eachOutput + \"_output\" + (outputClassIndex + 1),\n            ShowToolTip: true,\n            HideHyperlink: hideClassificationHyperlink,\n            OutputColumn: true\n          });\n        }\n      });\n    });\n\n    // to check and assign for reference data, for performance, checked condition outside\n    if (showRelevanceValue === true) {\n      if (isValidData(classificationNameHashmap)) {\n        if (hasDataList(predictionResults)) {\n          predictionResults.map(eachDataRow => {\n            let outputValueHashmap = eachDataRow.Output;\n            outputColumnList.map((eachOutput, outputIndex) => {\n              let valueArr = outputValueHashmap[eachOutput];\n              let relatedHeaderList = [];\n              outputHeaderList.map(eachHeader => {\n                if (eachHeader.Key.includes(eachOutput)) {\n                  relatedHeaderList.push(eachHeader);\n                }\n              });\n              if (Array.isArray(valueArr)) {\n                let relevanceValueArr = eachDataRow[eachOutput + \"_RelevanceValueArr\"];\n                let originalRelevanceValueArr = eachDataRow[eachOutput + \"_RelevanceValueArr\"];\n                relatedHeaderList.map((eachHeader, headerIndex) => {\n                  let value = \"\";\n                  if (isValidData(valueArr[headerIndex])) {\n                    value = valueArr[headerIndex];\n                  }\n                  eachDataRow[eachHeader.Key] = value; // for classification value\n\n                  // for relevance value (output key _ relevance)\n                  let eachRelevanceValue = \"\";\n                  let eachRelevanceKey = eachHeader.Key + \"___relevance\";\n                  if (isValidData(relevanceValueArr[headerIndex])) {\n                    eachRelevanceValue = relevanceValueArr[headerIndex];\n                  }\n                  eachDataRow[eachRelevanceKey] = eachRelevanceValue; // for relevance value\n\n                  let eachOriginalRelevanceValue = 0;\n                  let eachOriginalRelevanceKey = \"original___\" + eachRelevanceKey;\n                  if (isValidData(originalRelevanceValueArr[headerIndex])) {\n                    eachOriginalRelevanceValue = originalRelevanceValueArr[headerIndex];\n                  }\n                  eachDataRow[eachOriginalRelevanceKey] = eachOriginalRelevanceValue;\n                });\n              } else {\n                // for class count = 1 case\n                relatedHeaderList.map((eachHeader, headerIndex) => {\n                  let value = \"\";\n                  if (headerIndex === 0) {\n                    value = valueArr;\n                  }\n                  eachDataRow[eachHeader.Key] = value; // for classification value\n                });\n              }\n            });\n            if (isValidData(classifiedDateHashmap)) {\n              if (classifiedDateHashmap[eachDataRow.PredictionID]) {\n                eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID];\n              } else if (eachDataRow.CreatedAt) {\n                eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt);\n              } else {\n                eachDataRow[\"ClassifiedDate\"] = \"-\";\n              }\n            }\n          });\n        }\n      } else {\n        predictionResults.map(eachDataRow => {\n          let outputValueHashmap = eachDataRow.Output;\n          outputColumnList.map(eachOutput => {\n            let outputValue = outputValueHashmap[eachOutput];\n            if (Array.isArray(outputValue)) {\n              outputHeaderList.map((eachHeader, headerIndex) => {\n                let value = \"\";\n                if (isValidData(outputValue[headerIndex])) {\n                  value = outputValue[headerIndex];\n                }\n                eachDataRow[eachHeader.Key] = value; // for classification value\n              });\n            } else {\n              outputHeaderList.map((eachHeader, headerIndex) => {\n                let value = \"\";\n                if (headerIndex === 0) {\n                  value = outputValue;\n                }\n                eachDataRow[eachHeader.Key] = value; // for classification value\n              });\n            }\n          });\n        });\n      }\n    } else {\n      if (isValidData(classificationNameHashmap)) {\n        if (hasDataList(predictionResults)) {\n          predictionResults.map(eachDataRow => {\n            let outputValueHashmap = eachDataRow.Output;\n            outputColumnList.map(eachOutput => {\n              let outputValue = outputValueHashmap[eachOutput];\n              if (Array.isArray(outputValue)) {\n                outputHeaderList.map((eachHeader, headerIndex) => {\n                  let value = \"\";\n                  if (isValidData(outputValue[headerIndex])) {\n                    value = outputValue[headerIndex];\n                  }\n                  eachDataRow[eachHeader.Key] = value; // for classification value\n                });\n              } else {\n                outputHeaderList.map((eachHeader, headerIndex) => {\n                  let value = \"\";\n                  if (headerIndex === 0) {\n                    value = outputValue;\n                  }\n                  eachDataRow[eachHeader.Key] = value; // for classification value\n                });\n              }\n            });\n            if (isValidData(classifiedDateHashmap)) {\n              if (classifiedDateHashmap[eachDataRow.PredictionID]) {\n                eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID];\n              } else if (eachDataRow.CreatedAt) {\n                eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt);\n              } else {\n                eachDataRow[\"ClassifiedDate\"] = \"-\";\n              }\n            }\n          });\n        }\n      } else {\n        predictionResults.map(eachDataRow => {\n          let outputValueHashmap = eachDataRow.Output;\n          outputColumnList.map(eachOutput => {\n            let outputValue = outputValueHashmap[eachOutput];\n            if (Array.isArray(outputValue)) {\n              outputHeaderList.map((eachHeader, headerIndex) => {\n                let value = \"\";\n                if (isValidData(outputValue[headerIndex])) {\n                  value = outputValue[headerIndex];\n                }\n                eachDataRow[eachHeader.Key] = value; // for classification value\n              });\n            } else {\n              outputHeaderList.map((eachHeader, headerIndex) => {\n                let value = \"\";\n                if (headerIndex === 0) {\n                  value = outputValue;\n                }\n                eachDataRow[eachHeader.Key] = value; // for classification value\n              });\n            }\n          });\n        });\n      }\n    }\n    headerList = headerList.concat(outputHeaderList);\n  } else {\n    if (hideClassificationHyperlink === true) {\n      outputColumnList.map(eachOutput => {\n        let className = eachOutput + \"_Classification Name\"; // keyword\n        headerList.push({\n          DisplayName: isValidData(outputNodeNameHashmap[className]) && isValidData(outputNodeNameHashmap[className].ColumnName) ? outputNodeNameHashmap[className].ColumnName : eachOutput,\n          Key: eachOutput + \"_classificationID\",\n          NodeName: className,\n          OutputColumn: true,\n          MultiValueLabel: multiLabelModel\n        });\n      });\n    } else {\n      outputColumnList.map(eachOutput => {\n        let classID = eachOutput + \"_Classification ID\";\n        headerList.push({\n          DisplayName: isValidData(outputNodeNameHashmap[classID]) && isValidData(outputNodeNameHashmap[classID].ColumnName) ? outputNodeNameHashmap[classID].ColumnName : eachOutput + \"_CLASS_ID\",\n          Key: eachOutput + \"_classificationID\",\n          NodeName: classID,\n          OutputColumn: true,\n          MultiValueLabel: multiLabelModel\n        });\n        let className = eachOutput + \"_Classification Name\";\n        headerList.push({\n          DisplayName: isValidData(outputNodeNameHashmap[className]) && isValidData(outputNodeNameHashmap[className].ColumnName) ? outputNodeNameHashmap[className].ColumnName : eachOutput + \"_ClASS_NAME\",\n          Key: eachOutput + \"_classificationName\",\n          NodeName: className,\n          OutputColumn: true,\n          MultiValueLabel: multiLabelModel\n        });\n      });\n    }\n    if (hideClassificationHyperlink === true) {\n      if (isValidData(classifiedDateHashmap)) {\n        predictionResults.map(eachDataRow => {\n          let outputHashmap = eachDataRow.Output;\n          outputColumnList.map(eachOutput => {\n            if (multiLabelModel === true) {\n              let classificationIDs = [];\n              if (hasDataList(outputHashmap[eachOutput])) {\n                classificationIDs = outputHashmap[eachOutput];\n              }\n              eachDataRow[eachOutput + \"_classificationID\"] = classificationIDs;\n            } else {\n              eachDataRow[eachOutput + \"_classificationID\"] = getClassificationID(outputHashmap[eachOutput]);\n            }\n          });\n          if (classifiedDateHashmap[eachDataRow.PredictionID]) {\n            eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID];\n          } else if (eachDataRow.CreatedAt) {\n            eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt);\n          } else {\n            eachDataRow[\"ClassifiedDate\"] = \"-\";\n          }\n        });\n      } else {\n        predictionResults.map(eachDataRow => {\n          let outputHashmap = eachDataRow.Output;\n          outputColumnList.map(eachOutput => {\n            if (multiLabelModel === true) {\n              eachDataRow[eachOutput + \"_classificationID\"] = outputHashmap && hasDataList(outputHashmap[eachOutput]) ? outputHashmap[eachOutput] : [];\n            } else {\n              eachDataRow[eachOutput + \"_classificationID\"] = getClassificationID(outputHashmap[eachOutput]);\n            }\n          });\n        });\n      }\n    } else {\n      if (isValidData(classifiedDateHashmap)) {\n        predictionResults.map(eachDataRow => {\n          let outputHashmap = isValidData(eachDataRow.Output) ? eachDataRow.Output : {};\n          outputColumnList.map(eachOutput => {\n            if (multiLabelModel === true) {\n              let classificationIDs = [];\n              let classificationNames = [];\n              if (hasDataList(outputHashmap[eachOutput])) {\n                classificationIDs = outputHashmap[eachOutput];\n                classificationIDs.map(eachClassID => {\n                  let eachClassName = classificationNameHashmap[eachClassID];\n                  classificationNames.push(eachClassName);\n                });\n              }\n              eachDataRow[eachOutput + \"_classificationID\"] = classificationIDs;\n              eachDataRow[eachOutput + \"_classificationName\"] = classificationNames;\n            } else {\n              let classificationID = getClassificationID(outputHashmap[eachOutput]);\n              let classificationName = classificationNameHashmap[classificationID];\n              eachDataRow[eachOutput + \"_classificationID\"] = classificationID;\n              eachDataRow[eachOutput + \"_classificationName\"] = classificationName;\n            }\n          });\n          if (classifiedDateHashmap[eachDataRow.PredictionID]) {\n            eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID];\n          } else if (eachDataRow.CreatedAt) {\n            eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt);\n          } else {\n            eachDataRow[\"ClassifiedDate\"] = \"-\";\n          }\n        });\n      } else {\n        predictionResults.map(eachDataRow => {\n          let outputHashmap = isValidData(eachDataRow.Output) ? eachDataRow.Output : {};\n          outputColumnList.map(eachOutput => {\n            if (multiLabelModel === true) {\n              let classificationIDs = [];\n              let classificationNames = [];\n              if (hasDataList(outputHashmap[eachOutput])) {\n                classificationIDs = outputHashmap[eachOutput];\n                classificationIDs.map(eachClassID => {\n                  let eachClassName = classificationNameHashmap[eachClassID];\n                  classificationNames.push(eachClassName);\n                });\n              }\n              eachDataRow[eachOutput + \"_classificationID\"] = classificationIDs;\n              eachDataRow[eachOutput + \"_classificationName\"] = classificationNames;\n            } else {\n              let classificationID = getClassificationID(outputHashmap[eachOutput]);\n              let classificationName = classificationNameHashmap[classificationID];\n              eachDataRow[eachOutput + \"_classificationID\"] = classificationID;\n              eachDataRow[eachOutput + \"_classificationName\"] = classificationName;\n            }\n          });\n        });\n      }\n    }\n\n    // for single class count case\n    if (showRelevanceValue === true) {\n      outputColumnList.map(eachOutput => {\n        let columnKey = eachOutput + \"_Confidence\";\n        let displayName = eachOutput + \" Confidence\";\n        if (isValidData(outputNodeNameHashmap) && isValidData(outputNodeNameHashmap[columnKey]) && outputNodeNameHashmap[columnKey].ColumnName !== undefined) {\n          displayName = outputNodeNameHashmap[columnKey].ColumnName;\n        }\n        let key = eachOutput + \"_Confidence\";\n        if (multiLabelModel === true) {\n          key = eachOutput + \"_RelevanceValueArr\";\n        }\n        headerList.push({\n          DisplayName: displayName,\n          Key: key,\n          NodeName: eachOutput,\n          OutputColumn: false,\n          Pinned: true,\n          MultiValueLabel: multiLabelModel\n        });\n      });\n    }\n  }\n\n  // console.log(\"#header list after prepared: \", headerList)\n  // console.log(\"#outputNodeNameHashmap: \", outputNodeNameHashmap)\n\n  return {\n    headerList,\n    predictionResults\n  };\n};\nexport const getClassificationID = output => {\n  let classificationID;\n  if (Array.isArray(output)) {\n    classificationID = output[0];\n  } else {\n    classificationID = output;\n  }\n  return classificationID;\n};\nexport const checkAndAssignDefaultValue = value => {\n  if (value !== undefined && value !== null && value !== \"\") {} else {\n    value = \"-\";\n  }\n  return value;\n};\nexport const prepareOverviewStatusFromAllDetailedInfos = detailStatusInfos => {\n  let foundInProgress = false;\n  let foundSuccess = false;\n  let foundFailed = false;\n  detailStatusInfos.map(eachInfo => {\n    if (eachInfo.Status === FAIL) {\n      foundFailed = true;\n    } else if (eachInfo.Status === SUCCESS) {\n      foundSuccess = true;\n    } else if (eachInfo.Status === IN_PROGRESS) {\n      foundInProgress = true;\n    }\n  });\n  let status = \"\";\n  if (foundInProgress) {\n    status = IN_PROGRESS;\n  } else if (foundFailed && foundSuccess) {\n    status = MIX_STATUS;\n  } else if (foundSuccess) {\n    status = SUCCESS;\n  }\n  return status;\n};\nexport const calculateDisplayFileSize = inputFileSize => {\n  let displayFileSize = inputFileSize;\n  let kiloSize = 1024;\n  if (displayFileSize > kiloSize) {\n    displayFileSize = inputFileSize / kiloSize;\n    if (displayFileSize > kiloSize) {\n      displayFileSize = displayFileSize / kiloSize;\n      if (displayFileSize > kiloSize) {\n        displayFileSize = (displayFileSize / kiloSize).toFixed(1) + \"GB\";\n      } else {\n        displayFileSize = displayFileSize.toFixed(1) + \"MB\";\n      }\n    } else {\n      displayFileSize = displayFileSize.toFixed(1) + \"KB\";\n    }\n  } else {\n    displayFileSize = inputFileSize + \"B\";\n  }\n  return displayFileSize;\n};\nexport const convertUtcToCurrentDateAndTime = inputUtcTime => {\n  let timeStamp = new Date(inputUtcTime);\n  // console.log(\"original time stamp : \", timeStamp)\n  // Parse our locale string to [date, time]]\n  let localDateTimeArr = timeStamp.toLocaleString('en-US', {\n    hour12: true\n  }).split(\" \");\n  // console.log(\"new date with given format : \", localDateTimeArr)\n  let date = localDateTimeArr[0].split(\",\")[0];\n  let time = localDateTimeArr[1];\n  let ampm = localDateTimeArr[2];\n  let splitTime = time.split(\":\");\n  let hours = splitTime[0];\n  let minutes = splitTime[1];\n  let updateTime = hours + ':' + minutes + ' ' + ampm;\n  if (splitTime.length > 2) {\n    let seconds = splitTime[2];\n    updateTime = hours + ':' + minutes + \":\" + seconds + ' ' + ampm;\n  }\n  // to get for this format => 26 Jul 2023\n  // let dateArr = date.split(\"/\");\n  // let convertedDate = new Date(dateArr[2], (dateArr[0] - 1), dateArr[1]);\n  // let shortMonth = convertedDate.toLocaleString('default', {month: 'short'}); /* Jun */\n  // let updateDate = dateArr[1] + \" \" + shortMonth + \" \" + dateArr[2];\n  return {\n    Date: date,\n    Time: updateTime\n  };\n};\nexport const getFormattedPatentIDs = patentIDs => {\n  let outputPatentIDs = [];\n  patentIDs.map(eachPatentID => {\n    outputPatentIDs.push(patentFormatter(eachPatentID));\n  });\n  return outputPatentIDs;\n};\nexport const patentFormatter = inputPatentID => {\n  //space, hyphen, n-dash, m-dash, forward slash, backward slash, open/close parens\n  let replacedText = \"\";\n  if (inputPatentID !== undefined) {\n    replacedText = inputPatentID.replaceAll(\" \", \"\").replaceAll(\"_\", \"\").replaceAll(\"-\", \"\").replaceAll(\"/\", \"\").replaceAll(\"\\\\\", \"\").replaceAll(\"(\", \"\").replaceAll(\")\", \"\").replaceAll(\"{\", \"\").replaceAll(\"}\", \"\").replaceAll(\"[\", \"\").replaceAll(\"]\", \"\").replaceAll(\".\", \"\").replaceAll(\"?\", \"\");\n  }\n  console.log(inputPatentID, \" => \", replacedText);\n  return replacedText;\n};\nexport const getColumnWordSize = (pageNumber, pageSize) => {\n  let wordSize = 6;\n  let padding = 20;\n  if (!isValidData(pageNumber)) {\n    pageNumber = 1;\n  }\n  return (pageNumber * pageSize).toString().length * wordSize + 2 * padding;\n};\nexport const getSerialRowNumber = (pageNumber, pageSize, index) => {\n  if (!isValidData(pageNumber)) {\n    pageNumber = 1;\n  }\n  return (pageNumber - 1) * pageSize + (index + 1);\n};\nexport const getFiledName = fieldName => {\n  if (isValidData(fieldName) && fieldName.includes(\".\")) {\n    fieldName = fieldName.replaceAll(\".\", \"_\");\n  }\n  return fieldName;\n};\nexport const prepareColumnDefs = columnInfoList => {\n  let columnDefs = [];\n  const patentIDWidth = 250;\n  const titleWidth = 250;\n  const abstractWidth = 300;\n  const descriptionWidth = 300;\n  const otherColumnWidth = 250;\n  let modifiedColumnNames = [];\n  columnInfoList.map((eachColumn, columnIndex) => {\n    let filedName = getFiledName(eachColumn.ColumnName);\n    if (filedName !== eachColumn.ColumnName) {\n      modifiedColumnNames.push({\n        OldName: eachColumn.ColumnName,\n        NewName: filedName\n      });\n    }\n    let colDef = {\n      headerName: eachColumn.ColumnName,\n      field: filedName,\n      flex: 1,\n      minWidth: otherColumnWidth,\n      wrapText: true,\n      sortable: true\n    };\n    if (columnIndex === 0) {\n      colDef.pinned = \"top\";\n      colDef.lockPinned = true;\n    }\n    if (isValidData(eachColumn.ColumnName)) {\n      let columnNameLower = eachColumn.ColumnName.toLowerCase();\n      if (columnNameLower === \"patentid\" || columnNameLower === \"document no.\") {\n        colDef.minWidth = patentIDWidth;\n      } else if (columnNameLower === \"title\") {\n        colDef.minWidth = titleWidth;\n      } else if (columnNameLower === \"abstract\") {\n        colDef.minWidth = abstractWidth;\n      } else if (columnNameLower === \"description\") {\n        colDef.minWidth = descriptionWidth;\n      }\n    }\n    columnDefs.push(colDef);\n  });\n  console.log(\"#columnDefs: \", columnDefs);\n  console.log(\"#modifiedColumnNames: \", modifiedColumnNames);\n  return {\n    columnDefs,\n    modifiedColumnNames\n  };\n};\nexport const convertTableData = (modifiedInfoList, previewData) => {\n  if (hasDataList(previewData)) {\n    let prevDataStr = JSON.stringify(previewData);\n    modifiedInfoList.map(eachInfo => {\n      prevDataStr = prevDataStr.replaceAll(eachInfo.OldName, eachInfo.NewName);\n    });\n    previewData = JSON.parse(prevDataStr);\n  }\n  return previewData;\n};\nexport const getOppositeColor = color => {\n  // Variables for red, green, blue values\n  if (!isValidData(color)) {\n    return \"black\";\n  }\n  let r, g, b, hsp;\n\n  // Check the format of the color, HEX or RGB?\n  if (color.match(/^rgb/)) {\n    // If RGB --> store the red, green, blue values in separate variables\n    color = color.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/);\n    r = color[1];\n    g = color[2];\n    b = color[3];\n  } else {\n    color = +(\"0x\" + color.slice(1).replace(color.length < 5 && /./g, '$&$&'));\n    r = color >> 16;\n    g = color >> 8 & 255;\n    b = color & 255;\n  }\n\n  // HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html\n  hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));\n\n  // Using the HSP value, determine whether the color is light or dark\n  if (hsp > 127.5) {\n    //actually color type is light, so should return black color for text\n    return 'black';\n  } else {\n    //actually color type is dark, so should return white color for text\n    return 'white';\n  }\n};\nexport const calculateDisplayPatentSize = inputSize => {\n  let displayFileSize = inputSize;\n  let kiloSize = 1000;\n  if (displayFileSize > kiloSize) {\n    displayFileSize = inputSize / kiloSize;\n    if (displayFileSize > kiloSize) {\n      displayFileSize = displayFileSize / kiloSize;\n      if (displayFileSize > kiloSize) {\n        displayFileSize = (displayFileSize / kiloSize).toFixed(1) + \"GB\";\n      } else {\n        displayFileSize = displayFileSize.toFixed(1) + \"MB\";\n      }\n    } else {\n      displayFileSize = displayFileSize.toFixed(1) + \"KB\";\n    }\n  } else {\n    displayFileSize = inputSize;\n  }\n  return displayFileSize;\n};\nexport const getResponseMessage = function (responseCode) {\n  let pageType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  let requestID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  // let message = \"The process has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\" to know the exact problem.\"\n  let message = \"The process has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code for detailed information.\";\n  if (isValidData(requestID)) {\n    message = \"The process with the JobID \\\"\" + requestID + \"\\\" has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the JobID and response code for detailed information..\";\n  }\n  if (responseCode === 2403) {\n    message = \"Invalid Api Key From Header to continue the process.\";\n  } else if (responseCode === 2404) {\n    message = \"You exceeded your current quota, please check your plan and billing details.\";\n  } else if (responseCode === 2405) {\n    message = \"File data format is not valid, please check your file.\";\n  } else if (responseCode === 5128) {\n    if (pageType === \"smart_innovation\") {\n      message = \"Currently, GPUs are temporarily unavailable to run the novelty process. Please try again later.\";\n    } else {\n      message = \"Currently, GPU server is not available for classification process. Please try again later.\";\n    }\n  } else {\n    if (pageType === \"inference\") {\n      message = \"Classification process has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\";\n    } else if (pageType === \"train\") {\n      message = \"Model training has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\";\n    } else if (pageType === \"test\") {\n      message = \"Training testing batches has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\";\n    } else if (pageType === \"generate\") {\n      message = \"Generating model has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\";\n    } else if (pageType === \"model_config\") {\n      message = \"Model configuration has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\";\n    } else if (pageType === \"aqx\") {\n      message = \"Searching process has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\";\n    }\n  }\n  return message;\n};\nexport const getCurrentLocalTimeForFolderName = () => {\n  let utcTime = getCurrentUTCDateTime();\n  let timeStamp = new Date(utcTime);\n  // Parse our locale string to [date, time]\n  let localDateTimeArr = timeStamp.toLocaleString('en-US', {\n    hour12: true\n  }).split(\" \");\n  let date = localDateTimeArr[0].split(\",\")[0];\n  // let time = localDateTimeArr[1];\n  // let ampm = localDateTimeArr[2]\n  // let splitTime = time.split(\":\");\n  // let hours = splitTime[0];\n  // let minutes = splitTime[1];\n  // let updateTime = hours + '-' + minutes + ampm;\n  // if (splitTime.length > 2) {\n  //     let seconds = splitTime[2]\n  //     updateTime = hours + '-' + minutes + \"-\" + seconds + ampm;\n  // }\n\n  let dateSplitArr = date.split(\"/\");\n  if (dateSplitArr.length > 2) {\n    let month = dateSplitArr[0];\n    let day = dateSplitArr[1];\n    let year = dateSplitArr[2];\n    date = year + \"-\" + month + \"-\" + day;\n  }\n\n  // return date + \"_\" + updateTime\n  return date;\n};\nexport const getCurrentLocalTime = () => {\n  let utcTime = getCurrentUTCDateTime();\n  let timeStamp = new Date(utcTime);\n  // Parse our locale string to [date, time]\n  let localDateTimeArr = timeStamp.toLocaleString('en-US', {\n    hour12: true\n  }).split(\" \");\n  let time = localDateTimeArr[1];\n  let ampm = localDateTimeArr[2];\n  let splitTime = time.split(\":\");\n  let hours = splitTime[0];\n  let minutes = splitTime[1];\n  let updateTime = hours + '-' + minutes + ampm;\n  if (splitTime.length > 2) {\n    let seconds = splitTime[2];\n    updateTime = hours + '-' + minutes + \"-\" + seconds + ampm;\n  }\n  return updateTime;\n};\nexport const prepareDownloadFolderName = (modelName, predictionName, patentSearchCase) => {\n  //AI_Classifier_2024-01-02_1.csv\n  let folderName = \"AI_Classifier\";\n  if (patentSearchCase === true) {\n    folderName = \"Patent_Group\";\n  }\n  if (isValidData(modelName)) {\n    let splitModelNames = modelName.split(\" \");\n    let shortModelName = \"\";\n    splitModelNames.map(eachName => {\n      eachName = eachName.replaceAll(\" \", \"\");\n      if (isValidData(eachName)) {\n        let firstChar = eachName[0];\n        let regex = /^[a-zA-Z]+$/;\n        let isChar = regex.test(firstChar);\n        if (isChar) {\n          let firstCharUpper = firstChar.toUpperCase();\n          if (shortModelName === \"\") {\n            shortModelName = firstCharUpper;\n          } else {\n            shortModelName += firstCharUpper;\n          }\n        }\n      }\n    });\n    if (shortModelName !== \"\") {\n      folderName += \"_\" + shortModelName;\n    }\n  }\n  if (isValidData(predictionName)) {\n    predictionName = predictionName.replaceAll(\" \", \"\"); // prediction based\n    if (predictionName !== \"\") {\n      folderName += \"_\" + predictionName;\n    }\n  }\n  let localTime = getCurrentLocalTimeForFolderName();\n  folderName += \"_\" + localTime;\n  return folderName;\n};\nexport const calculatePercentage = (value, total) => {\n  let percentage = value / total * 100;\n  if (parseInt(percentage.toString()) === percentage) {} else {\n    percentage = percentage.toFixed(2);\n    if (parseFloat(percentage) <= 0) {\n      for (let digitCount = 3; digitCount < 10; digitCount++) {\n        percentage = (value / total * 100).toFixed(digitCount);\n        if (parseFloat(percentage) > 0) {\n          break;\n        }\n      }\n    }\n  }\n  return percentage;\n};\nexport const getFixedNumber = (inputValue, minDigit, maxDigit) => {\n  // console.log(\"#getFixedNumber: \", inputValue, \", type: \", typeof inputValue)\n  let value = parseFloat(inputValue);\n  let fixedValue = value.toFixed(minDigit);\n  if (parseFloat(fixedValue) <= 0) {\n    for (let digitCount = 3; digitCount < maxDigit; digitCount++) {\n      fixedValue = value.toFixed(digitCount);\n      if (parseFloat(fixedValue) > 0) {\n        break;\n      }\n    }\n  }\n  return fixedValue;\n};\nexport const getClassifiedDate = createdAt => {\n  let convData = convertUtcToCurrentDateAndTime(createdAt);\n  let date = convData.Date;\n  let formattedDate = date;\n  let dateSplitArr = date.split(\"/\");\n  if (dateSplitArr.length > 2) {\n    let month = dateSplitArr[0];\n    let day = dateSplitArr[1];\n    let year = dateSplitArr[2];\n    if (parseInt(month) < 10) {\n      month = \"0\" + month;\n    }\n    if (parseInt(day) < 10) {\n      day = \"0\" + day;\n    }\n    formattedDate = year + \"-\" + month + \"-\" + day;\n  }\n  return formattedDate;\n};\nexport const getMaxNumberOfArray = numbers => {\n  // Math.max(...numbers)\n  // Math.max.apply(null, numbers)\n  // numbers.sort(numbers.length-1)\n  // with for loop\n  // reduce logic is the best when handled for multiple items in an array\n  return numbers.reduce((accumulator, currentValue) => {\n    return Math.max(accumulator, currentValue);\n  }, numbers[0]);\n};\nexport const getAboveThresholdCount = (rowData, threshold) => {\n  //let new_arr_1 = data.reduce((a, b) => a.concat(([1,3,5].includes(b.id) ? b.value: [])), []);\n  let newRowDataArr = rowData.reduce((newArr, eachData) => newArr.concat(eachData[\"OriginalRelevanceValue\"] < threshold ? eachData : []), []);\n  return newRowDataArr.length;\n};\nexport const getRoleBasedInfo = () => {\n  let role = \"user\";\n  let superAdminID = \"\";\n  let adminID = \"\";\n  if (isSuperAdmin === true) {\n    role = \"super_admin\";\n  } else if (isAdminUser === true) {\n    role = \"admin\";\n    superAdminID = userInfo.CreatedBy;\n  } else {\n    adminID = isValidData(userInfo.AssignedBy) ? userInfo.AssignedBy : userInfo.CreatedBy;\n  }\n  return {\n    role,\n    superAdminID,\n    adminID\n  };\n};\nexport const getCheckValidateHeaderColumnForReinforce = (inputColumnList, requiredColumns) => {\n  console.log(\"getCheckValidateHeaderColumn - inputColumnList: \", inputColumnList);\n  let successHeader = false;\n  let ColumnInfo = [];\n  let sameInitialCount = false;\n  let ColumnInfoForOutputColumn = [];\n  if (inputColumnList.length === 1) {} else {\n    inputColumnList.map(eachColumn => {\n      if (eachColumn[\"PossibleDataType\"].includes(\"string\")) {\n        eachColumn.Name = eachColumn.ColumnName;\n        ColumnInfo.push(eachColumn);\n        ColumnInfoForOutputColumn.push(eachColumn);\n      } else if (eachColumn[\"PossibleDataType\"].includes(\"int\")) {\n        eachColumn.Name = eachColumn.ColumnName;\n        ColumnInfoForOutputColumn.push(eachColumn);\n      }\n    });\n    if (inputColumnList.length >= requiredColumns.length) {\n      sameInitialCount = true;\n    }\n  }\n  let checkCountSuccess = false;\n  if (isValidData(ColumnInfo)) {\n    if (sameInitialCount === true) {\n      checkCountSuccess = true;\n    } else {\n      console.log(\"count is not same : \", ColumnInfo.length, \", \", requiredColumns.length);\n    }\n  }\n  if (checkCountSuccess) {\n    successHeader = checkCountSuccess;\n  }\n  console.log(\"checking file validation : \", checkCountSuccess);\n  return {\n    ColumnInfo,\n    successHeader,\n    checkCountSuccess,\n    columnList: ColumnInfo,\n    ColumnInfoForOutputColumn: ColumnInfoForOutputColumn\n  };\n};\nexport const checkReinforceColumnMappingsInfo = (requiredColumnMappings, ColumnInfo, validColumnInfoListForOutputColumn, usedColumnHashmap) => {\n  console.log(\"#checkReinforceColumnMappingsInfo: \", requiredColumnMappings, \", \", ColumnInfo, \", \", usedColumnHashmap);\n  let mappableColumnsCount = 0;\n  let availableColumnList = [];\n  ColumnInfo.map(eachColumn => {\n    availableColumnList.push(eachColumn.ColumnName);\n  });\n  let availableOutputColumns = [];\n  validColumnInfoListForOutputColumn.map(eachColumn => {\n    availableOutputColumns.push(eachColumn.ColumnName);\n  });\n  requiredColumnMappings.map(eachColumn => {\n    if (!isValidData(eachColumn.MappedColumnName)) {\n      let mappedColumnName = \"\";\n      if (eachColumn.OutputColumn === true) {\n        // mappedColumnName = checkAndGetForAvailableColumnName(eachColumn.Name, availableOutputColumns, usedColumnHashmap)\n      } else {\n        // mappedColumnName = checkAndGetForAvailableColumnName(eachColumn.Name, availableColumnList, usedColumnHashmap)\n      }\n      if (usedColumnHashmap[mappedColumnName] !== undefined) {\n        usedColumnHashmap[mappedColumnName]++;\n      } else {\n        usedColumnHashmap[mappedColumnName] = 1;\n      }\n      eachColumn.MappedColumnName = mappedColumnName;\n      let nameLower = eachColumn.Name.toLowerCase();\n      let mappedNameLower = eachColumn.MappedColumnName.toLowerCase();\n      if (nameLower === mappedNameLower) {\n        mappableColumnsCount++;\n      } else if ((nameLower === \"patentID\" || nameLower === \"document no.\") && (mappedNameLower === \"patentID\" || mappedNameLower === \"document no.\")) {\n        mappableColumnsCount++;\n      }\n    }\n  });\n  let skipHeaderCheck = false;\n  if (mappableColumnsCount > 0) {\n    skipHeaderCheck = true;\n  }\n  let skipColumnMapping = false;\n  if (mappableColumnsCount === requiredColumnMappings.length) {\n    skipColumnMapping = true;\n  }\n  return {\n    skipHeaderCheck,\n    skipColumnMapping,\n    requiredColumnMappings,\n    usedColumnHashmap\n  };\n};\nexport const getDefaultClassBasedMetrics = () => {\n  return [{\n    \"Name\": \"TruePositive\",\n    \"DisplayName\": \"True Positive (TP)\",\n    \"DataType\": \"int\",\n    \"Description\": \"The number of instances that are actually positive and are correctly predicted as positive by the model.\"\n  }, {\n    \"Name\": \"FalsePositive\",\n    \"DisplayName\": \"False Positive (FP)\",\n    \"DataType\": \"int\",\n    \"Description\": \"The number of instances that are actually negative but are incorrectly predicted as positive by the model.\"\n  }, {\n    \"Name\": \"TrueNegative\",\n    \"DisplayName\": \"True Negative (TN)\",\n    \"DataType\": \"int\",\n    \"Description\": \"The number of instances that are actually negative and are correctly predicted as negative by the model.\"\n  }, {\n    \"Name\": \"FalseNegative\",\n    \"DisplayName\": \"False Negative (FN)\",\n    \"DataType\": \"int\",\n    \"Description\": \"The number of instances that are actually positive but are incorrectly predicted as negative by the model.\"\n  }, {\n    \"Name\": \"TrueNegativeRate\",\n    \"DisplayName\": \"True Negative Rate (TNR)\",\n    \"DataType\": \"float\",\n    \"Description\": \"The true negative rate (also called specificity), which is the probability that an actual negative will test negative. It is calculated as TN/TN+FP.\"\n  }, {\n    \"Name\": \"FalsePositiveRate\",\n    \"DisplayName\": \"False Positive Rate (FPR)\",\n    \"DataType\": \"float\",\n    \"Description\": \"The false positive rate is calculated as the ratio between the number of negative events wrongly categorized as positive (false positives) and the total number of actual negative events (regardless of classification).\"\n  }, {\n    \"Name\": \"Precision\",\n    \"DisplayName\": \"Precision\",\n    \"DataType\": \"float\",\n    \"Description\": \"Precision is the ratio of true positives to the total number of predicted positives (true positives plus false positives). Precision gives an indication of how many of the predicted positive instances are actually positive. It is a measure of the model's accuracy when it predicts positive outcomes.\"\n  }, {\n    \"Name\": \"Recall\",\n    \"DisplayName\": \"Recall\",\n    \"DataType\": \"float\",\n    \"Description\": \"Recall is the ratio of true positives to the total number of actual positives (true positives plus false negatives). Recall measures the ability of the model to capture all the positive instances. It's a measure of the model's sensitivity to positive instances.\"\n  }, {\n    \"Name\": \"F1score\",\n    \"DisplayName\": \"F1Score\",\n    \"DataType\": \"float\",\n    \"Description\": \"The F1 score is the harmonic mean of precision and recall. It provides a balance between precision and recall.\"\n  }, {\n    \"Name\": \"Accuracy\",\n    \"DisplayName\": \"Accuracy\",\n    \"DataType\": \"float\",\n    \"Description\": \"Accuracy is the ratio of correct predictions out of all predictions made by an algorithm. It can be calculated by dividing precision by recall or as 1 minus false negative rate (FNR) divided by false positive rate (FPR).\"\n  }];\n};\nexport const formatDate = date => {\n  let dd = date.getDate();\n  let mm = date.getMonth() + 1;\n  let yyyy = date.getFullYear();\n  if (dd < 10) {\n    dd = '0' + dd;\n  }\n  if (mm < 10) {\n    mm = '0' + mm;\n  }\n  date = yyyy + \"-\" + mm + \"-\" + dd;\n  return date;\n};\nexport const getPreviousNthDate = nthDay => {\n  let d = new Date();\n  d.setDate(d.getDate() - nthDay);\n  let date = formatDate(d);\n  console.log(\"formatted date: \", date);\n  return date;\n};\nexport const getDisplayDateInfoFromDatePicker = inputDate => {\n  console.log(\"getDisplayDateInfoFromDatePicker: \", inputDate);\n  let dateValue = \"\";\n  let displayValue = \"\";\n  if (inputDate) {\n    dateValue = inputDate.format(\"YYYY-MM-DD\");\n    displayValue = inputDate.format(\"MMM DD, YYYY\");\n  }\n  return {\n    dateValue,\n    displayValue\n  };\n};\nexport const getActualModelName = inputModelName => {\n  let outputModelName = \"\";\n  if (inputModelName) {\n    outputModelName = inputModelName;\n    let splitArr = inputModelName.split(\"_\");\n    if (splitArr.length > 2) {\n      let lastValue = splitArr[splitArr.length - 1];\n      let secondLast = splitArr[splitArr.length - 2];\n      if (lastValue.includes(\"V\") && secondLast.includes(\"-\") && secondLast.split(\"-\").length === 3) {\n        // version and date is included\n        outputModelName = splitArr[0];\n        for (let index = 1; index < splitArr.length - 2; index++) {\n          outputModelName += \"_\" + splitArr[index];\n        }\n      }\n    }\n  }\n  console.log(\"#output model name: \", outputModelName, \" ==> from : \", inputModelName);\n  return outputModelName;\n};\nexport const openUrl = urlLink => {\n  window.open(urlLink, '_blank');\n};\nexport const foundSearchValue = (inputName, searchValue) => {\n  let inputNameLower = inputName.toLowerCase();\n  let searchValueLower = searchValue.toLowerCase();\n  let found = false;\n  if (inputNameLower.includes(searchValueLower)) {\n    found = true;\n  }\n  return found;\n};\nexport const checkLightOrDark = color => {\n  // Variables for red, green, blue values\n  let r, g, b, hsp;\n\n  // Check the format of the color, HEX or RGB?\n  if (isValidData(color)) {\n    if (color.match(/^rgb/)) {\n      // If RGB --> store the red, green, blue values in separate variables\n      color = color.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/);\n      r = color[1];\n      g = color[2];\n      b = color[3];\n    } else {\n      color = +(\"0x\" + color.slice(1).replace(color.length < 5 && /./g, '$&$&'));\n      r = color >> 16;\n      g = color >> 8 & 255;\n      b = color & 255;\n    }\n    hsp = Math.sqrt(0.299 * (r * r) + 0.587 * (g * g) + 0.114 * (b * b));\n    // Using the HSP value, determine whether the color is light or dark\n    if (hsp > 127.5) {\n      return 'light';\n    } else {\n      return 'dark';\n    }\n  } else {\n    return 'dark';\n  }\n};\nexport const getTextColor = color => {\n  let colorType = checkLightOrDark(color);\n  if (colorType === \"light\") {\n    // return \"var(--primary-color)\"\n    return \"#000000\";\n  } else {\n    return \"#FFFFFF\";\n  }\n};\nexport const prepareBooleanAndSqlQueryInfo = inputQuery => {\n  console.log(\"prepare query info: \", inputQuery);\n  // SELECT , FROM , WHERE, JOIN, AND , OR\n  // ON\n  let startKeywords = [\"SELECT\", \"FROM\", \"WHERE\", \"JOIN\", \"AND\", \"OR\"];\n  let innerKeywords = [\"ON\"];\n  let sqlQueryInfo = [];\n  let booleanQueryInfo = [];\n  let startCondition = false;\n  if (inputQuery) {\n    let spaceSplitArr = inputQuery.split(\" \");\n    let clauseName = \"\";\n    let clauseList = [];\n    let eachClauseValue = \"\";\n    spaceSplitArr.map((eachWord, index) => {\n      if (startKeywords.includes(eachWord)) {\n        if (clauseName !== \"\" && (clauseList.length > 0 || eachClauseValue !== \"\")) {\n          if (eachClauseValue !== \"\") {\n            clauseList.push({\n              Type: \"Text\",\n              Value: eachClauseValue\n            });\n          }\n          sqlQueryInfo.push({\n            ClauseName: clauseName,\n            Clause: clauseList\n          });\n          if (startCondition === true) {\n            let boolClause = \"\";\n            clauseList.map((eachInfo, infoIndex) => {\n              if (infoIndex === 0) {\n                boolClause = eachInfo.Value;\n              } else {\n                boolClause += \" \" + eachInfo.Value;\n              }\n            });\n            booleanQueryInfo.push({\n              ClauseName: booleanQueryInfo.length === 0 ? \"\" : clauseName,\n              ClauseValue: boolClause\n            });\n          }\n          clauseName = \"\";\n          clauseList = [];\n          eachClauseValue = \"\";\n        }\n        // start row case\n        clauseName = eachWord;\n        if (eachWord === \"WHERE\" || eachWord === \"JOIN\") {\n          startCondition = true;\n        }\n      } else {\n        // skip the word\n        // check if the keyword is inner keyword or not\n        if (clauseName !== \"\") {\n          if (innerKeywords.includes(eachWord)) {\n            if (eachClauseValue !== \"\") {\n              clauseList.push({\n                Type: \"Text\",\n                Value: eachClauseValue\n              });\n              eachClauseValue = \"\";\n            }\n            clauseList.push({\n              Type: \"ClauseName\",\n              Value: eachWord\n            });\n          } else {\n            if (eachClauseValue === \"\") {\n              eachClauseValue = eachWord;\n            } else {\n              eachClauseValue += \" \" + eachWord;\n            }\n          }\n        } else {\n          // clause empty case\n          console.log(\"empty clause case, so skip word: \", eachWord);\n        }\n      }\n      if (index === spaceSplitArr.length - 1) {\n        // last index case\n        if (clauseName !== \"\" && (clauseList.length > 0 || eachClauseValue !== \"\")) {\n          if (eachClauseValue !== \"\") {\n            clauseList.push({\n              Type: \"Text\",\n              Value: eachClauseValue\n            });\n          }\n          sqlQueryInfo.push({\n            ClauseName: clauseName,\n            Clause: clauseList\n          });\n\n          // for boolean query\n          if (startCondition === true) {\n            let boolClause = \"\";\n            clauseList.map((eachInfo, infoIndex) => {\n              if (infoIndex === 0) {\n                boolClause = eachInfo.Value;\n              } else {\n                boolClause += \" \" + eachInfo.Value;\n              }\n            });\n            booleanQueryInfo.push({\n              ClauseName: booleanQueryInfo.length === 0 ? \"\" : clauseName,\n              ClauseValue: boolClause\n            });\n          }\n\n          // empty data\n          clauseName = \"\";\n          clauseList = [];\n        }\n      }\n    });\n  }\n  return {\n    sqlQueryInfo,\n    booleanQueryInfo\n  };\n};\nexport const getDescriptionForModuleName = inputModuleName => {\n  const descriptionHashmap = {\n    \"Agreement\": \"Legal contracts or agreements related to intellectual property, such as licensing agreements, assignment agreements, or nondisclosure agreements.\",\n    \"Billing\": \"Financial transactions related to intellectual property services, such as billing clients for legal services related to IP matters or paying fees for filing patents or trademarks.\",\n    \"Brand\": \"The identity or image of a product, service, or organization, including trademarks, logos, slogans, and other elements used to differentiate it from competitors\",\n    \"Contact\": \"Individuals or entities with whom an organization interacts regarding intellectual property matters, such as clients, inventors, attorneys, or representatives from government agencies.\",\n    \"Conflict\": \"Individuals or entities with whom an organization interacts regarding intellectual property matters, such as clients, inventors, attorneys, or representatives from government agencies.Disputes or conflicts that may arise regarding intellectual property rights, such as infringement claims, opposition proceedings, or disputes over ownership of IP assets.\",\n    \"Design\": \"The visual appearance or ornamental aspects of a product, including shape, configuration, pattern, or ornamentation, eligible for design protection\",\n    \"Design Application\": \"A formal request submitted to a patent office to seek protection for a design, typically in the form of a design patent or registration.\",\n    \"Invention\": \"A new and useful process, machine, composition of matter, or improvement thereof, eligible for patent protection.\"\n  };\n  let descriptionValue = \"\";\n  if (descriptionHashmap[inputModuleName] !== undefined) {\n    descriptionValue = descriptionHashmap[inputModuleName];\n  }\n  return descriptionValue;\n};\nexport const getModulesForNestedFilterConditions = (moduleNames, filterConditions) => {\n  filterConditions.map(eachCondition => {\n    if (eachCondition.Type === \"field\") {\n      if (eachCondition.FilterValueInfo.ModuleName) {\n        if (!moduleNames.includes(eachCondition.FilterValueInfo.ModuleName)) {\n          moduleNames.push(eachCondition.FilterValueInfo.ModuleName);\n        }\n      }\n    } else {\n      if (eachCondition.NestedFilterConditions) {\n        moduleNames = getModulesForNestedFilterConditions(moduleNames, eachCondition.NestedFilterConditions);\n      }\n    }\n  });\n  return moduleNames;\n};\nexport const getSameValuePatents = () => {\n  let allRows = [{\n    \"DocumentNo\": \"US10409988B2\",\n    \"Actual\": \"a065Y00001vvjfk\",\n    \"Predict\": \"a065Y00001vvjfk\"\n  }];\n  let newRows = [];\n  let documentMap = {};\n  allRows.map(eachRow => {\n    if (eachRow.Actual === eachRow.Predict) {\n      newRows.push({\n        DocumentNo: eachRow.DocumentNo,\n        Actual: eachRow.Actual,\n        Predict: eachRow.Predict\n      });\n      documentMap[eachRow.DocumentNo] = true;\n    }\n  });\n  // console.log(\"all patents rows \", allRows.length)\n  // console.log(\"same patents rows: \", newRows.length, \" => \", newRows)\n  return newRows;\n};\nexport const getNotIncludePatents = inputSamePatents => {\n  let allPredictRows = [{\n    \"DocumentNo\": \"DE102022108867A1\",\n    \"Actual\": \"a065Y000023bc9c\",\n    \"Predict\": \"a065Y000023bc9c\"\n  }];\n  let foundHashmap = {};\n  allPredictRows.map(eachRow => {\n    foundHashmap[eachRow.DocumentNo] = true;\n  });\n  // console.log(\"all fixed Rows: \", allPredictRows.length)\n  // console.log(\"fix hashmap: \", foundHashmap)\n\n  let notIncludeRows = [];\n  inputSamePatents.map(eachRow => {\n    if (foundHashmap[eachRow.DocumentNo] === undefined) {\n      notIncludeRows.push(eachRow);\n    }\n  });\n  return notIncludeRows;\n};\nexport const getDefaultDraftOutlineList = () => {\n  return [{\n    Name: \"Title\",\n    Key: \"Title\"\n  }, {\n    Name: \"Abstract\",\n    Key: \"Abstract\"\n  }, {\n    Name: \"Description\",\n    Key: \"Description\",\n    isExpand: true,\n    Children: [{\n      Name: \"Technical Field\",\n      Key: \"TechnicalField\"\n    }, {\n      Name: \"Background\",\n      Key: \"Background\"\n    }, {\n      Name: \"Disclosure of the Invention\",\n      Key: \"InventionDisclosure\"\n    }, {\n      Name: \"Novelty Statement\",\n      Key: \"NoveltyStatement\"\n    }, {\n      Name: \"Summary\",\n      Key: \"Summary\"\n    }]\n  }, {\n    Name: \"Claims\",\n    Key: \"Claims\"\n  }, {\n    Name: \"Citations\",\n    Key: \"Citations\"\n  }];\n};\nexport const prepareDraftSectionOutlines = draftSections => {\n  let outlineList = getDefaultDraftOutlineList();\n  let newOutlineList = [];\n  outlineList.map(eachOutline => {\n    let outlineKey = eachOutline.Key;\n    if (eachOutline.Children) {\n      let foundChildList = [];\n      eachOutline.Children.map(eachChild => {\n        if (draftSections.includes(eachChild.Key)) {\n          foundChildList.push(eachChild);\n        }\n      });\n      if (foundChildList.length > 0) {\n        newOutlineList.push({\n          Name: eachOutline.Name,\n          Key: eachOutline.Key,\n          Children: foundChildList,\n          isExpand: eachOutline.isExpand\n        });\n      } else {\n        if (draftSections.includes(outlineKey)) {\n          newOutlineList.push({\n            Name: eachOutline.Name,\n            Key: eachOutline.Key,\n            Children: [],\n            isExpand: eachOutline.isExpand\n          });\n        }\n      }\n    } else {\n      if (draftSections.includes(outlineKey)) {\n        newOutlineList.push(eachOutline);\n      }\n    }\n  });\n  console.log(\"#drafted outline list: \", newOutlineList);\n  return newOutlineList;\n};\nexport const prepareRemainingDraftSections = draftSections => {\n  let outlineList = getDefaultDraftOutlineList();\n  let newOutlineList = [];\n  outlineList.map(eachOutline => {\n    let outlineKey = eachOutline.Key;\n    if (eachOutline.Children) {\n      let foundChildList = [];\n      eachOutline.Children.map(eachChild => {\n        if (!draftSections.includes(eachChild.Key)) {\n          foundChildList.push(eachChild);\n        }\n      });\n      if (foundChildList.length > 0) {\n        newOutlineList.push({\n          Name: eachOutline.Name,\n          Key: eachOutline.Key,\n          Children: foundChildList\n        });\n      } else {\n        if (!draftSections.includes(outlineKey)) {\n          newOutlineList.push({\n            Name: eachOutline.Name,\n            Key: eachOutline.Key,\n            Children: []\n          });\n        }\n      }\n    } else {\n      if (!draftSections.includes(outlineKey)) {\n        newOutlineList.push(eachOutline);\n      }\n    }\n  });\n  console.log(\"#remaining outline list: \", newOutlineList);\n  return newOutlineList;\n};\nexport const getDisplayStatus = inputStatus => {\n  const statusMap = {\n    \"to_be_filed\": \"To Be Filed\",\n    \"filed\": \"Filed\",\n    \"not_filed\": \"Not Filed\",\n    \"granted\": \"Granted\"\n  };\n  let displayStatus = \"\";\n  if (isValidData(statusMap[inputStatus])) {\n    displayStatus = statusMap[inputStatus];\n  }\n  return displayStatus;\n};\nexport const changeAndUpdateSectionSelection = (sectionList, keyword, value) => {\n  let selectedCount = 0;\n  sectionList.map(eachSection => {\n    eachSection[keyword] = value;\n    if (hasDataList(eachSection.Children)) {\n      eachSection.Children.map(eachInfo => {\n        eachInfo[keyword] = value;\n        if (value === true) {\n          selectedCount++;\n        }\n      });\n      if (value === true) {\n        selectedCount++;\n      }\n    } else {\n      if (value === true) {\n        selectedCount++;\n      }\n    }\n  });\n  return {\n    sectionList,\n    selectedCount\n  };\n};\nexport const getSelectedDraftedSections = inventionSectionList => {\n  let sections = [];\n  inventionSectionList.map(eachInfo => {\n    if (hasDataList(eachInfo.Children)) {\n      eachInfo.Children.map(eachChild => {\n        if (eachChild.isSelected === true) {\n          if (eachChild.Value) {\n            sections.push(eachChild.Value);\n          } else {\n            sections.push(eachChild.Key);\n          }\n        }\n      });\n      if (eachInfo.isSelected === true) {\n        if (eachInfo.Value) {\n          sections.push(eachInfo.Value);\n        } else {\n          sections.push(eachInfo.Key);\n        }\n      }\n    } else {\n      if (eachInfo.isSelected === true) {\n        if (eachInfo.Value) {\n          sections.push(eachInfo.Value);\n        } else {\n          sections.push(eachInfo.Key);\n        }\n      }\n    }\n  });\n  console.log(\"#returned sections: \", sections);\n  return sections;\n};\nexport const concatInventionData = invention => {\n  let textData = \"\";\n  if (invention.InventionDescription) {\n    textData = invention.InventionDescription;\n  }\n  if (invention.ProblemSolved) {\n    textData += \"\\n\" + invention.ProblemSolved;\n  }\n  if (invention.NoveltyAndNonObviousness) {\n    textData += \"\\n\" + invention.NoveltyAndNonObviousness;\n  }\n  if (invention.PriorArts) {\n    textData += \"\\n\" + invention.PriorArts;\n  }\n  if (invention.CommercializationPotential) {\n    textData += \"\\n\" + invention.CommercializationPotential;\n  }\n  return textData;\n};\nexport const getLastIndexByGivenName = (itemList, filedName, defaultVariableName) => {\n  let lastIndex = 0;\n  itemList.map(eachItem => {\n    let splitArr = [];\n    if (isValidData(filedName)) {\n      if (isValidData(eachItem[filedName])) {\n        splitArr = eachItem[filedName].split(defaultVariableName);\n      }\n    } else {\n      if (isValidData(eachItem)) {\n        splitArr = eachItem.split(defaultVariableName);\n      }\n    }\n    if (splitArr.length === 2 && splitArr[0] === \"\") {\n      let variableIndexStr = splitArr[1];\n      if (!variableIndexStr.includes(\".\")) {\n        if (Number.parseInt(variableIndexStr).toString() === variableIndexStr) {\n          let currentIndex = parseInt(variableIndexStr);\n          if (currentIndex > lastIndex) {\n            lastIndex = currentIndex;\n          }\n        }\n      }\n    }\n  });\n  return lastIndex;\n};\nexport const checkClaimTitle = value => {\n  let isTitle = false;\n  if (isValidData(value)) {\n    let valueLower = value.toLowerCase();\n    if (valueLower.includes(\"independent claim\") || valueLower.includes(\"dependent claim\")) {\n      isTitle = true;\n    }\n  }\n  return isTitle;\n};\nconst splitDataArrBySubStr = (textArr, subStr) => {\n  // console.log(\"input text arr => \", textArr)\n  // console.log(\"input sub str => \", subStr)\n  let splitDataArr = [];\n  textArr.map(eachText => {\n    if (eachText.includes(subStr)) {\n      let splitArr = eachText.split(subStr);\n      if (splitArr.length === 2) {\n        if (splitArr[0] === \"\") {\n          splitDataArr = splitDataArr.concat(subStr);\n          splitDataArr = splitDataArr.concat(splitArr[1]);\n        } else if (splitArr[1] === \"\") {\n          splitDataArr = splitDataArr.concat(splitArr[0]);\n          splitDataArr = splitDataArr.concat(subStr);\n        } else {\n          splitDataArr = splitDataArr.concat(splitArr[0]);\n          splitDataArr = splitDataArr.concat(subStr);\n          splitDataArr = splitDataArr.concat(splitArr[1]);\n        }\n      } else {\n        splitArr.map((eachSplitStr, index) => {\n          if (splitArr[0] === \"\") {\n            //first one is empty\n            if (eachSplitStr !== \"\") {\n              if (index !== 0) {\n                splitDataArr = splitDataArr.concat(subStr);\n              }\n              splitDataArr = splitDataArr.concat(eachSplitStr);\n            }\n          } else if (splitArr[splitArr.length - 1] === \"\") {\n            if (eachSplitStr !== \"\") {\n              splitDataArr = splitDataArr.concat(eachSplitStr);\n              if (index !== splitArr.length - 1) {\n                splitDataArr = splitDataArr.concat(subStr);\n              }\n            }\n          } else {\n            if (eachSplitStr !== \"\") {\n              splitDataArr = splitDataArr.concat(eachSplitStr);\n              if (index !== splitArr.length - 1) {\n                splitDataArr = splitDataArr.concat(subStr);\n              }\n            }\n          }\n        });\n      }\n    } else {\n      splitDataArr = splitDataArr.concat(eachText);\n      // console.log(\"not include case\")\n    }\n  });\n  return splitDataArr;\n};\nexport const convertSentimentDataToStrArr = (textInput, sentimentTextArr) => {\n  let convertedStrArr = [textInput];\n  sentimentTextArr.map(eachText => {\n    convertedStrArr = splitDataArrBySubStr(JSON.parse(JSON.stringify(convertedStrArr)), eachText);\n  });\n  return convertedStrArr;\n};\nexport const getDefaultColor = () => {\n  let colorList = ['rgba(183,236,6,0.8)', \"#F8A690\", \"#7C6FEE\", \"#76A1D5\", \"#4BCEBC\", '#eb4039', \"#eb8f39\", \"#d6eb39\", \"#34eba9\", \"#5a356b\", \"#349fe9\", \"#9342f9\", \"#66664D\", \"#a8328b\", \"#4632a8\", \"#FF99E6\"];\n};\nexport const getDefaultUserTypes = () => {\n  return [{\n    Name: \"inventor\",\n    DisplayName: \"Inventor\"\n  }, {\n    Name: \"r&d_manager\",\n    DisplayName: \"R&D Manager\"\n  }, {\n    Name: \"attorney\",\n    DisplayName: \"Attorney\"\n  }, {\n    Name: \"decision_maker\",\n    DisplayName: \"Other Decision Makers\"\n  }\n  // {\n  //     Name: \"\",\n  //     DisplayName: \"\",\n  // },\n  ];\n};\nexport const getParseData = inputData => {\n  return JSON.parse(JSON.stringify(inputData));\n};\nexport const getMenuIconClass = (icon, disabled) => {\n  let negativeIconList = [\"delete\", \"remove\", \"close\"];\n  return disabled ? \"menu-button disabled\" : negativeIconList.includes(icon.toLowerCase()) ? \"menu-button delete-btn\" : \"menu-button\";\n};\nexport const getSeparatedModelNameAndVersion = inputModelName => {\n  //modelName\n  let modelName;\n  let version;\n  //Semiconductor_2023-11-29_V1\n  let splitArr = inputModelName.split(\"_\");\n  if (splitArr[splitArr.length - 1].includes(\"-\")) {\n    version = splitArr[splitArr.length - 1];\n    modelName = inputModelName.split(\"_\" + version)[0];\n  } else {\n    version = splitArr[splitArr.length - 2];\n    modelName = inputModelName.split(\"_\" + version)[0];\n  }\n  return {\n    modelName,\n    version\n  };\n};\nexport const getOperatorSpecificInfo = operatorDisplayName => {\n  const operatorInfoHashmap = {\n    \"Equals\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"Does Not Equal\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"Greater than\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"Less than\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"Greater than or Equals\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"Less than or Equals\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"Between\": {\n      ValidInputCount: 2,\n      InputType: \"\" // for required case\n    },\n    \"Begins With\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"Contains\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"Does Not Contain\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"Today\": {\n      ValidInputCount: 0,\n      InputType: \"\" // for required case\n    },\n    \"Yesterday\": {\n      ValidInputCount: 0,\n      InputType: \"\" // for required case\n    },\n    \"Is Blank\": {\n      ValidInputCount: 0,\n      InputType: \"\" // for required case\n    },\n    \"Is Not Blank\": {\n      //TODO to confirm with backend, how to pass to backend (as operator or as value))\n      ValidInputCount: 0,\n      InputType: \"\" // for required case\n    },\n    \"Yes\": {\n      ValidInputCount: 0,\n      InputType: \"\" // for required case\n    },\n    \"No\": {\n      ValidInputCount: 0,\n      InputType: \"\" // for required case\n    },\n    \"In List\": {\n      ValidInputCount: -1,\n      InputType: \"\" // for required case\n    },\n    \"On or Before\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"On or After\": {\n      ValidInputCount: 1,\n      InputType: \"\" // for required case\n    },\n    \"Last (N) Days\": {\n      ValidInputCount: 1,\n      InputType: \"number\" // for required case\n    },\n    \"YTD\": {\n      ValidInputCount: 1,\n      InputType: \"number\" // for required case\n    },\n    \"Any of These\": {\n      ValidInputCount: -1,\n      InputType: \"\" // for required case\n    },\n    \"All of These\": {\n      ValidInputCount: -1,\n      InputType: \"\" // for required case\n    },\n    \"None of Any of These\": {\n      ValidInputCount: -1,\n      InputType: \"\" // for required case\n    },\n    \"None of All of These\": {\n      ValidInputCount: -1,\n      InputType: \"\" // for required case\n    }\n  };\n  let info = {\n    ValidInputCount: 1,\n    InputType: \"\" // for required case\n  };\n  if (operatorInfoHashmap[operatorDisplayName]) {\n    info = operatorInfoHashmap[operatorDisplayName];\n  }\n  return info;\n};\nvar _c, _c2;\n$RefreshReg$(_c, \"CreateUUID\");\n$RefreshReg$(_c2, \"CommonLoadingPopup\");","map":{"version":3,"names":["React","Component","DuoIconV2","Icon","Popup","jsxDEV","_jsxDEV","uuidv4","require","v4","userInfo","isAdminUser","isSuperAdmin","checkboxWidth","patentIDWidth","titleWidth","descriptionWidth","multiLabelSeparator","clientBasedFeatures","IN_PROGRESS","SUCCESS","MIX_STATUS","FAIL","TRAINING_KEYWORD","getInstanceID","CreateUUID","_c","isValidData","input","undefined","checkEmpty","inputArr","empty","length","hasDataList","hasData","getSortingDataByNameAndOrder","currentData","name","order","sort","a","b","nameA","toLowerCase","nameB","binarySearch","data","target","startIndex","endIndex","middle","Math","floor","abs","getCurrentTimeStamp","Date","getTime","convertArrayToHashMap","columnKey","hashMap","map","eachInput","console","log","getCurrentUTCDateTime","currentDate","utcTimeParse","toUTCString","year","getFullYear","month","getMonth","toString","date","getDate","utcDate","hour","getUTCHours","minute","getUTCMinutes","second","getUTCSeconds","utcTime","convertSimpleDateTotUTCDateTime","inputDate","CommonLoadingPopup","open","content","contentStyle","background","width","height","textAlign","border","closeOnDocumentClick","position","lockScroll","children","className","fileName","_jsxFileName","lineNumber","columnNumber","_c2","MultiColumnsSearchBox","constructor","props","prepareInitialData","searchColumnName","searchValue","disableSearchBtn","itemList","itemHashMap","eachItem","Value","setState","handleChangeSearchColumnName","itemName","handleChangeSearchValue","event","getActiveInfo","activeColumnInfo","state","index","keyPress","e","keyCode","preventDefault","searchBtnRef","current","focus","onKeyDown","handleSearchOnClick","searchValueRef","DisplayName","DuoIconName","createRef","componentDidMount","componentWillReceiveProps","nextProps","nextContext","render","activeInfo","style","size","IconName","icon","type","ref","placeholder","value","onChange","paddingRight","eachItemInfo","onClick","disabled","defaultProps","prepareInitialPredictionParameters","inputTrainingParameters","parameterInfoList","languageSelectedNeeded","newTrainingParameters","JSON","parse","stringify","eachTrainingParameter","disabledChanges","Name","rangeCheck","possibleValues","multiInputCase","inputPossibleValues","inputValue","minValue","maxValue","selectedValue","DefaultValue","MinValue","MaxValue","Type","parseInt","parseFloat","PossibleValue","split","concat","Description","SelectedValue","InputPossibleValues","InputValue","checkValid","getMlDataTypeSafety","dataType","mlDataType","checkAllItemsUnSelected","items","allUnSelected","isSelected","checkAllItemsSelected","allSelected","checkAndUpdateSelectAllItems","selectAllItems","itemInfoList","itemSelected","getDataTypeTag","charAt","toUpperCase","slice","checkAndAppendUniqueIDs","allIDs","inputID","includes","push","checkAndAppendUniqueIDsForMultiLabels","inputIDs","eachID","convertPredictionResults","predictionResults","multiLabelModel","multiOutputModel","outputColumnList","multiClass","patentIDs","classificationIDs","historyTab","pageNumber","pageSize","patentInsight","showRelevanceValue","checkedData","convertPredictionResultsForMultiOutputColumns","tableRowCount","predictionIDs","specificPatentIDs","patentIDsHashmapByPredictionID","rowCountForMultiLabelModel","eachPatent","patentIndex","getSerialRowNumber","patentID","PatentID","predictionID","PredictionID","includedPatentIDs","Output","eachPatentOutput","splitArr","outputArr","eachClass","replaceAll","jsonStr","jsonParsed","startsWith","innerSplitArr","endsWith","newClassIDs","eachRowCount","Score","eachPatentScoreValue","scoreValueArr","originalValueArr","eachScoreValue","eachFixedScore","getFixedNumber","Confidence","OriginalRelevanceValue","RelevanceValueArr","OriginalRelevanceValueArr","relevanceArr","outputValueHashmap","eachOutputColumn","Array","isArray","scoreValueHashmap","eachColumn","checkPasswordValidation","inputPassword","valid","test","PasswordValidator","Schema","is","min","max","has","uppercase","lowercase","digits","not","spaces","oneOf","validate","list","getPosition","rowNumberWidth","includedCheckbox","includedTitle","includedAbstract","includedDescription","checkboxSpace","titleSpace","descriptionSpace","checkAndAssignedPatentValueForPredictionResults","predictionResultList","patentValueHashmap","title","description","abstract","Title","Abstract","prepareClassificationInfoForPredictionResults","outputAndNoOfClasses","hideClassificationHyperlink","classificationColumnName","arguments","headerList","outputClassList","classificationNameHashmap","outputNodeNameHashmap","classifiedDateHashmap","showCompanyName","checkData","prepareClassificationInfoForResultsOfMultiOutputColumns","Key","NodeName","OutputColumn","Pinned","outputHeaderList","eachClassHeader","outputClassIndex","ShowToolTip","HideHyperlink","eachDataRow","relevanceValueArr","originalRelevanceValueArr","eachHeader","headerIndex","eachRelevanceValue","eachRelevanceKey","eachOriginalRelevanceValue","eachOriginalRelevanceKey","CreatedAt","getClassifiedDate","ColumnName","MultiValueLabel","classID","getClassificationID","classificationNames","eachClassID","eachClassName","classificationID","classificationName","displayName","key","eachOutput","outputCount","outputIndex","valueArr","relatedHeaderList","outputValue","outputHashmap","output","checkAndAssignDefaultValue","prepareOverviewStatusFromAllDetailedInfos","detailStatusInfos","foundInProgress","foundSuccess","foundFailed","eachInfo","Status","status","calculateDisplayFileSize","inputFileSize","displayFileSize","kiloSize","toFixed","convertUtcToCurrentDateAndTime","inputUtcTime","timeStamp","localDateTimeArr","toLocaleString","hour12","time","ampm","splitTime","hours","minutes","updateTime","seconds","Time","getFormattedPatentIDs","outputPatentIDs","eachPatentID","patentFormatter","inputPatentID","replacedText","getColumnWordSize","wordSize","padding","getFiledName","fieldName","prepareColumnDefs","columnInfoList","columnDefs","abstractWidth","otherColumnWidth","modifiedColumnNames","columnIndex","filedName","OldName","NewName","colDef","headerName","field","flex","minWidth","wrapText","sortable","pinned","lockPinned","columnNameLower","convertTableData","modifiedInfoList","previewData","prevDataStr","getOppositeColor","color","r","g","hsp","match","replace","sqrt","calculateDisplayPatentSize","inputSize","getResponseMessage","responseCode","pageType","requestID","message","getCurrentLocalTimeForFolderName","dateSplitArr","day","getCurrentLocalTime","prepareDownloadFolderName","modelName","predictionName","patentSearchCase","folderName","splitModelNames","shortModelName","eachName","firstChar","regex","isChar","firstCharUpper","localTime","calculatePercentage","total","percentage","digitCount","minDigit","maxDigit","fixedValue","createdAt","convData","formattedDate","getMaxNumberOfArray","numbers","reduce","accumulator","currentValue","getAboveThresholdCount","rowData","threshold","newRowDataArr","newArr","eachData","getRoleBasedInfo","role","superAdminID","adminID","CreatedBy","AssignedBy","getCheckValidateHeaderColumnForReinforce","inputColumnList","requiredColumns","successHeader","ColumnInfo","sameInitialCount","ColumnInfoForOutputColumn","checkCountSuccess","columnList","checkReinforceColumnMappingsInfo","requiredColumnMappings","validColumnInfoListForOutputColumn","usedColumnHashmap","mappableColumnsCount","availableColumnList","availableOutputColumns","MappedColumnName","mappedColumnName","nameLower","mappedNameLower","skipHeaderCheck","skipColumnMapping","getDefaultClassBasedMetrics","formatDate","dd","mm","yyyy","getPreviousNthDate","nthDay","d","setDate","getDisplayDateInfoFromDatePicker","dateValue","displayValue","format","getActualModelName","inputModelName","outputModelName","lastValue","secondLast","openUrl","urlLink","window","foundSearchValue","inputName","inputNameLower","searchValueLower","found","checkLightOrDark","getTextColor","colorType","prepareBooleanAndSqlQueryInfo","inputQuery","startKeywords","innerKeywords","sqlQueryInfo","booleanQueryInfo","startCondition","spaceSplitArr","clauseName","clauseList","eachClauseValue","eachWord","ClauseName","Clause","boolClause","infoIndex","ClauseValue","getDescriptionForModuleName","inputModuleName","descriptionHashmap","descriptionValue","getModulesForNestedFilterConditions","moduleNames","filterConditions","eachCondition","FilterValueInfo","ModuleName","NestedFilterConditions","getSameValuePatents","allRows","newRows","documentMap","eachRow","Actual","Predict","DocumentNo","getNotIncludePatents","inputSamePatents","allPredictRows","foundHashmap","notIncludeRows","getDefaultDraftOutlineList","isExpand","Children","prepareDraftSectionOutlines","draftSections","outlineList","newOutlineList","eachOutline","outlineKey","foundChildList","eachChild","prepareRemainingDraftSections","getDisplayStatus","inputStatus","statusMap","displayStatus","changeAndUpdateSectionSelection","sectionList","keyword","selectedCount","eachSection","getSelectedDraftedSections","inventionSectionList","sections","concatInventionData","invention","textData","InventionDescription","ProblemSolved","NoveltyAndNonObviousness","PriorArts","CommercializationPotential","getLastIndexByGivenName","defaultVariableName","lastIndex","variableIndexStr","Number","currentIndex","checkClaimTitle","isTitle","valueLower","splitDataArrBySubStr","textArr","subStr","splitDataArr","eachText","eachSplitStr","convertSentimentDataToStrArr","textInput","sentimentTextArr","convertedStrArr","getDefaultColor","colorList","getDefaultUserTypes","getParseData","inputData","getMenuIconClass","negativeIconList","getSeparatedModelNameAndVersion","version","getOperatorSpecificInfo","operatorDisplayName","operatorInfoHashmap","ValidInputCount","InputType","info","$RefreshReg$"],"sources":["D:/Task/dashboard/src/assets/components/PopupComponents/BasicComponents/CommonMethods.js"],"sourcesContent":["import React, {Component} from 'react';\r\nimport DuoIconV2 from \"../../../IconLibrary/DuoIcon\";\r\nimport Icon from \"../../../IconLibrary/Icon\";\r\nimport Popup from \"reactjs-popup\";\r\nimport \"./FeatureStore.css\"\r\n\r\nconst uuidv4 = require('uuid').v4;\r\n\r\nlet userInfo = {}\r\nlet isAdminUser = false\r\nlet isSuperAdmin = false\r\nlet checkboxWidth = 50;\r\nlet patentIDWidth = 200;\r\nlet titleWidth = 150;\r\nlet descriptionWidth = 200;\r\nlet multiLabelSeparator = \";\"\r\nlet clientBasedFeatures = []\r\n\r\nexport const IN_PROGRESS = \"in progress\"\r\nexport const SUCCESS = \"success\"\r\nexport const MIX_STATUS = \"success_fail\"\r\nexport const FAIL = \"fail\"\r\nexport const TRAINING_KEYWORD = \"training\"\r\n\r\nexport const getInstanceID = () => {\r\n    return \"00000000-0000-0000-0000-000000000000\"\r\n}\r\n\r\nexport const CreateUUID = () => {\r\n    return uuidv4()\r\n}\r\n\r\nexport const isValidData = (input) => {\r\n    return input !== undefined && input !== null && input !== \"\"\r\n}\r\n\r\nexport const checkEmpty = (inputArr) => {\r\n    let empty = true\r\n    if (inputArr !== undefined && inputArr !== null && inputArr.length > 0) {\r\n        empty = false\r\n    }\r\n    return empty\r\n}\r\n\r\nexport const hasDataList = (inputArr) => {\r\n    let hasData = false\r\n    if (inputArr !== undefined && inputArr !== null && inputArr.length > 0) {\r\n        hasData = true\r\n    }\r\n    return hasData\r\n}\r\n\r\nexport const getSortingDataByNameAndOrder = (currentData, name, order) => {\r\n    currentData.sort(function (a, b) {\r\n        let nameA = a[name].toLowerCase(); // ignore upper and lowercase\r\n        let nameB = b[name].toLowerCase(); // ignore upper and lowercase\r\n        if (order === \"desc\") {\r\n            if (nameA > nameB) {\r\n                return -1;\r\n            }\r\n            if (nameA < nameB) {\r\n                return 1;\r\n            }\r\n        } else {\r\n            if (nameA < nameB) {\r\n                return -1;\r\n            }\r\n            if (nameA > nameB) {\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    });\r\n    return currentData\r\n}\r\n\r\nexport const binarySearch = (data, target, startIndex, endIndex) => {\r\n    const middle = Math.floor((startIndex + endIndex) / 2);\r\n    if (target === data[middle]) return data[middle];\r\n    if (endIndex - 1 === startIndex) {\r\n        return Math.abs(data[startIndex] - target) > Math.abs(data[endIndex] - target) ? data[endIndex] : data[startIndex];\r\n    } else if (target > data[middle]) {\r\n        return binarySearch(data, target, middle, endIndex);\r\n    } else if (target < data[middle]) {\r\n        return binarySearch(data, target, startIndex, middle);\r\n    }\r\n}\r\n\r\nexport const getCurrentTimeStamp = () => {\r\n    return Math.floor(new Date().getTime()) //by milliseconds, (if want for second, divide by 1000)\r\n}\r\n\r\nexport const convertArrayToHashMap = (inputArr, columnKey) => {\r\n    let hashMap = {}\r\n    if (isValidData(columnKey)) {\r\n        inputArr.map(eachInput => {\r\n            if (isValidData(eachInput[columnKey])) {\r\n                hashMap[eachInput[columnKey]] = eachInput\r\n            } else {\r\n                console.log(\"key is not included in the pass data\")\r\n            }\r\n        })\r\n    } else { //for true/false case\r\n        inputArr.map(eachInput => {\r\n            hashMap[eachInput] = true\r\n        })\r\n    }\r\n\r\n    return hashMap\r\n}\r\n\r\nexport const getCurrentUTCDateTime = () => {\r\n    let currentDate = new Date()\r\n    let utcTimeParse = new Date(currentDate.toUTCString())\r\n    let year = utcTimeParse.getFullYear()\r\n    let month = utcTimeParse.getMonth() + 1\r\n    if (month.toString().length === 1) {\r\n        month = \"0\" + month.toString()\r\n    }\r\n    let date = utcTimeParse.getDate()\r\n    if (date.toString().length === 1) {\r\n        date = \"0\" + date.toString()\r\n    }\r\n\r\n    let utcDate = year + \"-\" + month + \"-\" + date\r\n    let hour = utcTimeParse.getUTCHours()\r\n    if (hour < 10) {\r\n        hour = \"0\" + hour\r\n    }\r\n    let minute = utcTimeParse.getUTCMinutes()\r\n    if (minute < 10) {\r\n        minute = \"0\" + minute\r\n    }\r\n    let second = utcTimeParse.getUTCSeconds()\r\n    if (second < 10) {\r\n        second = \"0\" + second\r\n    }\r\n\r\n    let utcTime = hour + \":\" + minute + \":\" + second\r\n\r\n    // for direct hours //TODO to remove after tested\r\n    // let utcDate2 = year + \"-\" + month + \"-\" + date\r\n    // let hour2 = utcTimeParse.getHours()\r\n    // if (hour2 < 10) {\r\n    //     hour2 = \"0\" + hour2\r\n    // }\r\n    // let minute2 = utcTimeParse.getMinutes()\r\n    // if (minute2 < 10) {\r\n    //     minute2 = \"0\" + minute2\r\n    // }\r\n    // let second2 = utcTimeParse.getSeconds()\r\n    // if (second2 < 10) {\r\n    //     second2 = \"0\" + second2\r\n    // }\r\n    // let utcTime2 = hour2 + \":\" + minute2 + \":\" + second2\r\n    // let dateValue2 = utcDate2 + \"T\" + utcTime2 + \"Z\"\r\n    // let dateValue1 = utcDate + \"T\" + utcTime + \"Z\"\r\n    //\r\n    // console.log(\"#Converted UTC time1: \", dateValue1, \"=> \", convertUtcToCurrentDateAndTime(dateValue1))\r\n    // console.log(\"#Converted UTC time2: \", dateValue2, \"=> \", convertUtcToCurrentDateAndTime(dateValue2))\r\n\r\n    return utcDate + \"T\" + utcTime + \"Z\"\r\n}\r\n\r\nexport const convertSimpleDateTotUTCDateTime = (inputDate) => {\r\n    let currentDate = new Date(inputDate)\r\n    let utcTimeParse = new Date(currentDate.toUTCString())\r\n    let year = utcTimeParse.getFullYear()\r\n    let month = utcTimeParse.getMonth() + 1\r\n    if (month.toString().length === 1) {\r\n        month = \"0\" + month.toString()\r\n    }\r\n    let date = utcTimeParse.getDate()\r\n    if (date.toString().length === 1) {\r\n        date = \"0\" + date.toString()\r\n    }\r\n\r\n    let utcDate = year + \"-\" + month + \"-\" + date\r\n    let hour = utcTimeParse.getUTCHours()\r\n    if (hour < 10) {\r\n        hour = \"0\" + hour\r\n    }\r\n    let minute = utcTimeParse.getUTCMinutes()\r\n    if (minute < 10) {\r\n        minute = \"0\" + minute\r\n    }\r\n    let second = utcTimeParse.getUTCSeconds()\r\n    if (second < 10) {\r\n        second = \"0\" + second\r\n    }\r\n\r\n    let utcTime = hour + \":\" + minute + \":\" + second\r\n    return utcDate + \"T\" + utcTime + \"Z\"\r\n}\r\n\r\nexport const CommonLoadingPopup = (input) => {\r\n    let open = input.open;\r\n    let content = input.content;\r\n    return (\r\n        <Popup\r\n            contentStyle={{\r\n                background: 'transparent',\r\n                width: 'auto',\r\n                height: 'auto',\r\n                textAlign: 'center',\r\n                border: 'none',\r\n            }} open={open}\r\n            closeOnDocumentClick={false}\r\n            position=\"top right\"\r\n            lockScroll={true}>\r\n            <button className=\"loadingContainer\">\r\n                {content} &emsp;\r\n                <span className=\"loading-icon\"/>\r\n            </button>\r\n        </Popup>\r\n    )\r\n}\r\n\r\nexport class MultiColumnsSearchBox extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            searchColumnName: \"\",\r\n            searchValue: \"\",\r\n            itemHashMap: {},\r\n            itemList: [\r\n                {DisplayName: \"item name\", Value: \"item\", DuoIconName: \"feature_store\"},\r\n                {DisplayName: \"variable/operator name\", Value: \"variable\", DuoIconName: \"column\"},\r\n            ],\r\n            disableSearchBtn: true,\r\n        }\r\n        this.searchBtnRef = React.createRef()\r\n        this.searchValueRef = React.createRef()\r\n    }\r\n\r\n    componentDidMount() {\r\n        const {searchColumnName, searchValue, disableSearchBtn, itemList} = this.props;\r\n        this.prepareInitialData(searchColumnName, searchValue, disableSearchBtn, itemList)\r\n    }\r\n\r\n    componentWillReceiveProps(nextProps, nextContext) {\r\n        const {searchColumnName, searchValue, disableSearchBtn, itemList} = nextProps;\r\n        this.prepareInitialData(searchColumnName, searchValue, disableSearchBtn, itemList)\r\n    }\r\n\r\n    prepareInitialData = (searchColumnName, searchValue, disableSearchBtn, itemList) => {\r\n        let itemHashMap = {}\r\n        itemList.map(eachItem => {\r\n            itemHashMap[eachItem.Value] = eachItem\r\n        })\r\n        this.setState({\r\n            searchColumnName,\r\n            searchValue,\r\n            itemList,\r\n            itemHashMap,\r\n            disableSearchBtn\r\n        })\r\n    }\r\n\r\n    handleChangeSearchColumnName = (itemName) => {\r\n        if (this.props.handleChangeSearchColumnName !== undefined && this.props.handleChangeSearchColumnName !== null) {\r\n            this.props.handleChangeSearchColumnName(itemName)\r\n        }\r\n    }\r\n\r\n    handleChangeSearchValue = (event) => {\r\n        if (this.props.handleChangeSearchValue !== undefined && this.props.handleChangeSearchValue !== null) {\r\n            this.props.handleChangeSearchValue(event)\r\n        }\r\n    }\r\n\r\n    getActiveInfo = (searchColumnName) => {\r\n        let activeColumnInfo = \"\"\r\n        let {itemList} = this.state;\r\n        if (isValidData(this.state.itemHashMap[searchColumnName])) {\r\n            activeColumnInfo = this.state.itemHashMap[searchColumnName]\r\n        } else {\r\n            for (let index = 0; index < itemList.length; index++) {\r\n                if (itemList[index].Value === searchColumnName) {\r\n                    activeColumnInfo = itemList[index]\r\n                }\r\n            }\r\n        }\r\n        return activeColumnInfo\r\n    }\r\n\r\n    keyPress = (e) => {\r\n        if (e.keyCode === 13) {\r\n            e.preventDefault()\r\n            this.searchBtnRef.current.focus()\r\n            if (this.props.onKeyDown !== undefined && this.props.onKeyDown !== null) {\r\n                this.props.onKeyDown()\r\n            } else if (this.props.handleSearchOnClick !== undefined && this.props.handleSearchOnClick !== null) {\r\n                this.props.handleSearchOnClick()\r\n            }\r\n        } else if (e.keyCode === 38) {\r\n            e.preventDefault()\r\n            this.searchValueRef.current.focus()\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const {searchColumnName, searchValue, disableSearchBtn, itemList} = this.state;\r\n        const {onKeyDown, handleSearchOnClick, width} = this.props;\r\n        let activeInfo = this.getActiveInfo(searchColumnName)\r\n        return (\r\n            <div className=\"feature-store-feature-search-box\" style={{width: width}}>\r\n                <div className=\"feature-search-box\">\r\n                    <div className=\"feature-search-box-left\" style={{width: \"100%\"}}>\r\n                        <div className=\"feature-search-icon\">\r\n                            {\r\n                                activeInfo.DuoIconName ?\r\n                                    <DuoIconV2 name={activeInfo.DuoIconName}\r\n                                               size={16}/>\r\n                                    :\r\n                                    activeInfo.IconName ?\r\n                                        <Icon icon={activeInfo.IconName}\r\n                                              size={14}/>\r\n                                        :\r\n                                        null\r\n                            }\r\n                        </div>\r\n                        {\r\n                            (onKeyDown !== undefined && onKeyDown !== null) || (handleSearchOnClick !== undefined && handleSearchOnClick !== null) ?\r\n                                <input type={\"text\"}\r\n                                       ref={this.searchValueRef}\r\n                                       onKeyDown={(event) => this.keyPress(event)}\r\n                                       placeholder={activeInfo.DisplayName}\r\n                                       value={searchValue}\r\n                                       onChange={(event) => this.handleChangeSearchValue(event)}\r\n                                       style={{paddingRight: \"20px\"}}\r\n                                       className=\"feature-search-input-box\"/>\r\n                                :\r\n                                <input type={\"text\"}\r\n                                       ref={this.searchValueRef}\r\n                                       placeholder={activeInfo.DisplayName}\r\n                                       value={searchValue}\r\n                                       onChange={(event) => this.handleChangeSearchValue(event)}\r\n                                       style={{paddingRight: \"20px\"}}\r\n                                       className=\"feature-search-input-box\"/>\r\n                        }\r\n\r\n                        <Icon icon={\"search\"} size=\"14\" className=\"filter-popup-search-icon\"/>\r\n                        <button\r\n                            className=\"feature-search-dropdown\">\r\n                            <Icon icon=\"drop_down\" size=\"small\"/>\r\n\r\n                            <div className=\"feature-search-box-drop-down-list\">\r\n                                {\r\n                                    itemList.map((eachItemInfo, index) =>\r\n                                        <div key={index}\r\n                                             className=\"feature-search-box-drop-down-item\"\r\n                                             onClick={() => this.handleChangeSearchColumnName(eachItemInfo.Value)}>\r\n                                            {\r\n                                                eachItemInfo.DuoIconName ?\r\n                                                    <DuoIconV2 name={eachItemInfo.DuoIconName}\r\n                                                               size={14}\r\n                                                               className=\"feature-search-box-drop-down-icon\"/>\r\n                                                    :\r\n                                                    eachItemInfo.IconName ?\r\n                                                        <Icon icon={eachItemInfo.IconName}\r\n                                                              size={14}\r\n                                                              className=\"feature-search-box-drop-down-icon\"/>\r\n                                                        :\r\n                                                        null\r\n                                            }\r\n\r\n                                            {\"Search by \" + eachItemInfo.DisplayName}\r\n                                            {\r\n                                                searchColumnName === eachItemInfo.Value &&\r\n                                                <div className=\"feature-search-box-drop-down-check\">\r\n                                                    <Icon icon=\"check_circle_outline\" size={14}/>\r\n                                                </div>\r\n                                            }\r\n                                        </div>\r\n                                    )\r\n                                }\r\n                            </div>\r\n                        </button>\r\n                    </div>\r\n                    <button onClick={this.props.handleSearchOnClick}\r\n                            ref={this.searchBtnRef}\r\n                            disabled={disableSearchBtn}\r\n                            className=\"feature-search-box-btn\">\r\n                        Search\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nMultiColumnsSearchBox.defaultProps = {\r\n    width: \"unset\"\r\n}\r\n\r\nexport const prepareInitialPredictionParameters = (inputTrainingParameters) => {\r\n    let parameterInfoList = [];\r\n    let languageSelectedNeeded = false\r\n    let newTrainingParameters = JSON.parse(JSON.stringify(inputTrainingParameters));\r\n    if (newTrainingParameters.length !== 0) {\r\n        newTrainingParameters.map((eachTrainingParameter) => {\r\n            let disabledChanges = false\r\n            if (eachTrainingParameter.Name === \"source_language\") {\r\n                languageSelectedNeeded = true\r\n                disabledChanges = true\r\n            } else if (eachTrainingParameter.Name === \"target_language\") {\r\n                languageSelectedNeeded = true\r\n            }\r\n            let rangeCheck = false\r\n            let possibleValues = [];\r\n            let multiInputCase = false\r\n            let inputPossibleValues = []\r\n            let inputValue = \"\"\r\n            let minValue = \"\"\r\n            let maxValue = \"\"\r\n            let selectedValue = eachTrainingParameter.DefaultValue\r\n            if (eachTrainingParameter.Name === \"Labels\") { // may need to check with domain name\r\n                multiInputCase = true\r\n            } else {\r\n                if (isValidData(eachTrainingParameter.MinValue) && isValidData(eachTrainingParameter.MaxValue)) {\r\n                    rangeCheck = true\r\n                    if (eachTrainingParameter.Type === \"int\") {\r\n                        minValue = parseInt(eachTrainingParameter.MinValue)\r\n                        if (eachTrainingParameter.MaxValue !== \"inf\") {\r\n                            maxValue = parseInt(eachTrainingParameter.MaxValue)\r\n                        } else {\r\n                            maxValue = eachTrainingParameter.MaxValue\r\n                        }\r\n                    } else if (eachTrainingParameter.Type === \"float\") {\r\n                        minValue = parseFloat(eachTrainingParameter.MinValue)\r\n                        if (eachTrainingParameter.MaxValue !== \"inf\") {\r\n                            maxValue = parseFloat(eachTrainingParameter.MaxValue)\r\n                        } else {\r\n                            maxValue = eachTrainingParameter.MaxValue\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (isValidData(eachTrainingParameter.PossibleValue)) {\r\n                possibleValues = eachTrainingParameter.PossibleValue.split(\",\")\r\n                selectedValue = possibleValues[0]\r\n                if (multiInputCase) {\r\n                    inputPossibleValues = possibleValues\r\n                    inputValue = \"\"\r\n                }\r\n            }\r\n\r\n            //to add selected value\r\n            parameterInfoList = parameterInfoList.concat({\r\n                Name: eachTrainingParameter.Name,\r\n                Description: eachTrainingParameter.Description,\r\n                DefaultValue: eachTrainingParameter.DefaultValue,\r\n                PossibleValue: possibleValues,\r\n                Type: eachTrainingParameter.Type,\r\n                MinValue: minValue,\r\n                MaxValue: maxValue,\r\n                SelectedValue: selectedValue, // for single selected case\r\n                InputPossibleValues: inputPossibleValues, //for multiple input case\r\n                InputValue: inputValue,\r\n                checkValid: true,\r\n                rangeCheck: rangeCheck,\r\n                multiInputCase: multiInputCase,\r\n                disabledChanges: disabledChanges\r\n            })\r\n\r\n            return parameterInfoList\r\n        })\r\n    }\r\n\r\n    // console.log(\"Prepared parameter info list : \", parameterInfoList)\r\n    return {\r\n        parameterInfoList,\r\n        languageSelectedNeeded\r\n    }\r\n}\r\n\r\nexport const getMlDataTypeSafety = (dataType) => {\r\n    //check if it is scaled or not\r\n    dataType = dataType.toLowerCase()\r\n    let mlDataType = dataType\r\n    switch (dataType) {\r\n        case \"string\":\r\n            mlDataType = \"str\"\r\n            break\r\n        case \"nlp\":\r\n            mlDataType = \"int\"\r\n            break\r\n        case \"image\":\r\n            mlDataType = \"int\"\r\n            break\r\n        case \"audio\":\r\n            mlDataType = \"int\"\r\n            break\r\n        case \"video\":\r\n            mlDataType = \"int\"\r\n            break\r\n        case \"tinyint\":\r\n            mlDataType = \"int\"\r\n            break\r\n        case \"real\":\r\n            mlDataType = \"float\"\r\n            break\r\n        case \"enum\":\r\n            mlDataType = \"int\"\r\n            break\r\n        case \"integer\":\r\n            mlDataType = \"int\"\r\n            break\r\n        case \"number\":\r\n            mlDataType = \"int\"\r\n            break\r\n        case \"int32\":\r\n            mlDataType = \"int\"\r\n            break\r\n        case \"int64\":\r\n            mlDataType = \"int\"\r\n            break\r\n        case \"float32\":\r\n            mlDataType = \"float\"\r\n            break\r\n        case \"float64\":\r\n            mlDataType = \"float\"\r\n            break\r\n        case \"double\":\r\n            mlDataType = \"float\"\r\n            break\r\n        case \"varchar\":\r\n            mlDataType = \"string\"\r\n            break\r\n        case \"complex\":\r\n            mlDataType = \"float\"\r\n            break\r\n        case \"varchar2\":\r\n            mlDataType = \"string\"\r\n            break\r\n        case \"text\":\r\n            mlDataType = \"string\"\r\n            break\r\n        case \"char varying\":\r\n            mlDataType = \"string\"\r\n            break\r\n    }\r\n\r\n    return mlDataType\r\n}\r\n\r\nexport const checkAllItemsUnSelected = (items) => {\r\n    let allUnSelected = true\r\n    for (let index = 0; index < items.length; index++) {\r\n        if (items[index].isSelected === true) {\r\n            allUnSelected = false\r\n            break\r\n        }\r\n    }\r\n    return allUnSelected\r\n}\r\n\r\nexport const checkAllItemsSelected = (items) => {\r\n    let allSelected = true\r\n    for (let index = 0; index < items.length; index++) {\r\n        if (items[index].isSelected === false) {\r\n            allSelected = false\r\n            break\r\n        }\r\n    }\r\n    return allSelected\r\n}\r\n\r\nexport const checkAndUpdateSelectAllItems = (selectAllItems, itemInfoList, itemSelected) => {\r\n    if (selectAllItems === true) {\r\n        if (itemSelected === false) {\r\n            // check all cards are false or not if the current info is unselected\r\n            let allUnSelected = checkAllItemsUnSelected(itemInfoList)\r\n            if (allUnSelected === true) {\r\n                selectAllItems = false\r\n            }\r\n        } // else => it is clear that all items are not unselected, because current card is selected\r\n    } else {\r\n        if (itemSelected === true) {\r\n            let allSelected = checkAllItemsSelected(itemInfoList)\r\n            if (allSelected === true) {\r\n                selectAllItems = true\r\n            }\r\n        }// else => all items cannot be selected case, because current item is un selected\r\n    }\r\n\r\n    return selectAllItems\r\n}\r\n\r\nexport const getDataTypeTag = (dataType) => {\r\n    if (isValidData(dataType)) {\r\n        return (\r\n            <div className={\"default-data-type-tag \" + dataType}>\r\n                {dataType.charAt(0).toUpperCase() + dataType.slice(1)}\r\n            </div>\r\n        )\r\n    } else {\r\n        return (\r\n            <div className=\"default-data-type-tag\" style={{background: \"transparent\"}}>\r\n                {\"-\"}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nconst checkAndAppendUniqueIDs = (allIDs, inputID) => {\r\n    if (isValidData(inputID)) {\r\n        if (!allIDs.includes(inputID)) {\r\n            allIDs.push(inputID)\r\n        }\r\n    }\r\n    return allIDs\r\n}\r\n\r\nconst checkAndAppendUniqueIDsForMultiLabels = (allIDs, inputIDs) => {\r\n    if (hasDataList(inputIDs)) {\r\n        inputIDs.map(eachID => {\r\n            if (!allIDs.includes(eachID)) {\r\n                allIDs.push(eachID)\r\n            }\r\n        })\r\n    }\r\n    return allIDs\r\n}\r\n\r\nexport const convertPredictionResults = (predictionResults, multiLabelModel, multiOutputModel, outputColumnList, multiClass, patentIDs, classificationIDs, historyTab, pageNumber, pageSize, patentInsight, showRelevanceValue) => {\r\n    if (multiOutputModel === true) {\r\n        let checkedData = convertPredictionResultsForMultiOutputColumns(predictionResults, multiLabelModel, outputColumnList, multiClass, patentIDs, classificationIDs, historyTab, pageNumber, pageSize, patentInsight, showRelevanceValue)\r\n        return {\r\n            tableRowCount: checkedData.tableRowCount,\r\n            patentIDs: checkedData.patentIDs,\r\n            predictionIDs: checkedData.predictionIDs,\r\n            specificPatentIDs: checkedData.specificPatentIDs,\r\n            classificationIDs: checkedData.classificationIDs,\r\n            predictionResults: checkedData.predictionResults,\r\n            patentIDsHashmapByPredictionID: checkedData.patentIDsHashmapByPredictionID\r\n        }\r\n    }\r\n    let specificPatentIDs = []\r\n    let patentIDsHashmapByPredictionID = {}\r\n    let predictionIDs = []\r\n    let rowCountForMultiLabelModel = 0\r\n    if (hasDataList(predictionResults)) {\r\n        predictionResults.map((eachPatent, patentIndex) => {\r\n            eachPatent[\"no\"] = getSerialRowNumber(pageNumber, pageSize, patentIndex)\r\n            if (patentInsight === true) {\r\n                // prepare for nested hashmap\r\n                let patentID = eachPatent.PatentID\r\n                let predictionID = eachPatent.PredictionID\r\n                if (patentIDsHashmapByPredictionID[predictionID] !== undefined) {\r\n                    let includedPatentIDs = patentIDsHashmapByPredictionID[predictionID]\r\n                    if (!includedPatentIDs.includes(patentID)) {\r\n                        includedPatentIDs.push(patentID)\r\n                        patentIDsHashmapByPredictionID[predictionID] = includedPatentIDs\r\n                    }\r\n                } else {\r\n                    patentIDsHashmapByPredictionID[predictionID] = [patentID]\r\n                }\r\n                if (!predictionIDs.includes(predictionID)) {\r\n                    predictionIDs.push(predictionID)\r\n                }\r\n            }\r\n\r\n            if (!patentIDs.includes(eachPatent.PatentID)) {\r\n                patentIDs.push(eachPatent.PatentID)\r\n            }\r\n            if (!specificPatentIDs.includes(eachPatent.PatentID)) {\r\n                specificPatentIDs.push(eachPatent.PatentID)\r\n            }\r\n\r\n            if (isValidData(eachPatent.Output)) {\r\n                eachPatent.Output = eachPatent.Output.toString()\r\n                let eachPatentOutput;\r\n                if (historyTab === true) {\r\n                    eachPatentOutput = eachPatent.Output.slice(0, eachPatent.Output.length)\r\n                } else {\r\n                    // check if output is included double quote or not\r\n                    if (eachPatent.Output.includes(\"\\\"\")) {\r\n                        eachPatentOutput = eachPatent.Output.slice(1, eachPatent.Output.length - 1)\r\n                    } else {\r\n                        eachPatentOutput = eachPatent.Output.slice(0, eachPatent.Output.length)\r\n                    }\r\n                }\r\n\r\n                if (eachPatentOutput.includes(\",\")) {\r\n                    let splitArr = eachPatentOutput.split(\",\")\r\n                    let outputArr = []\r\n                    splitArr.map(eachClass => {\r\n                        eachClass = eachClass.replaceAll(\"\\\"\", \"\")\r\n                        if (historyTab !== true) {\r\n                            if (isValidData(eachClass)) {\r\n                                if (eachClass && eachClass.includes(\"\\\"\")) {\r\n                                    eachClass = eachClass.replaceAll(\"\\\"\", \"\")\r\n                                }\r\n                                let jsonStr = '{\"Output\":\"' + eachClass + '\"}'\r\n                                let jsonParsed = JSON.parse(jsonStr)\r\n                                eachClass = jsonParsed.Output\r\n                            }\r\n                        }\r\n                        if (eachClass.startsWith(\"[\")) {\r\n                            let innerSplitArr = eachClass.split(\"[\")\r\n                            eachClass = innerSplitArr[innerSplitArr.length - 1]\r\n                        } else if (eachClass.endsWith(\"]\")) {\r\n                            let innerSplitArr = eachClass.split(\"]\")\r\n                            eachClass = innerSplitArr[0]\r\n                        }\r\n                        outputArr.push(eachClass)\r\n                        classificationIDs = checkAndAppendUniqueIDs(classificationIDs, eachClass)\r\n                    })\r\n                    eachPatent.Output = outputArr\r\n                } else {\r\n                    if (historyTab !== true) {\r\n                        if (isValidData(eachPatentOutput)) {\r\n                            if (eachPatentOutput && eachPatentOutput.includes(\"\\\"\")) {\r\n                                eachPatentOutput = eachPatentOutput.replaceAll(\"\\\"\", \"\")\r\n                            }\r\n                            let jsonStr = '{\"Output\":\"' + eachPatentOutput + '\"}'\r\n                            let jsonParsed = JSON.parse(jsonStr)\r\n                            eachPatentOutput = jsonParsed.Output\r\n                        }\r\n                    }\r\n\r\n                    if (multiLabelModel === true) {\r\n                        let newClassIDs = eachPatentOutput.split(multiLabelSeparator)\r\n                        eachPatent.Output = newClassIDs\r\n                        classificationIDs = checkAndAppendUniqueIDsForMultiLabels(classificationIDs, newClassIDs)\r\n                        let eachRowCount = 1\r\n                        if (newClassIDs.length > 0) {\r\n                            eachRowCount = newClassIDs.length\r\n                        }\r\n                        rowCountForMultiLabelModel += eachRowCount\r\n                    } else {\r\n                        if (multiClass === true) {\r\n                            eachPatent.Output = [eachPatentOutput]\r\n                        } else {\r\n                            eachPatent.Output = eachPatentOutput\r\n                        }\r\n                        classificationIDs = checkAndAppendUniqueIDs(classificationIDs, eachPatentOutput)\r\n                    }\r\n                }\r\n            } else {\r\n                if (multiClass === true) {\r\n                    eachPatent.Output = []\r\n                } else {\r\n                    if (multiLabelModel === true) {\r\n                        eachPatent.Output = []\r\n                        rowCountForMultiLabelModel += 1\r\n                    } else {\r\n                        eachPatent.Output = \"\"\r\n                    }\r\n                }\r\n            }\r\n\r\n            // check for score value\r\n            if (showRelevanceValue === true) {\r\n                if (isValidData(eachPatent[\"Score\"])) {\r\n                    eachPatent.Score = eachPatent.Score.toString()\r\n                    // console.log(\"#eachPatent.Score: \", historyTab, \", \", eachPatent.Score)\r\n                    let eachPatentScoreValue;\r\n                    if (historyTab === true) {\r\n                        eachPatentScoreValue = eachPatent.Score.slice(0, eachPatent.Score.length)\r\n                    } else {\r\n                        // check if output is included double quote or not\r\n                        if (eachPatent.Score.includes(\"\\\"\")) {\r\n                            eachPatentScoreValue = eachPatent.Score.slice(1, eachPatent.Score.length - 1)\r\n                        } else {\r\n                            eachPatentScoreValue = eachPatent.Score.slice(0, eachPatent.Score.length)\r\n                        }\r\n                    }\r\n\r\n                    // checking for multiple class case\r\n                    if (eachPatentScoreValue.includes(\",\")) {\r\n                        let splitArr = eachPatentScoreValue.split(\",\")\r\n                        // console.log(\"#patent split arr: \", splitArr)\r\n                        let scoreValueArr = []\r\n                        let originalValueArr = []\r\n                        splitArr.map(eachScoreValue => {\r\n                            eachScoreValue = eachScoreValue.replaceAll(\"\\\"\", \"\")\r\n                            eachScoreValue = eachScoreValue.replaceAll(\"[\", \"\")\r\n                            if (historyTab !== true) {\r\n                                if (isValidData(eachScoreValue)) {\r\n                                    let jsonStr = '{\"Score\":\"' + eachScoreValue + '\"}'\r\n                                    let jsonParsed = JSON.parse(jsonStr)\r\n                                    eachScoreValue = jsonParsed.Score\r\n                                }\r\n                            }\r\n                            originalValueArr.push(parseFloat(eachScoreValue))\r\n                            let eachFixedScore = getFixedNumber(eachScoreValue, 4, 4)\r\n                            scoreValueArr.push(eachFixedScore)\r\n                        })\r\n                        eachPatent.Confidence = \"\"\r\n                        eachPatent.OriginalRelevanceValue = 0\r\n                        eachPatent.RelevanceValueArr = scoreValueArr // multiple case\r\n                        eachPatent.OriginalRelevanceValueArr = originalValueArr // for number value\r\n                    } else {\r\n                        if (historyTab !== true) {\r\n                            if (isValidData(eachPatentScoreValue)) {\r\n                                let jsonStr = '{\"Score\":\"' + eachPatentScoreValue + '\"}'\r\n                                let jsonParsed = JSON.parse(jsonStr)\r\n                                eachPatentScoreValue = jsonParsed.Score\r\n                            }\r\n                        }\r\n                        if (multiLabelModel === true) {\r\n                            let scoreValueArr = eachPatentScoreValue.split(multiLabelSeparator)\r\n                            let relevanceArr = []\r\n                            scoreValueArr.map(eachScoreValue => {\r\n                                relevanceArr.push(getFixedNumber(eachScoreValue, 4, 4))\r\n                            })\r\n                            eachPatent.Confidence = \"\"\r\n                            eachPatent.RelevanceValueArr = relevanceArr\r\n                            eachPatent.OriginalRelevanceValue = scoreValueArr\r\n                        } else {\r\n                            eachPatentScoreValue = getFixedNumber(eachPatentScoreValue, 4, 4)\r\n                            if (multiClass === true) {\r\n                                eachPatent.Confidence = \"\"\r\n                                eachPatent.RelevanceValueArr = [eachPatentScoreValue]\r\n                                eachPatent.OriginalRelevanceValue = [parseFloat(eachPatentScoreValue)]\r\n                            } else {\r\n                                eachPatent.Confidence = eachPatentScoreValue\r\n                                eachPatent.OriginalRelevanceValue = parseFloat(eachPatentScoreValue)\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (multiLabelModel === true) {\r\n                        eachPatent.Confidence = \"\"\r\n                        eachPatent.RelevanceValueArr = []\r\n                        eachPatent.OriginalRelevanceValue = []\r\n                    } else {\r\n                        if (multiClass === true) {\r\n                            eachPatent.RelevanceValueArr = []\r\n                            eachPatent.OriginalRelevanceValueArr = []\r\n                        } else {\r\n                            eachPatent.Confidence = \"\"\r\n                            eachPatent.OriginalRelevanceValue = 0\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    // console.log(\"#patentIDsHashmapByPredictionID: \", patentIDsHashmapByPredictionID)\r\n    // console.log(\"#predictionIDs: \", predictionIDs)\r\n    // console.log(\"#converted predictionResults: \", predictionResults)\r\n    let tableRowCount = multiLabelModel === true ? rowCountForMultiLabelModel : predictionResults.length\r\n    return {\r\n        tableRowCount,\r\n        patentIDs,\r\n        predictionIDs,\r\n        specificPatentIDs,\r\n        classificationIDs,\r\n        predictionResults,\r\n        patentIDsHashmapByPredictionID\r\n    }\r\n}\r\n\r\nexport const convertPredictionResultsForMultiOutputColumns = (predictionResults, multiLabelModel, outputColumnList, multiClass, patentIDs, classificationIDs, historyTab, pageNumber, pageSize, patentInsight, showRelevanceValue) => {\r\n    let specificPatentIDs = []\r\n    let patentIDsHashmapByPredictionID = {}\r\n    let predictionIDs = []\r\n    let rowCountForMultiLabelModel = 0\r\n    if (hasDataList(predictionResults)) {\r\n        predictionResults.map((eachPatent, patentIndex) => {\r\n            eachPatent[\"no\"] = getSerialRowNumber(pageNumber, pageSize, patentIndex)\r\n            if (patentInsight === true) {\r\n                // prepare for nested hashmap\r\n                let patentID = eachPatent.PatentID\r\n                let predictionID = eachPatent.PredictionID\r\n                if (patentIDsHashmapByPredictionID[predictionID] !== undefined) {\r\n                    let includedPatentIDs = patentIDsHashmapByPredictionID[predictionID]\r\n                    if (!includedPatentIDs.includes(patentID)) {\r\n                        includedPatentIDs.push(patentID)\r\n                        patentIDsHashmapByPredictionID[predictionID] = includedPatentIDs\r\n                    }\r\n                } else {\r\n                    patentIDsHashmapByPredictionID[predictionID] = [patentID]\r\n                }\r\n                if (!predictionIDs.includes(predictionID)) {\r\n                    predictionIDs.push(predictionID)\r\n                }\r\n            }\r\n\r\n            if (!patentIDs.includes(eachPatent.PatentID)) {\r\n                patentIDs.push(eachPatent.PatentID)\r\n            }\r\n            if (!specificPatentIDs.includes(eachPatent.PatentID)) {\r\n                specificPatentIDs.push(eachPatent.PatentID)\r\n            }\r\n\r\n            if (isValidData(eachPatent.Output)) {\r\n                let outputValueHashmap; // for all output columns (it will be with hashmap as string type)\r\n                if (historyTab === true) {\r\n                    outputValueHashmap = eachPatent.Output.slice(0, eachPatent.Output.length)\r\n                } else {\r\n                    outputValueHashmap = JSON.parse(eachPatent.Output)\r\n                }\r\n\r\n                outputColumnList.map(eachOutputColumn => {\r\n                    let eachPatentOutput = isValidData(outputValueHashmap[eachOutputColumn]) ? outputValueHashmap[eachOutputColumn] : \"\"\r\n                    if (Array.isArray(eachPatentOutput)) {\r\n                        let splitArr = eachPatentOutput\r\n                        let outputArr = []\r\n                        splitArr.map(eachClass => {\r\n                            outputArr.push(eachClass)\r\n                            classificationIDs = checkAndAppendUniqueIDs(classificationIDs, eachClass)\r\n                        })\r\n                        outputValueHashmap[eachOutputColumn] = outputArr\r\n                    } else {\r\n                        if (historyTab !== true) {\r\n                            if (isValidData(eachPatentOutput)) {\r\n                                if (eachPatentOutput && eachPatentOutput.includes(\"\\\"\")) {\r\n                                    eachPatentOutput = eachPatentOutput.replaceAll(\"\\\"\", \"\")\r\n                                }\r\n                                let jsonStr = '{\"Output\":\"' + eachPatentOutput + '\"}'\r\n                                let jsonParsed = JSON.parse(jsonStr)\r\n                                eachPatentOutput = jsonParsed.Output\r\n                            }\r\n                        }\r\n\r\n                        if (multiLabelModel === true) {\r\n                            let newClassIDs = eachPatentOutput.split(multiLabelSeparator)\r\n                            outputValueHashmap[eachOutputColumn] = newClassIDs\r\n                            classificationIDs = checkAndAppendUniqueIDsForMultiLabels(classificationIDs, newClassIDs)\r\n                            let eachRowCount = 1\r\n                            if (newClassIDs.length > 0) {\r\n                                eachRowCount = newClassIDs.length\r\n                            }\r\n                            rowCountForMultiLabelModel += eachRowCount\r\n                        } else {\r\n                            if (multiClass === true) {\r\n                                outputValueHashmap[eachOutputColumn] = [eachPatentOutput]\r\n                            } else {\r\n                                outputValueHashmap[eachOutputColumn] = eachPatentOutput\r\n                            }\r\n                            classificationIDs = checkAndAppendUniqueIDs(classificationIDs, eachPatentOutput)\r\n                        }\r\n                    }\r\n                })\r\n\r\n                eachPatent.Output = outputValueHashmap\r\n            } else {\r\n                if (multiClass === true) {\r\n                    eachPatent.Output = {}\r\n                } else {\r\n                    if (multiLabelModel === true) {\r\n                        eachPatent.Output = {}\r\n                        rowCountForMultiLabelModel += 1\r\n                    } else {\r\n                        eachPatent.Output = {}\r\n                    }\r\n                }\r\n            }\r\n\r\n            // check for score value\r\n            if (showRelevanceValue === true) {\r\n                if (isValidData(eachPatent[\"Score\"])) {\r\n                    // eachPatent.Score = eachPatent.Score.toString()\r\n                    // console.log(\"#eachPatent.Score: \", historyTab, \", \", eachPatent.Score)\r\n                    let scoreValueHashmap;\r\n                    if (historyTab === true) {\r\n                        scoreValueHashmap = eachPatent.Score.slice(0, eachPatent.Score.length)\r\n                    } else {\r\n                        scoreValueHashmap = JSON.parse(eachPatent[\"Score\"])\r\n                    }\r\n\r\n                    // console.log(\"#scoreValueHashmap: \", scoreValueHashmap)\r\n                    // set initial value (defined initial value)\r\n                    outputColumnList.map(eachColumn => {\r\n                        let eachPatentScoreValue = scoreValueHashmap[eachColumn]\r\n                        if (hasDataList(eachPatentScoreValue)) {\r\n                            let splitArr = eachPatentScoreValue\r\n                            let scoreValueArr = []\r\n                            let originalValueArr = []\r\n                            splitArr.map(eachScoreValue => {\r\n                                originalValueArr.push(eachScoreValue)\r\n                                let eachFixedScore = getFixedNumber(eachScoreValue.toString(), 4, 4)\r\n                                scoreValueArr.push(eachFixedScore)\r\n                            })\r\n                            eachPatent[eachColumn + \"_Confidence\"] = \"\"\r\n                            eachPatent[eachColumn + \"_OriginalRelevanceValue\"] = 0\r\n                            eachPatent[eachColumn + \"_RelevanceValueArr\"] = scoreValueArr\r\n                            eachPatent[eachColumn + \"_OriginalRelevanceValueArr\"] = originalValueArr\r\n                        } else {\r\n                            if (historyTab !== true) {\r\n                                if (isValidData(eachPatentScoreValue)) {\r\n                                    let jsonStr = '{\"Score\":\"' + eachPatentScoreValue + '\"}'\r\n                                    let jsonParsed = JSON.parse(jsonStr)\r\n                                    eachPatentScoreValue = jsonParsed.Score\r\n                                }\r\n                            }\r\n                            if (multiLabelModel === true) {\r\n                                let scoreValueArr = eachPatentScoreValue.split(multiLabelSeparator)\r\n                                let relevanceArr = []\r\n                                scoreValueArr.map(eachScoreValue => {\r\n                                    relevanceArr.push(getFixedNumber(eachScoreValue, 4, 4))\r\n                                })\r\n\r\n                                eachPatent[eachColumn + \"_Confidence\"] = \"\"\r\n                                eachPatent[eachColumn + \"_RelevanceValueArr\"] = relevanceArr\r\n                                eachPatent[eachColumn + \"_OriginalRelevanceValueArr\"] = scoreValueArr\r\n                            } else {\r\n                                eachPatentScoreValue = eachPatentScoreValue.toString()\r\n                                eachPatentScoreValue = getFixedNumber(eachPatentScoreValue, 4, 4)\r\n                                if (multiClass === true) {\r\n                                    eachPatent[eachColumn + \"_Confidence\"] = \"\"\r\n                                    eachPatent[eachColumn + \"_RelevanceValueArr\"] = [eachPatentScoreValue]\r\n                                    eachPatent[eachColumn + \"_OriginalRelevanceValueArr\"] = [parseFloat(eachPatentScoreValue)]\r\n                                } else {\r\n                                    eachPatent[eachColumn + \"_Confidence\"] = eachPatentScoreValue\r\n                                    eachPatent[eachColumn + \"_OriginalRelevanceValue\"] = parseFloat(eachPatentScoreValue)\r\n                                }\r\n                            }\r\n                        }\r\n                    })\r\n                } else {\r\n                    if (multiLabelModel === true) {\r\n                        outputColumnList.map(eachColumn => {\r\n                            eachPatent[eachColumn + \"_Confidence\"] = \"\"\r\n                            eachPatent[eachColumn + \"_RelevanceValueArr\"] = []\r\n                            eachPatent[eachColumn + \"_OriginalRelevanceValue\"] = []\r\n                        })\r\n                    } else {\r\n                        outputColumnList.map(eachColumn => {\r\n                            if (multiClass === true) {\r\n                                eachPatent[eachColumn + \"_RelevanceValueArr\"] = []\r\n                                eachPatent[eachColumn + \"_OriginalRelevanceValueArr\"] = []\r\n                            } else {\r\n                                eachPatent[eachColumn + \"_Confidence\"] = \"\"\r\n                                eachPatent[eachColumn + \"_OriginalRelevanceValue\"] = 0\r\n                            }\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    // console.log(\"#patentIDsHashmapByPredictionID: \", patentIDsHashmapByPredictionID)\r\n    // console.log(\"#predictionIDs: \", predictionIDs)\r\n    // console.log(\"#converted predictionResults: \", predictionResults)\r\n    let tableRowCount = multiLabelModel === true ? rowCountForMultiLabelModel : predictionResults.length\r\n    return {\r\n        tableRowCount,\r\n        patentIDs,\r\n        predictionIDs,\r\n        specificPatentIDs,\r\n        classificationIDs,\r\n        predictionResults,\r\n        patentIDsHashmapByPredictionID\r\n    }\r\n}\r\n\r\nexport const checkPasswordValidation = (inputPassword) => {\r\n    let valid = /^(?=.*[!\"'()+,-./:;<=>?\\\\_`~@#$%^&*{}|])/.test(inputPassword); // Should include special character\r\n    if (valid) {\r\n        let PasswordValidator = require('password-validator');\r\n        let Schema = new PasswordValidator();\r\n        Schema\r\n            .is().min(8)                                    // Minimum length 8\r\n            .is().max(100)                                  // Maximum length 100\r\n            .has().uppercase()                              // Must have uppercase letters\r\n            .has().lowercase()                              // Must have lowercase letters\r\n            .has().digits()                                 // Must have digits\r\n            .has().not().spaces()                           // Should not have spaces\r\n            .is().not().oneOf(['Passw0rd', 'Password123']);\r\n\r\n        valid = Schema.validate(inputPassword, {list: false})\r\n    }\r\n    console.log(\"Valid password - \", inputPassword, \" => \", valid)\r\n    return valid\r\n}\r\n\r\nexport const getPosition = (type, rowNumberWidth, includedCheckbox, includedTitle, includedAbstract, includedDescription) => {\r\n    let checkboxSpace = includedCheckbox ? checkboxWidth : rowNumberWidth;\r\n    let titleSpace = includedTitle ? titleWidth : rowNumberWidth;\r\n    // let abstractSpace = includedAbstract ? abstractWidth : rowNumberWidth;\r\n    let descriptionSpace = includedDescription ? descriptionWidth : rowNumberWidth;\r\n\r\n    if (type === \"checkbox\") {\r\n        return (0)\r\n    } else if (type === \"Patent ID\") {\r\n        return (checkboxSpace)\r\n    } else if (type === \"Title\") {\r\n        return (patentIDWidth + checkboxSpace)\r\n    } else if (type === \"Abstract\") {\r\n        return (patentIDWidth + checkboxSpace + titleSpace)\r\n    } else if (type === \"Description\") {\r\n        return (patentIDWidth + checkboxSpace + titleSpace + descriptionSpace)\r\n    }\r\n}\r\n\r\nexport const checkAndAssignedPatentValueForPredictionResults = (predictionResultList, patentValueHashmap) => {\r\n    predictionResultList.map(eachPatent => {\r\n        let title = \"\"\r\n        let description = \"\"\r\n        let abstract = \"\"\r\n        if (isValidData(patentValueHashmap[eachPatent.PatentID])) {\r\n            title = patentValueHashmap[eachPatent.PatentID].Title\r\n            description = patentValueHashmap[eachPatent.PatentID].Description\r\n            abstract = patentValueHashmap[eachPatent.PatentID].Abstract\r\n        }\r\n        eachPatent.Title = title\r\n        eachPatent.Description = description\r\n        eachPatent.Abstract = abstract\r\n    })\r\n    return predictionResultList\r\n}\r\n\r\nexport const prepareClassificationInfoForPredictionResults = (multiLabelModel, multiOutputModel, outputColumnList, outputAndNoOfClasses, hideClassificationHyperlink, classificationColumnName = \"\", headerList, outputClassList, predictionResults, classificationNameHashmap, outputNodeNameHashmap, classifiedDateHashmap, showRelevanceValue, showCompanyName) => {\r\n    if (multiOutputModel === true) {\r\n        let checkData = prepareClassificationInfoForResultsOfMultiOutputColumns(multiLabelModel, outputColumnList, outputAndNoOfClasses, hideClassificationHyperlink, headerList, outputClassList, predictionResults, classificationNameHashmap, outputNodeNameHashmap, classifiedDateHashmap, showRelevanceValue, showCompanyName)\r\n        return {\r\n            headerList: checkData.headerList,\r\n            predictionResults: checkData.predictionResults\r\n        }\r\n    }\r\n    // for company name\r\n    if (showCompanyName === true) {\r\n        headerList.push({\r\n            DisplayName: \"Competitor Name\",\r\n            Key: \"CompanyName\",\r\n            NodeName: \"CompanyName\",\r\n            OutputColumn: false,\r\n            Pinned: true\r\n        })\r\n    }\r\n\r\n    if (hasDataList(outputClassList) && outputClassList.length > 1) {\r\n        let outputHeaderList = []\r\n        outputClassList.map((eachClassHeader, outputClassIndex) => {\r\n            // header\r\n            outputHeaderList.push({\r\n                DisplayName: eachClassHeader,\r\n                NodeName: eachClassHeader,\r\n                Key: \"output\" + (outputClassIndex + 1),\r\n                ShowToolTip: true,\r\n                HideHyperlink: hideClassificationHyperlink,\r\n                OutputColumn: true\r\n            })\r\n        })\r\n\r\n        // to check and assign for reference data, for performance, checked condition outside\r\n        if (showRelevanceValue === true) {\r\n            if (isValidData(classificationNameHashmap)) {\r\n                if (hasDataList(predictionResults)) {\r\n                    predictionResults.map(eachDataRow => {\r\n                        if (Array.isArray(eachDataRow.Output)) {\r\n                            let relevanceValueArr = eachDataRow.RelevanceValueArr\r\n                            let originalRelevanceValueArr = eachDataRow.RelevanceValueArr\r\n                            outputHeaderList.map((eachHeader, headerIndex) => {\r\n                                let value = \"\"\r\n                                if (isValidData(eachDataRow.Output[headerIndex])) {\r\n                                    value = eachDataRow.Output[headerIndex]\r\n                                }\r\n                                eachDataRow[eachHeader.Key] = value // for classification value\r\n\r\n                                // for relevance value (output key _ relevance)\r\n                                let eachRelevanceValue = \"\"\r\n                                let eachRelevanceKey = eachHeader.Key + \"___relevance\"\r\n                                if (isValidData(relevanceValueArr[headerIndex])) {\r\n                                    eachRelevanceValue = relevanceValueArr[headerIndex]\r\n                                }\r\n                                eachDataRow[eachRelevanceKey] = eachRelevanceValue // for relevance value\r\n\r\n                                let eachOriginalRelevanceValue = 0\r\n                                let eachOriginalRelevanceKey = \"original___\" + eachRelevanceKey\r\n                                if (isValidData(originalRelevanceValueArr[headerIndex])) {\r\n                                    eachOriginalRelevanceValue = originalRelevanceValueArr[headerIndex]\r\n                                }\r\n                                eachDataRow[eachOriginalRelevanceKey] = eachOriginalRelevanceValue\r\n                            })\r\n                        } else {\r\n                            // for class count = 1 case\r\n                            outputHeaderList.map((eachHeader, headerIndex) => {\r\n                                let value = \"\"\r\n                                if (headerIndex === 0) {\r\n                                    value = eachDataRow.Output\r\n                                }\r\n                                eachDataRow[eachHeader.Key] = value // for classification value\r\n                            })\r\n                        }\r\n                        if (isValidData(classifiedDateHashmap)) {\r\n                            if (classifiedDateHashmap[eachDataRow.PredictionID]) {\r\n                                eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID]\r\n                            } else if (eachDataRow.CreatedAt) {\r\n                                eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt)\r\n                            } else {\r\n                                eachDataRow[\"ClassifiedDate\"] = \"-\"\r\n                            }\r\n                        }\r\n                    })\r\n                }\r\n            } else {\r\n                predictionResults.map(eachDataRow => {\r\n                    if (Array.isArray(eachDataRow.Output)) {\r\n                        outputHeaderList.map((eachHeader, headerIndex) => {\r\n                            let value = \"\"\r\n                            if (isValidData(eachDataRow.Output[headerIndex])) {\r\n                                value = eachDataRow.Output[headerIndex]\r\n                            }\r\n                            eachDataRow[eachHeader.Key] = value // for classification value\r\n                        })\r\n                    } else {\r\n                        outputHeaderList.map((eachHeader, headerIndex) => {\r\n                            let value = \"\"\r\n                            if (headerIndex === 0) {\r\n                                value = eachDataRow.Output\r\n                            }\r\n                            eachDataRow[eachHeader.Key] = value // for classification value\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n        } else {\r\n            if (isValidData(classificationNameHashmap)) {\r\n                if (hasDataList(predictionResults)) {\r\n                    predictionResults.map(eachDataRow => {\r\n                        if (Array.isArray(eachDataRow.Output)) {\r\n                            outputHeaderList.map((eachHeader, headerIndex) => {\r\n                                let value = \"\"\r\n                                if (isValidData(eachDataRow.Output[headerIndex])) {\r\n                                    value = eachDataRow.Output[headerIndex]\r\n                                }\r\n                                eachDataRow[eachHeader.Key] = value // for classification value\r\n                            })\r\n                        } else {\r\n                            outputHeaderList.map((eachHeader, headerIndex) => {\r\n                                let value = \"\"\r\n                                if (headerIndex === 0) {\r\n                                    value = eachDataRow.Output\r\n                                }\r\n                                eachDataRow[eachHeader.Key] = value // for classification value\r\n                            })\r\n                        }\r\n\r\n                        if (isValidData(classifiedDateHashmap)) {\r\n                            if (classifiedDateHashmap[eachDataRow.PredictionID]) {\r\n                                eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID]\r\n                            } else if (eachDataRow.CreatedAt) {\r\n                                eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt)\r\n                            } else {\r\n                                eachDataRow[\"ClassifiedDate\"] = \"-\"\r\n                            }\r\n                        }\r\n\r\n                    })\r\n                }\r\n            } else {\r\n                predictionResults.map(eachDataRow => {\r\n                    if (Array.isArray(eachDataRow.Output)) {\r\n                        outputHeaderList.map((eachHeader, headerIndex) => {\r\n                            let value = \"\"\r\n                            if (isValidData(eachDataRow.Output[headerIndex])) {\r\n                                value = eachDataRow.Output[headerIndex]\r\n                            }\r\n                            eachDataRow[eachHeader.Key] = value // for classification value\r\n                        })\r\n                    } else {\r\n                        outputHeaderList.map((eachHeader, headerIndex) => {\r\n                            let value = \"\"\r\n                            if (headerIndex === 0) {\r\n                                value = eachDataRow.Output\r\n                            }\r\n                            eachDataRow[eachHeader.Key] = value // for classification value\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n        }\r\n        headerList = headerList.concat(outputHeaderList)\r\n    } else {\r\n        if (hideClassificationHyperlink === true) {\r\n            let className = classificationColumnName !== \"\" ? classificationColumnName : \"Classification Name\"\r\n            headerList.push({\r\n                DisplayName: isValidData(outputNodeNameHashmap[className]) && isValidData(outputNodeNameHashmap[className].ColumnName) ? outputNodeNameHashmap[className].ColumnName : className,\r\n                Key: \"classificationID\",\r\n                NodeName: classificationColumnName !== \"\" ? classificationColumnName : \"Classification Name\",\r\n                OutputColumn: true,\r\n                MultiValueLabel: multiLabelModel,\r\n            })\r\n        } else {\r\n            let classID = \"Classification ID\"\r\n            headerList.push({\r\n                DisplayName: isValidData(outputNodeNameHashmap[classID]) && isValidData(outputNodeNameHashmap[classID].ColumnName) ? outputNodeNameHashmap[classID].ColumnName : classID,\r\n                Key: \"classificationID\",\r\n                NodeName: \"Classification ID\",\r\n                OutputColumn: true,\r\n                MultiValueLabel: multiLabelModel,\r\n            })\r\n            let className = \"Classification Name\"\r\n            headerList.push({\r\n                DisplayName: isValidData(outputNodeNameHashmap[className]) && isValidData(outputNodeNameHashmap[className].ColumnName) ? outputNodeNameHashmap[className].ColumnName : className,\r\n                Key: \"classificationName\",\r\n                NodeName: \"Classification Name\",\r\n                OutputColumn: true,\r\n                MultiValueLabel: multiLabelModel,\r\n            })\r\n        }\r\n\r\n        if (hideClassificationHyperlink === true) {\r\n            if (isValidData(classifiedDateHashmap)) {\r\n                predictionResults.map(eachDataRow => {\r\n                    if (multiLabelModel === true) {\r\n                        let classificationIDs = []\r\n                        if (hasDataList(eachDataRow.Output)) {\r\n                            classificationIDs = eachDataRow.Output\r\n                        }\r\n                        eachDataRow[\"classificationID\"] = classificationIDs\r\n                    } else {\r\n                        eachDataRow[\"classificationID\"] = getClassificationID(eachDataRow.Output)\r\n                    }\r\n\r\n                    if (classifiedDateHashmap[eachDataRow.PredictionID]) {\r\n                        eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID]\r\n                    } else if (eachDataRow.CreatedAt) {\r\n                        eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt)\r\n                    } else {\r\n                        eachDataRow[\"ClassifiedDate\"] = \"-\"\r\n                    }\r\n                })\r\n            } else {\r\n                predictionResults.map(eachDataRow => {\r\n                    if (multiLabelModel === true) {\r\n                        let classificationIDs = []\r\n                        if (hasDataList(eachDataRow.Output)) {\r\n                            classificationIDs = eachDataRow.Output\r\n                        }\r\n                        eachDataRow[\"classificationID\"] = classificationIDs\r\n                    } else {\r\n                        eachDataRow[\"classificationID\"] = getClassificationID(eachDataRow.Output)\r\n                    }\r\n                })\r\n            }\r\n        } else {\r\n            if (isValidData(classifiedDateHashmap)) {\r\n                predictionResults.map(eachDataRow => {\r\n                    if (multiLabelModel === true) {\r\n                        let classificationIDs = []\r\n                        let classificationNames = []\r\n                        if (hasDataList(eachDataRow.Output)) {\r\n                            classificationIDs = eachDataRow.Output\r\n                            classificationIDs.map(eachClassID => {\r\n                                let eachClassName = classificationNameHashmap[eachClassID]\r\n                                classificationNames.push(eachClassName)\r\n                            })\r\n                        }\r\n                        eachDataRow[\"classificationID\"] = classificationIDs\r\n                        eachDataRow[\"classificationName\"] = classificationNames\r\n                    } else {\r\n                        let classificationID = getClassificationID(eachDataRow.Output)\r\n                        let classificationName = classificationNameHashmap[classificationID]\r\n                        eachDataRow[\"classificationID\"] = classificationID\r\n                        eachDataRow[\"classificationName\"] = classificationName\r\n                    }\r\n\r\n                    if (classifiedDateHashmap[eachDataRow.PredictionID]) {\r\n                        eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID]\r\n                    } else if (eachDataRow.CreatedAt) {\r\n                        eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt)\r\n                    } else {\r\n                        eachDataRow[\"ClassifiedDate\"] = \"-\"\r\n                    }\r\n                })\r\n            } else {\r\n                predictionResults.map(eachDataRow => {\r\n                    if (multiLabelModel === true) {\r\n                        let classificationIDs = []\r\n                        let classificationNames = []\r\n                        if (hasDataList(eachDataRow.Output)) {\r\n                            classificationIDs = eachDataRow.Output\r\n                            classificationIDs.map(eachClassID => {\r\n                                let eachClassName = classificationNameHashmap[eachClassID]\r\n                                classificationNames.push(eachClassName)\r\n                            })\r\n                        }\r\n                        eachDataRow[\"classificationID\"] = classificationIDs\r\n                        eachDataRow[\"classificationName\"] = classificationNames\r\n                    } else {\r\n                        let classificationID = getClassificationID(eachDataRow.Output)\r\n                        let classificationName = classificationNameHashmap[classificationID]\r\n                        eachDataRow[\"classificationID\"] = classificationID\r\n                        eachDataRow[\"classificationName\"] = classificationName\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n        // for single class count case\r\n        if (showRelevanceValue === true) {\r\n            let displayName = \"Confidence\"\r\n            if (isValidData(outputNodeNameHashmap) && isValidData(outputNodeNameHashmap[\"Confidence\"]) && outputNodeNameHashmap[\"Confidence\"].ColumnName !== undefined) {\r\n                displayName = outputNodeNameHashmap[\"Confidence\"].ColumnName\r\n            }\r\n            let key = \"Confidence\"\r\n            if (multiLabelModel === true) {\r\n                key = \"RelevanceValueArr\"\r\n            }\r\n            headerList.push({\r\n                DisplayName: displayName,\r\n                Key: key,\r\n                NodeName: \"Confidence\",\r\n                OutputColumn: false,\r\n                Pinned: true,\r\n                MultiValueLabel: multiLabelModel\r\n            })\r\n        }\r\n    }\r\n\r\n    // console.log(\"#header list after prepared: \", headerList)\r\n    // console.log(\"#outputNodeNameHashmap: \", outputNodeNameHashmap)\r\n\r\n    return {\r\n        headerList,\r\n        predictionResults\r\n    }\r\n}\r\n\r\nexport const prepareClassificationInfoForResultsOfMultiOutputColumns = (multiLabelModel, outputColumnList, outputAndNoOfClasses = {}, hideClassificationHyperlink, headerList, outputClassList, predictionResults, classificationNameHashmap, outputNodeNameHashmap, classifiedDateHashmap, showRelevanceValue, showCompanyName) => {\r\n    // for company name\r\n    // console.log(\"#outputAndNoOfClasses: \", outputAndNoOfClasses)\r\n    if (showCompanyName === true) {\r\n        headerList.push({\r\n            DisplayName: \"Competitor Name\",\r\n            Key: \"CompanyName\",\r\n            NodeName: \"CompanyName\",\r\n            OutputColumn: false,\r\n            Pinned: true\r\n        })\r\n    }\r\n\r\n    if (hasDataList(outputClassList) && outputClassList.length > 1) {\r\n        let outputHeaderList = []\r\n        outputClassList.map((eachClassHeader, outputClassIndex) => {\r\n            outputColumnList.map(eachOutput => {\r\n                let outputCount = outputClassList.length;\r\n                if (isValidData(outputAndNoOfClasses[eachOutput])) {\r\n                    outputCount = outputAndNoOfClasses[eachOutput]\r\n                }\r\n                if (outputClassIndex < outputCount) {\r\n                    outputHeaderList.push({\r\n                        DisplayName: eachOutput + \" \" + eachClassHeader,\r\n                        NodeName: eachClassHeader,\r\n                        Key: eachOutput + \"_output\" + (outputClassIndex + 1),\r\n                        ShowToolTip: true,\r\n                        HideHyperlink: hideClassificationHyperlink,\r\n                        OutputColumn: true\r\n                    })\r\n                }\r\n            })\r\n        })\r\n\r\n        // to check and assign for reference data, for performance, checked condition outside\r\n        if (showRelevanceValue === true) {\r\n            if (isValidData(classificationNameHashmap)) {\r\n                if (hasDataList(predictionResults)) {\r\n                    predictionResults.map(eachDataRow => {\r\n                        let outputValueHashmap = eachDataRow.Output\r\n                        outputColumnList.map((eachOutput, outputIndex) => {\r\n                            let valueArr = outputValueHashmap[eachOutput]\r\n\r\n                            let relatedHeaderList = []\r\n                            outputHeaderList.map(eachHeader => {\r\n                                if (eachHeader.Key.includes(eachOutput)) {\r\n                                    relatedHeaderList.push(eachHeader)\r\n                                }\r\n                            })\r\n\r\n                            if (Array.isArray(valueArr)) {\r\n                                let relevanceValueArr = eachDataRow[eachOutput + \"_RelevanceValueArr\"]\r\n                                let originalRelevanceValueArr = eachDataRow[eachOutput + \"_RelevanceValueArr\"]\r\n                                relatedHeaderList.map((eachHeader, headerIndex) => {\r\n                                    let value = \"\"\r\n                                    if (isValidData(valueArr[headerIndex])) {\r\n                                        value = valueArr[headerIndex]\r\n                                    }\r\n                                    eachDataRow[eachHeader.Key] = value // for classification value\r\n\r\n                                    // for relevance value (output key _ relevance)\r\n                                    let eachRelevanceValue = \"\"\r\n                                    let eachRelevanceKey = eachHeader.Key + \"___relevance\"\r\n                                    if (isValidData(relevanceValueArr[headerIndex])) {\r\n                                        eachRelevanceValue = relevanceValueArr[headerIndex]\r\n                                    }\r\n                                    eachDataRow[eachRelevanceKey] = eachRelevanceValue // for relevance value\r\n\r\n                                    let eachOriginalRelevanceValue = 0\r\n                                    let eachOriginalRelevanceKey = \"original___\" + eachRelevanceKey\r\n                                    if (isValidData(originalRelevanceValueArr[headerIndex])) {\r\n                                        eachOriginalRelevanceValue = originalRelevanceValueArr[headerIndex]\r\n                                    }\r\n                                    eachDataRow[eachOriginalRelevanceKey] = eachOriginalRelevanceValue\r\n                                })\r\n                            } else {\r\n                                // for class count = 1 case\r\n                                relatedHeaderList.map((eachHeader, headerIndex) => {\r\n                                    let value = \"\"\r\n                                    if (headerIndex === 0) {\r\n                                        value = valueArr\r\n                                    }\r\n                                    eachDataRow[eachHeader.Key] = value // for classification value\r\n                                })\r\n                            }\r\n                        })\r\n\r\n\r\n                        if (isValidData(classifiedDateHashmap)) {\r\n                            if (classifiedDateHashmap[eachDataRow.PredictionID]) {\r\n                                eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID]\r\n                            } else if (eachDataRow.CreatedAt) {\r\n                                eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt)\r\n                            } else {\r\n                                eachDataRow[\"ClassifiedDate\"] = \"-\"\r\n                            }\r\n                        }\r\n                    })\r\n                }\r\n            } else {\r\n                predictionResults.map(eachDataRow => {\r\n                    let outputValueHashmap = eachDataRow.Output\r\n                    outputColumnList.map(eachOutput => {\r\n                        let outputValue = outputValueHashmap[eachOutput]\r\n                        if (Array.isArray(outputValue)) {\r\n                            outputHeaderList.map((eachHeader, headerIndex) => {\r\n                                let value = \"\"\r\n                                if (isValidData(outputValue[headerIndex])) {\r\n                                    value = outputValue[headerIndex]\r\n                                }\r\n                                eachDataRow[eachHeader.Key] = value // for classification value\r\n                            })\r\n                        } else {\r\n                            outputHeaderList.map((eachHeader, headerIndex) => {\r\n                                let value = \"\"\r\n                                if (headerIndex === 0) {\r\n                                    value = outputValue\r\n                                }\r\n                                eachDataRow[eachHeader.Key] = value // for classification value\r\n                            })\r\n                        }\r\n                    })\r\n                })\r\n            }\r\n        } else {\r\n            if (isValidData(classificationNameHashmap)) {\r\n                if (hasDataList(predictionResults)) {\r\n                    predictionResults.map(eachDataRow => {\r\n                        let outputValueHashmap = eachDataRow.Output\r\n                        outputColumnList.map(eachOutput => {\r\n                            let outputValue = outputValueHashmap[eachOutput]\r\n                            if (Array.isArray(outputValue)) {\r\n                                outputHeaderList.map((eachHeader, headerIndex) => {\r\n                                    let value = \"\"\r\n                                    if (isValidData(outputValue[headerIndex])) {\r\n                                        value = outputValue[headerIndex]\r\n                                    }\r\n                                    eachDataRow[eachHeader.Key] = value // for classification value\r\n                                })\r\n                            } else {\r\n                                outputHeaderList.map((eachHeader, headerIndex) => {\r\n                                    let value = \"\"\r\n                                    if (headerIndex === 0) {\r\n                                        value = outputValue\r\n                                    }\r\n                                    eachDataRow[eachHeader.Key] = value // for classification value\r\n                                })\r\n                            }\r\n                        })\r\n\r\n                        if (isValidData(classifiedDateHashmap)) {\r\n                            if (classifiedDateHashmap[eachDataRow.PredictionID]) {\r\n                                eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID]\r\n                            } else if (eachDataRow.CreatedAt) {\r\n                                eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt)\r\n                            } else {\r\n                                eachDataRow[\"ClassifiedDate\"] = \"-\"\r\n                            }\r\n                        }\r\n                    })\r\n                }\r\n            } else {\r\n                predictionResults.map(eachDataRow => {\r\n                    let outputValueHashmap = eachDataRow.Output\r\n                    outputColumnList.map(eachOutput => {\r\n                        let outputValue = outputValueHashmap[eachOutput]\r\n                        if (Array.isArray(outputValue)) {\r\n                            outputHeaderList.map((eachHeader, headerIndex) => {\r\n                                let value = \"\"\r\n                                if (isValidData(outputValue[headerIndex])) {\r\n                                    value = outputValue[headerIndex]\r\n                                }\r\n                                eachDataRow[eachHeader.Key] = value // for classification value\r\n                            })\r\n                        } else {\r\n                            outputHeaderList.map((eachHeader, headerIndex) => {\r\n                                let value = \"\"\r\n                                if (headerIndex === 0) {\r\n                                    value = outputValue\r\n                                }\r\n                                eachDataRow[eachHeader.Key] = value // for classification value\r\n                            })\r\n                        }\r\n                    })\r\n                })\r\n            }\r\n        }\r\n        headerList = headerList.concat(outputHeaderList)\r\n    } else {\r\n        if (hideClassificationHyperlink === true) {\r\n            outputColumnList.map(eachOutput => {\r\n                let className = eachOutput + \"_Classification Name\" // keyword\r\n                headerList.push({\r\n                    DisplayName: isValidData(outputNodeNameHashmap[className]) && isValidData(outputNodeNameHashmap[className].ColumnName) ? outputNodeNameHashmap[className].ColumnName : eachOutput,\r\n                    Key: eachOutput + \"_classificationID\",\r\n                    NodeName: className,\r\n                    OutputColumn: true,\r\n                    MultiValueLabel: multiLabelModel,\r\n                })\r\n            })\r\n        } else {\r\n            outputColumnList.map(eachOutput => {\r\n                let classID = eachOutput + \"_Classification ID\"\r\n                headerList.push({\r\n                    DisplayName: isValidData(outputNodeNameHashmap[classID]) && isValidData(outputNodeNameHashmap[classID].ColumnName) ? outputNodeNameHashmap[classID].ColumnName : eachOutput + \"_CLASS_ID\",\r\n                    Key: eachOutput + \"_classificationID\",\r\n                    NodeName: classID,\r\n                    OutputColumn: true,\r\n                    MultiValueLabel: multiLabelModel,\r\n                })\r\n                let className = eachOutput + \"_Classification Name\"\r\n                headerList.push({\r\n                    DisplayName: isValidData(outputNodeNameHashmap[className]) && isValidData(outputNodeNameHashmap[className].ColumnName) ? outputNodeNameHashmap[className].ColumnName : eachOutput + \"_ClASS_NAME\",\r\n                    Key: eachOutput + \"_classificationName\",\r\n                    NodeName: className,\r\n                    OutputColumn: true,\r\n                    MultiValueLabel: multiLabelModel,\r\n                })\r\n            })\r\n        }\r\n\r\n        if (hideClassificationHyperlink === true) {\r\n            if (isValidData(classifiedDateHashmap)) {\r\n                predictionResults.map(eachDataRow => {\r\n                    let outputHashmap = eachDataRow.Output\r\n                    outputColumnList.map(eachOutput => {\r\n                        if (multiLabelModel === true) {\r\n                            let classificationIDs = []\r\n                            if (hasDataList(outputHashmap[eachOutput])) {\r\n                                classificationIDs = outputHashmap[eachOutput]\r\n                            }\r\n                            eachDataRow[eachOutput + \"_classificationID\"] = classificationIDs\r\n                        } else {\r\n                            eachDataRow[eachOutput + \"_classificationID\"] = getClassificationID(outputHashmap[eachOutput])\r\n                        }\r\n                    })\r\n\r\n                    if (classifiedDateHashmap[eachDataRow.PredictionID]) {\r\n                        eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID]\r\n                    } else if (eachDataRow.CreatedAt) {\r\n                        eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt)\r\n                    } else {\r\n                        eachDataRow[\"ClassifiedDate\"] = \"-\"\r\n                    }\r\n                })\r\n            } else {\r\n                predictionResults.map(eachDataRow => {\r\n                    let outputHashmap = eachDataRow.Output\r\n                    outputColumnList.map(eachOutput => {\r\n                        if (multiLabelModel === true) {\r\n                            eachDataRow[eachOutput + \"_classificationID\"] = outputHashmap && hasDataList(outputHashmap[eachOutput]) ? outputHashmap[eachOutput] : []\r\n                        } else {\r\n                            eachDataRow[eachOutput + \"_classificationID\"] = getClassificationID(outputHashmap[eachOutput])\r\n                        }\r\n                    })\r\n                })\r\n            }\r\n        } else {\r\n            if (isValidData(classifiedDateHashmap)) {\r\n                predictionResults.map(eachDataRow => {\r\n                    let outputHashmap = isValidData(eachDataRow.Output) ? eachDataRow.Output : {}\r\n                    outputColumnList.map(eachOutput => {\r\n                        if (multiLabelModel === true) {\r\n                            let classificationIDs = []\r\n                            let classificationNames = []\r\n                            if (hasDataList(outputHashmap[eachOutput])) {\r\n                                classificationIDs = outputHashmap[eachOutput]\r\n                                classificationIDs.map(eachClassID => {\r\n                                    let eachClassName = classificationNameHashmap[eachClassID]\r\n                                    classificationNames.push(eachClassName)\r\n                                })\r\n                            }\r\n                            eachDataRow[eachOutput + \"_classificationID\"] = classificationIDs\r\n                            eachDataRow[eachOutput + \"_classificationName\"] = classificationNames\r\n                        } else {\r\n                            let classificationID = getClassificationID(outputHashmap[eachOutput])\r\n                            let classificationName = classificationNameHashmap[classificationID]\r\n                            eachDataRow[eachOutput + \"_classificationID\"] = classificationID\r\n                            eachDataRow[eachOutput + \"_classificationName\"] = classificationName\r\n                        }\r\n                    })\r\n\r\n                    if (classifiedDateHashmap[eachDataRow.PredictionID]) {\r\n                        eachDataRow[\"ClassifiedDate\"] = classifiedDateHashmap[eachDataRow.PredictionID]\r\n                    } else if (eachDataRow.CreatedAt) {\r\n                        eachDataRow[\"ClassifiedDate\"] = getClassifiedDate(eachDataRow.CreatedAt)\r\n                    } else {\r\n                        eachDataRow[\"ClassifiedDate\"] = \"-\"\r\n                    }\r\n                })\r\n            } else {\r\n                predictionResults.map(eachDataRow => {\r\n                    let outputHashmap = isValidData(eachDataRow.Output) ? eachDataRow.Output : {}\r\n                    outputColumnList.map(eachOutput => {\r\n                        if (multiLabelModel === true) {\r\n                            let classificationIDs = []\r\n                            let classificationNames = []\r\n                            if (hasDataList(outputHashmap[eachOutput])) {\r\n                                classificationIDs = outputHashmap[eachOutput]\r\n                                classificationIDs.map(eachClassID => {\r\n                                    let eachClassName = classificationNameHashmap[eachClassID]\r\n                                    classificationNames.push(eachClassName)\r\n                                })\r\n                            }\r\n                            eachDataRow[eachOutput + \"_classificationID\"] = classificationIDs\r\n                            eachDataRow[eachOutput + \"_classificationName\"] = classificationNames\r\n                        } else {\r\n                            let classificationID = getClassificationID(outputHashmap[eachOutput])\r\n                            let classificationName = classificationNameHashmap[classificationID]\r\n                            eachDataRow[eachOutput + \"_classificationID\"] = classificationID\r\n                            eachDataRow[eachOutput + \"_classificationName\"] = classificationName\r\n                        }\r\n                    })\r\n                })\r\n            }\r\n        }\r\n\r\n        // for single class count case\r\n        if (showRelevanceValue === true) {\r\n            outputColumnList.map(eachOutput => {\r\n                let columnKey = eachOutput + \"_Confidence\"\r\n                let displayName = eachOutput + \" Confidence\"\r\n                if (isValidData(outputNodeNameHashmap) && isValidData(outputNodeNameHashmap[columnKey]) && outputNodeNameHashmap[columnKey].ColumnName !== undefined) {\r\n                    displayName = outputNodeNameHashmap[columnKey].ColumnName\r\n                }\r\n\r\n                let key = eachOutput + \"_Confidence\"\r\n                if (multiLabelModel === true) {\r\n                    key = eachOutput + \"_RelevanceValueArr\"\r\n                }\r\n                headerList.push({\r\n                    DisplayName: displayName,\r\n                    Key: key,\r\n                    NodeName: eachOutput,\r\n                    OutputColumn: false,\r\n                    Pinned: true,\r\n                    MultiValueLabel: multiLabelModel\r\n                })\r\n            })\r\n        }\r\n    }\r\n\r\n    // console.log(\"#header list after prepared: \", headerList)\r\n    // console.log(\"#outputNodeNameHashmap: \", outputNodeNameHashmap)\r\n\r\n    return {\r\n        headerList,\r\n        predictionResults\r\n    }\r\n}\r\n\r\nexport const getClassificationID = (output) => {\r\n    let classificationID;\r\n    if (Array.isArray(output)) {\r\n        classificationID = output[0]\r\n    } else {\r\n        classificationID = output\r\n    }\r\n    return classificationID\r\n}\r\n\r\nexport const checkAndAssignDefaultValue = (value) => {\r\n    if (value !== undefined && value !== null && value !== \"\") {\r\n\r\n    } else {\r\n        value = \"-\"\r\n    }\r\n    return value\r\n}\r\n\r\nexport const prepareOverviewStatusFromAllDetailedInfos = (detailStatusInfos) => {\r\n    let foundInProgress = false\r\n    let foundSuccess = false\r\n    let foundFailed = false\r\n    detailStatusInfos.map(eachInfo => {\r\n        if (eachInfo.Status === FAIL) {\r\n            foundFailed = true\r\n        } else if (eachInfo.Status === SUCCESS) {\r\n            foundSuccess = true\r\n        } else if (eachInfo.Status === IN_PROGRESS) {\r\n            foundInProgress = true\r\n        }\r\n    })\r\n    let status = \"\"\r\n    if (foundInProgress) {\r\n        status = IN_PROGRESS\r\n    } else if (foundFailed && foundSuccess) {\r\n        status = MIX_STATUS\r\n    } else if (foundSuccess) {\r\n        status = SUCCESS\r\n    }\r\n    return status\r\n}\r\n\r\nexport const calculateDisplayFileSize = (inputFileSize) => {\r\n    let displayFileSize = inputFileSize\r\n    let kiloSize = 1024\r\n    if (displayFileSize > kiloSize) {\r\n        displayFileSize = inputFileSize / kiloSize\r\n        if (displayFileSize > kiloSize) {\r\n            displayFileSize = displayFileSize / kiloSize\r\n            if (displayFileSize > kiloSize) {\r\n                displayFileSize = (displayFileSize / kiloSize).toFixed(1) + \"GB\"\r\n            } else {\r\n                displayFileSize = displayFileSize.toFixed(1) + \"MB\"\r\n            }\r\n        } else {\r\n            displayFileSize = displayFileSize.toFixed(1) + \"KB\"\r\n        }\r\n    } else {\r\n        displayFileSize = inputFileSize + \"B\"\r\n    }\r\n    return displayFileSize\r\n}\r\n\r\nexport const convertUtcToCurrentDateAndTime = (inputUtcTime) => {\r\n    let timeStamp = new Date(inputUtcTime);\r\n    // console.log(\"original time stamp : \", timeStamp)\r\n    // Parse our locale string to [date, time]]\r\n    let localDateTimeArr = timeStamp.toLocaleString('en-US', {hour12: true}).split(\" \");\r\n    // console.log(\"new date with given format : \", localDateTimeArr)\r\n    let date = localDateTimeArr[0].split(\",\")[0];\r\n    let time = localDateTimeArr[1];\r\n    let ampm = localDateTimeArr[2]\r\n    let splitTime = time.split(\":\");\r\n    let hours = splitTime[0];\r\n    let minutes = splitTime[1];\r\n    let updateTime = hours + ':' + minutes + ' ' + ampm;\r\n    if (splitTime.length > 2) {\r\n        let seconds = splitTime[2]\r\n        updateTime = hours + ':' + minutes + \":\" + seconds + ' ' + ampm;\r\n    }\r\n    // to get for this format => 26 Jul 2023\r\n    // let dateArr = date.split(\"/\");\r\n    // let convertedDate = new Date(dateArr[2], (dateArr[0] - 1), dateArr[1]);\r\n    // let shortMonth = convertedDate.toLocaleString('default', {month: 'short'}); /* Jun */\r\n    // let updateDate = dateArr[1] + \" \" + shortMonth + \" \" + dateArr[2];\r\n    return {\r\n        Date: date,\r\n        Time: updateTime\r\n    }\r\n}\r\n\r\nexport const getFormattedPatentIDs = (patentIDs) => {\r\n    let outputPatentIDs = []\r\n    patentIDs.map(eachPatentID => {\r\n        outputPatentIDs.push(patentFormatter(eachPatentID))\r\n    })\r\n    return outputPatentIDs\r\n}\r\n\r\nexport const patentFormatter = (inputPatentID) => {\r\n    //space, hyphen, n-dash, m-dash, forward slash, backward slash, open/close parens\r\n    let replacedText = \"\"\r\n    if (inputPatentID !== undefined) {\r\n        replacedText = inputPatentID\r\n            .replaceAll(\" \", \"\")\r\n            .replaceAll(\"_\", \"\")\r\n            .replaceAll(\"-\", \"\")\r\n            .replaceAll(\"/\", \"\")\r\n            .replaceAll(\"\\\\\", \"\")\r\n            .replaceAll(\"(\", \"\")\r\n            .replaceAll(\")\", \"\")\r\n            .replaceAll(\"{\", \"\")\r\n            .replaceAll(\"}\", \"\")\r\n            .replaceAll(\"[\", \"\")\r\n            .replaceAll(\"]\", \"\")\r\n            .replaceAll(\".\", \"\")\r\n            .replaceAll(\"?\", \"\")\r\n    }\r\n    console.log(inputPatentID, \" => \", replacedText)\r\n    return replacedText\r\n}\r\n\r\nexport const getColumnWordSize = (pageNumber, pageSize) => {\r\n    let wordSize = 6\r\n    let padding = 20\r\n    if (!isValidData(pageNumber)) {\r\n        pageNumber = 1\r\n    }\r\n\r\n    return (((pageNumber * pageSize).toString()).length * wordSize) + (2 * padding)\r\n}\r\n\r\nexport const getSerialRowNumber = (pageNumber, pageSize, index) => {\r\n    if (!isValidData(pageNumber)) {\r\n        pageNumber = 1\r\n    }\r\n    return ((pageNumber - 1) * pageSize) + (index + 1)\r\n}\r\n\r\nexport const getFiledName = (fieldName) => {\r\n    if (isValidData(fieldName) && fieldName.includes(\".\")) {\r\n        fieldName = fieldName.replaceAll(\".\", \"_\")\r\n    }\r\n    return fieldName\r\n}\r\n\r\nexport const prepareColumnDefs = (columnInfoList) => {\r\n    let columnDefs = []\r\n    const patentIDWidth = 250;\r\n    const titleWidth = 250;\r\n    const abstractWidth = 300;\r\n    const descriptionWidth = 300;\r\n    const otherColumnWidth = 250;\r\n    let modifiedColumnNames = []\r\n    columnInfoList.map((eachColumn, columnIndex) => {\r\n        let filedName = getFiledName(eachColumn.ColumnName)\r\n        if (filedName !== eachColumn.ColumnName) {\r\n            modifiedColumnNames.push({\r\n                OldName: eachColumn.ColumnName,\r\n                NewName: filedName,\r\n            })\r\n        }\r\n        let colDef = {\r\n            headerName: eachColumn.ColumnName,\r\n            field: filedName,\r\n            flex: 1,\r\n            minWidth: otherColumnWidth,\r\n            wrapText: true,\r\n            sortable: true\r\n        }\r\n        if (columnIndex === 0) {\r\n            colDef.pinned = \"top\"\r\n            colDef.lockPinned = true\r\n        }\r\n        if (isValidData(eachColumn.ColumnName)) {\r\n            let columnNameLower = eachColumn.ColumnName.toLowerCase()\r\n            if (columnNameLower === \"patentid\" || columnNameLower === \"document no.\") {\r\n                colDef.minWidth = patentIDWidth\r\n            } else if (columnNameLower === \"title\") {\r\n                colDef.minWidth = titleWidth\r\n            } else if (columnNameLower === \"abstract\") {\r\n                colDef.minWidth = abstractWidth\r\n            } else if (columnNameLower === \"description\") {\r\n                colDef.minWidth = descriptionWidth\r\n            }\r\n        }\r\n\r\n        columnDefs.push(colDef)\r\n    })\r\n    console.log(\"#columnDefs: \", columnDefs)\r\n    console.log(\"#modifiedColumnNames: \", modifiedColumnNames)\r\n    return {\r\n        columnDefs,\r\n        modifiedColumnNames\r\n    }\r\n}\r\n\r\nexport const convertTableData = (modifiedInfoList, previewData) => {\r\n    if (hasDataList(previewData)) {\r\n        let prevDataStr = JSON.stringify(previewData)\r\n        modifiedInfoList.map(eachInfo => {\r\n            prevDataStr = prevDataStr.replaceAll(eachInfo.OldName, eachInfo.NewName)\r\n        })\r\n        previewData = JSON.parse(prevDataStr)\r\n    }\r\n    return previewData\r\n}\r\n\r\nexport const getOppositeColor = (color) => {\r\n    // Variables for red, green, blue values\r\n    if (!isValidData(color)) {\r\n        return \"black\"\r\n    }\r\n    let r, g, b, hsp;\r\n\r\n    // Check the format of the color, HEX or RGB?\r\n    if (color.match(/^rgb/)) {\r\n\r\n        // If RGB --> store the red, green, blue values in separate variables\r\n        color = color.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/);\r\n\r\n        r = color[1];\r\n        g = color[2];\r\n        b = color[3];\r\n    } else {\r\n        color = +(\"0x\" + color.slice(1).replace(\r\n            color.length < 5 && /./g, '$&$&'));\r\n\r\n        r = color >> 16;\r\n        g = color >> 8 & 255;\r\n        b = color & 255;\r\n    }\r\n\r\n    // HSP (Highly Sensitive Poo) equation from http://alienryderflex.com/hsp.html\r\n    hsp = Math.sqrt(\r\n        0.299 * (r * r) +\r\n        0.587 * (g * g) +\r\n        0.114 * (b * b)\r\n    );\r\n\r\n    // Using the HSP value, determine whether the color is light or dark\r\n    if (hsp > 127.5) {\r\n\r\n        //actually color type is light, so should return black color for text\r\n        return 'black';\r\n    } else {\r\n        //actually color type is dark, so should return white color for text\r\n        return 'white';\r\n    }\r\n}\r\n\r\nexport const calculateDisplayPatentSize = (inputSize) => {\r\n    let displayFileSize = inputSize\r\n    let kiloSize = 1000\r\n    if (displayFileSize > kiloSize) {\r\n        displayFileSize = inputSize / kiloSize\r\n        if (displayFileSize > kiloSize) {\r\n            displayFileSize = displayFileSize / kiloSize\r\n            if (displayFileSize > kiloSize) {\r\n                displayFileSize = (displayFileSize / kiloSize).toFixed(1) + \"GB\"\r\n            } else {\r\n                displayFileSize = displayFileSize.toFixed(1) + \"MB\"\r\n            }\r\n        } else {\r\n            displayFileSize = displayFileSize.toFixed(1) + \"KB\"\r\n        }\r\n    } else {\r\n        displayFileSize = inputSize\r\n    }\r\n    return displayFileSize\r\n}\r\n\r\nexport const getResponseMessage = (responseCode, pageType = \"\", requestID = \"\") => {\r\n    // let message = \"The process has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\" to know the exact problem.\"\r\n    let message = \"The process has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code for detailed information.\"\r\n    if (isValidData(requestID)) {\r\n        message = \"The process with the JobID \\\"\" + requestID + \"\\\" has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the JobID and response code for detailed information..\"\r\n    }\r\n    if (responseCode === 2403) {\r\n        message = \"Invalid Api Key From Header to continue the process.\"\r\n    } else if (responseCode === 2404) {\r\n        message = \"You exceeded your current quota, please check your plan and billing details.\"\r\n    } else if (responseCode === 2405) {\r\n        message = \"File data format is not valid, please check your file.\"\r\n    } else if (responseCode === 5128) {\r\n        if (pageType === \"smart_innovation\") {\r\n            message = \"Currently, GPUs are temporarily unavailable to run the novelty process. Please try again later.\"\r\n        } else {\r\n            message = \"Currently, GPU server is not available for classification process. Please try again later.\"\r\n        }\r\n    } else {\r\n        if (pageType === \"inference\") {\r\n            message = \"Classification process has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\"\r\n        } else if (pageType === \"train\") {\r\n            message = \"Model training has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\"\r\n        } else if (pageType === \"test\") {\r\n            message = \"Training testing batches has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\"\r\n        } else if (pageType === \"generate\") {\r\n            message = \"Generating model has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\"\r\n        } else if (pageType === \"model_config\") {\r\n            message = \"Model configuration has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\"\r\n        } else if (pageType === \"aqx\") {\r\n            message = \"Searching process has failed with this response code \\\"\" + responseCode + \"\\\". Please contact AnyGen support team at \\\"support@anygen.ai\\\", providing the response code to know the exact problem.\"\r\n        }\r\n    }\r\n\r\n    return message\r\n}\r\n\r\nexport const getCurrentLocalTimeForFolderName = () => {\r\n    let utcTime = getCurrentUTCDateTime()\r\n    let timeStamp = new Date(utcTime);\r\n    // Parse our locale string to [date, time]\r\n    let localDateTimeArr = timeStamp.toLocaleString('en-US', {hour12: true}).split(\" \");\r\n    let date = localDateTimeArr[0].split(\",\")[0];\r\n    // let time = localDateTimeArr[1];\r\n    // let ampm = localDateTimeArr[2]\r\n    // let splitTime = time.split(\":\");\r\n    // let hours = splitTime[0];\r\n    // let minutes = splitTime[1];\r\n    // let updateTime = hours + '-' + minutes + ampm;\r\n    // if (splitTime.length > 2) {\r\n    //     let seconds = splitTime[2]\r\n    //     updateTime = hours + '-' + minutes + \"-\" + seconds + ampm;\r\n    // }\r\n\r\n    let dateSplitArr = date.split(\"/\")\r\n    if (dateSplitArr.length > 2) {\r\n        let month = dateSplitArr[0]\r\n        let day = dateSplitArr[1]\r\n        let year = dateSplitArr[2]\r\n        date = year + \"-\" + month + \"-\" + day\r\n    }\r\n\r\n    // return date + \"_\" + updateTime\r\n    return date\r\n}\r\n\r\nexport const getCurrentLocalTime = () => {\r\n    let utcTime = getCurrentUTCDateTime()\r\n    let timeStamp = new Date(utcTime);\r\n    // Parse our locale string to [date, time]\r\n    let localDateTimeArr = timeStamp.toLocaleString('en-US', {hour12: true}).split(\" \");\r\n    let time = localDateTimeArr[1];\r\n    let ampm = localDateTimeArr[2]\r\n    let splitTime = time.split(\":\");\r\n    let hours = splitTime[0];\r\n    let minutes = splitTime[1];\r\n    let updateTime = hours + '-' + minutes + ampm;\r\n    if (splitTime.length > 2) {\r\n        let seconds = splitTime[2]\r\n        updateTime = hours + '-' + minutes + \"-\" + seconds + ampm;\r\n    }\r\n\r\n    return updateTime\r\n}\r\n\r\nexport const prepareDownloadFolderName = (modelName, predictionName, patentSearchCase) => {\r\n    //AI_Classifier_2024-01-02_1.csv\r\n    let folderName = \"AI_Classifier\"\r\n    if (patentSearchCase === true) {\r\n        folderName = \"Patent_Group\"\r\n    }\r\n    if (isValidData(modelName)) {\r\n        let splitModelNames = modelName.split(\" \")\r\n        let shortModelName = \"\"\r\n        splitModelNames.map(eachName => {\r\n            eachName = eachName.replaceAll(\" \", \"\")\r\n            if (isValidData(eachName)) {\r\n                let firstChar = eachName[0]\r\n                let regex = /^[a-zA-Z]+$/;\r\n                let isChar = regex.test(firstChar)\r\n                if (isChar) {\r\n                    let firstCharUpper = firstChar.toUpperCase()\r\n                    if (shortModelName === \"\") {\r\n                        shortModelName = firstCharUpper\r\n                    } else {\r\n                        shortModelName += firstCharUpper\r\n                    }\r\n                }\r\n            }\r\n        })\r\n        if (shortModelName !== \"\") {\r\n            folderName += \"_\" + shortModelName\r\n        }\r\n    }\r\n    if (isValidData(predictionName)) {\r\n        predictionName = predictionName.replaceAll(\" \", \"\")   // prediction based\r\n        if (predictionName !== \"\") {\r\n            folderName += \"_\" + predictionName\r\n        }\r\n    }\r\n    let localTime = getCurrentLocalTimeForFolderName()\r\n    folderName += \"_\" + localTime\r\n    return folderName\r\n}\r\n\r\nexport const calculatePercentage = (value, total) => {\r\n    let percentage = (value / total) * 100\r\n    if (parseInt(percentage.toString()) === percentage) {\r\n\r\n    } else {\r\n        percentage = percentage.toFixed(2)\r\n        if (parseFloat(percentage) <= 0) {\r\n            for (let digitCount = 3; digitCount < 10; digitCount++) {\r\n                percentage = ((value / total) * 100).toFixed(digitCount)\r\n                if (parseFloat(percentage) > 0) {\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return percentage\r\n}\r\n\r\nexport const getFixedNumber = (inputValue, minDigit, maxDigit) => {\r\n    // console.log(\"#getFixedNumber: \", inputValue, \", type: \", typeof inputValue)\r\n    let value = parseFloat(inputValue)\r\n    let fixedValue = value.toFixed(minDigit)\r\n    if (parseFloat(fixedValue) <= 0) {\r\n        for (let digitCount = 3; digitCount < maxDigit; digitCount++) {\r\n            fixedValue = value.toFixed(digitCount)\r\n            if (parseFloat(fixedValue) > 0) {\r\n                break\r\n            }\r\n        }\r\n    }\r\n    return fixedValue\r\n}\r\n\r\nexport const getClassifiedDate = (createdAt) => {\r\n    let convData = convertUtcToCurrentDateAndTime(createdAt)\r\n    let date = convData.Date\r\n    let formattedDate = date\r\n    let dateSplitArr = date.split(\"/\")\r\n    if (dateSplitArr.length > 2) {\r\n        let month = dateSplitArr[0]\r\n        let day = dateSplitArr[1]\r\n        let year = dateSplitArr[2]\r\n        if (parseInt(month) < 10) {\r\n            month = \"0\" + month\r\n        }\r\n        if (parseInt(day) < 10) {\r\n            day = \"0\" + day\r\n        }\r\n        formattedDate = year + \"-\" + month + \"-\" + day\r\n    }\r\n    return formattedDate\r\n}\r\n\r\nexport const getMaxNumberOfArray = (numbers) => {\r\n    // Math.max(...numbers)\r\n    // Math.max.apply(null, numbers)\r\n    // numbers.sort(numbers.length-1)\r\n    // with for loop\r\n    // reduce logic is the best when handled for multiple items in an array\r\n    return numbers.reduce((accumulator, currentValue) => {\r\n        return Math.max(accumulator, currentValue);\r\n    }, numbers[0])\r\n}\r\n\r\nexport const getAboveThresholdCount = (rowData, threshold) => {\r\n    //let new_arr_1 = data.reduce((a, b) => a.concat(([1,3,5].includes(b.id) ? b.value: [])), []);\r\n    let newRowDataArr = rowData.reduce((newArr, eachData) => newArr.concat(eachData[\"OriginalRelevanceValue\"] < threshold ? eachData : []), []);\r\n    return newRowDataArr.length\r\n}\r\n\r\nexport const getRoleBasedInfo = () => {\r\n    let role = \"user\"\r\n    let superAdminID = \"\"\r\n    let adminID = \"\"\r\n    if (isSuperAdmin === true) {\r\n        role = \"super_admin\"\r\n    } else if (isAdminUser === true) {\r\n        role = \"admin\"\r\n        superAdminID = userInfo.CreatedBy\r\n    } else {\r\n        adminID = isValidData(userInfo.AssignedBy) ? userInfo.AssignedBy : userInfo.CreatedBy\r\n    }\r\n    return {\r\n        role,\r\n        superAdminID,\r\n        adminID,\r\n    }\r\n}\r\n\r\nexport const getCheckValidateHeaderColumnForReinforce = (inputColumnList, requiredColumns) => {\r\n    console.log(\"getCheckValidateHeaderColumn - inputColumnList: \", inputColumnList)\r\n    let successHeader = false\r\n    let ColumnInfo = []\r\n    let sameInitialCount = false\r\n    let ColumnInfoForOutputColumn = []\r\n    if (inputColumnList.length === 1) {\r\n\r\n    } else {\r\n        inputColumnList.map(eachColumn => {\r\n            if (eachColumn[\"PossibleDataType\"].includes(\"string\")) {\r\n                eachColumn.Name = eachColumn.ColumnName\r\n                ColumnInfo.push(eachColumn)\r\n                ColumnInfoForOutputColumn.push(eachColumn)\r\n            } else if (eachColumn[\"PossibleDataType\"].includes(\"int\")) {\r\n                eachColumn.Name = eachColumn.ColumnName\r\n                ColumnInfoForOutputColumn.push(eachColumn)\r\n            }\r\n        })\r\n\r\n        if (inputColumnList.length >= requiredColumns.length) {\r\n            sameInitialCount = true\r\n        }\r\n    }\r\n\r\n    let checkCountSuccess = false\r\n    if (isValidData(ColumnInfo)) {\r\n        if (sameInitialCount === true) {\r\n            checkCountSuccess = true\r\n        } else {\r\n            console.log(\"count is not same : \", ColumnInfo.length, \", \", requiredColumns.length)\r\n        }\r\n    }\r\n    if (checkCountSuccess) {\r\n        successHeader = checkCountSuccess\r\n    }\r\n    console.log(\"checking file validation : \", checkCountSuccess)\r\n    return {\r\n        ColumnInfo,\r\n        successHeader,\r\n        checkCountSuccess,\r\n        columnList: ColumnInfo,\r\n        ColumnInfoForOutputColumn: ColumnInfoForOutputColumn\r\n    }\r\n}\r\n\r\nexport const checkReinforceColumnMappingsInfo = (requiredColumnMappings, ColumnInfo, validColumnInfoListForOutputColumn, usedColumnHashmap) => {\r\n    console.log(\"#checkReinforceColumnMappingsInfo: \", requiredColumnMappings, \", \", ColumnInfo, \", \", usedColumnHashmap)\r\n    let mappableColumnsCount = 0\r\n    let availableColumnList = []\r\n    ColumnInfo.map(eachColumn => {\r\n        availableColumnList.push(eachColumn.ColumnName)\r\n    })\r\n\r\n    let availableOutputColumns = []\r\n    validColumnInfoListForOutputColumn.map(eachColumn => {\r\n        availableOutputColumns.push(eachColumn.ColumnName)\r\n    })\r\n    requiredColumnMappings.map(eachColumn => {\r\n        if (!isValidData(eachColumn.MappedColumnName)) {\r\n            let mappedColumnName = \"\"\r\n            if (eachColumn.OutputColumn === true) {\r\n                // mappedColumnName = checkAndGetForAvailableColumnName(eachColumn.Name, availableOutputColumns, usedColumnHashmap)\r\n            } else {\r\n                // mappedColumnName = checkAndGetForAvailableColumnName(eachColumn.Name, availableColumnList, usedColumnHashmap)\r\n            }\r\n            if (usedColumnHashmap[mappedColumnName] !== undefined) {\r\n                usedColumnHashmap[mappedColumnName]++\r\n            } else {\r\n                usedColumnHashmap[mappedColumnName] = 1\r\n            }\r\n            eachColumn.MappedColumnName = mappedColumnName\r\n            let nameLower = eachColumn.Name.toLowerCase()\r\n            let mappedNameLower = eachColumn.MappedColumnName.toLowerCase()\r\n            if (nameLower === mappedNameLower) {\r\n                mappableColumnsCount++\r\n            } else if ((nameLower === \"patentID\" || nameLower === \"document no.\") && (mappedNameLower === \"patentID\" || mappedNameLower === \"document no.\")) {\r\n                mappableColumnsCount++\r\n            }\r\n        }\r\n    })\r\n    let skipHeaderCheck = false\r\n    if (mappableColumnsCount > 0) {\r\n        skipHeaderCheck = true\r\n    }\r\n    let skipColumnMapping = false\r\n    if (mappableColumnsCount === requiredColumnMappings.length) {\r\n        skipColumnMapping = true\r\n    }\r\n    return {\r\n        skipHeaderCheck,\r\n        skipColumnMapping,\r\n        requiredColumnMappings,\r\n        usedColumnHashmap\r\n    }\r\n}\r\n\r\nexport const getDefaultClassBasedMetrics = () => {\r\n    return [\r\n        {\r\n            \"Name\": \"TruePositive\",\r\n            \"DisplayName\": \"True Positive (TP)\",\r\n            \"DataType\": \"int\",\r\n            \"Description\": \"The number of instances that are actually positive and are correctly predicted as positive by the model.\"\r\n        },\r\n        {\r\n            \"Name\": \"FalsePositive\",\r\n            \"DisplayName\": \"False Positive (FP)\",\r\n            \"DataType\": \"int\",\r\n            \"Description\": \"The number of instances that are actually negative but are incorrectly predicted as positive by the model.\"\r\n        },\r\n        {\r\n            \"Name\": \"TrueNegative\",\r\n            \"DisplayName\": \"True Negative (TN)\",\r\n            \"DataType\": \"int\",\r\n            \"Description\": \"The number of instances that are actually negative and are correctly predicted as negative by the model.\"\r\n        },\r\n        {\r\n            \"Name\": \"FalseNegative\",\r\n            \"DisplayName\": \"False Negative (FN)\",\r\n            \"DataType\": \"int\",\r\n            \"Description\": \"The number of instances that are actually positive but are incorrectly predicted as negative by the model.\"\r\n        },\r\n        {\r\n            \"Name\": \"TrueNegativeRate\",\r\n            \"DisplayName\": \"True Negative Rate (TNR)\",\r\n            \"DataType\": \"float\",\r\n            \"Description\": \"The true negative rate (also called specificity), which is the probability that an actual negative will test negative. It is calculated as TN/TN+FP.\"\r\n        },\r\n        {\r\n            \"Name\": \"FalsePositiveRate\",\r\n            \"DisplayName\": \"False Positive Rate (FPR)\",\r\n            \"DataType\": \"float\",\r\n            \"Description\": \"The false positive rate is calculated as the ratio between the number of negative events wrongly categorized as positive (false positives) and the total number of actual negative events (regardless of classification).\"\r\n        },\r\n        {\r\n            \"Name\": \"Precision\",\r\n            \"DisplayName\": \"Precision\",\r\n            \"DataType\": \"float\",\r\n            \"Description\": \"Precision is the ratio of true positives to the total number of predicted positives (true positives plus false positives). Precision gives an indication of how many of the predicted positive instances are actually positive. It is a measure of the model's accuracy when it predicts positive outcomes.\"\r\n        },\r\n        {\r\n            \"Name\": \"Recall\",\r\n            \"DisplayName\": \"Recall\",\r\n            \"DataType\": \"float\",\r\n            \"Description\": \"Recall is the ratio of true positives to the total number of actual positives (true positives plus false negatives). Recall measures the ability of the model to capture all the positive instances. It's a measure of the model's sensitivity to positive instances.\"\r\n        },\r\n        {\r\n            \"Name\": \"F1score\",\r\n            \"DisplayName\": \"F1Score\",\r\n            \"DataType\": \"float\",\r\n            \"Description\": \"The F1 score is the harmonic mean of precision and recall. It provides a balance between precision and recall.\"\r\n        },\r\n        {\r\n            \"Name\": \"Accuracy\",\r\n            \"DisplayName\": \"Accuracy\",\r\n            \"DataType\": \"float\",\r\n            \"Description\": \"Accuracy is the ratio of correct predictions out of all predictions made by an algorithm. It can be calculated by dividing precision by recall or as 1 minus false negative rate (FNR) divided by false positive rate (FPR).\"\r\n        }\r\n    ]\r\n}\r\n\r\nexport const formatDate = (date) => {\r\n    let dd = date.getDate();\r\n    let mm = date.getMonth() + 1;\r\n    let yyyy = date.getFullYear();\r\n    if (dd < 10) {\r\n        dd = '0' + dd\r\n    }\r\n    if (mm < 10) {\r\n        mm = '0' + mm\r\n    }\r\n    date = yyyy + \"-\" + mm + \"-\" + dd\r\n    return date\r\n}\r\n\r\nexport const getPreviousNthDate = (nthDay) => {\r\n    let d = new Date();\r\n    d.setDate(d.getDate() - nthDay);\r\n    let date = formatDate(d)\r\n    console.log(\"formatted date: \", date)\r\n    return date\r\n}\r\n\r\nexport const getDisplayDateInfoFromDatePicker = (inputDate) => {\r\n    console.log(\"getDisplayDateInfoFromDatePicker: \", inputDate)\r\n    let dateValue = \"\"\r\n    let displayValue = \"\"\r\n    if (inputDate) {\r\n        dateValue = inputDate.format(\"YYYY-MM-DD\")\r\n        displayValue = inputDate.format(\"MMM DD, YYYY\")\r\n    }\r\n    return {\r\n        dateValue,\r\n        displayValue\r\n    }\r\n}\r\n\r\nexport const getActualModelName = (inputModelName) => {\r\n    let outputModelName = \"\"\r\n    if (inputModelName) {\r\n        outputModelName = inputModelName\r\n        let splitArr = inputModelName.split(\"_\")\r\n        if (splitArr.length > 2) {\r\n            let lastValue = splitArr[splitArr.length - 1]\r\n            let secondLast = splitArr[splitArr.length - 2]\r\n            if (lastValue.includes(\"V\") && secondLast.includes(\"-\") && secondLast.split(\"-\").length === 3) {\r\n                // version and date is included\r\n                outputModelName = splitArr[0]\r\n                for (let index = 1; index < splitArr.length - 2; index++) {\r\n                    outputModelName += \"_\" + splitArr[index]\r\n                }\r\n            }\r\n        }\r\n    }\r\n    console.log(\"#output model name: \", outputModelName, \" ==> from : \", inputModelName)\r\n    return outputModelName\r\n}\r\n\r\nexport const openUrl = (urlLink) => {\r\n    window.open(urlLink, '_blank');\r\n}\r\n\r\nexport const foundSearchValue = (inputName, searchValue) => {\r\n    let inputNameLower = inputName.toLowerCase();\r\n    let searchValueLower = searchValue.toLowerCase();\r\n    let found = false\r\n    if (inputNameLower.includes(searchValueLower)) {\r\n        found = true\r\n    }\r\n    return found\r\n}\r\n\r\nexport const checkLightOrDark = (color) => {\r\n    // Variables for red, green, blue values\r\n    let r, g, b, hsp;\r\n\r\n    // Check the format of the color, HEX or RGB?\r\n    if (isValidData(color)) {\r\n        if (color.match(/^rgb/)) {\r\n\r\n            // If RGB --> store the red, green, blue values in separate variables\r\n            color = color.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/);\r\n            r = color[1];\r\n            g = color[2];\r\n            b = color[3];\r\n        } else {\r\n            color = +(\"0x\" + color.slice(1).replace(\r\n                color.length < 5 && /./g, '$&$&'));\r\n            r = color >> 16;\r\n            g = color >> 8 & 255;\r\n            b = color & 255;\r\n        }\r\n\r\n        hsp = Math.sqrt(\r\n            0.299 * (r * r) +\r\n            0.587 * (g * g) +\r\n            0.114 * (b * b)\r\n        );\r\n        // Using the HSP value, determine whether the color is light or dark\r\n        if (hsp > 127.5) {\r\n            return 'light';\r\n        } else {\r\n            return 'dark';\r\n        }\r\n    } else {\r\n        return 'dark';\r\n    }\r\n}\r\n\r\nexport const getTextColor = (color) => {\r\n    let colorType = checkLightOrDark(color)\r\n    if (colorType === \"light\") {\r\n        // return \"var(--primary-color)\"\r\n        return \"#000000\"\r\n    } else {\r\n        return \"#FFFFFF\"\r\n    }\r\n}\r\n\r\nexport const prepareBooleanAndSqlQueryInfo = (inputQuery) => {\r\n    console.log(\"prepare query info: \", inputQuery)\r\n    // SELECT , FROM , WHERE, JOIN, AND , OR\r\n    // ON\r\n    let startKeywords = [\"SELECT\", \"FROM\", \"WHERE\", \"JOIN\", \"AND\", \"OR\"]\r\n    let innerKeywords = [\"ON\"]\r\n\r\n    let sqlQueryInfo = []\r\n    let booleanQueryInfo = []\r\n    let startCondition = false\r\n    if (inputQuery) {\r\n        let spaceSplitArr = inputQuery.split(\" \")\r\n        let clauseName = \"\"\r\n        let clauseList = []\r\n        let eachClauseValue = \"\"\r\n        spaceSplitArr.map((eachWord, index) => {\r\n            if (startKeywords.includes(eachWord)) {\r\n                if (clauseName !== \"\" && (clauseList.length > 0 || eachClauseValue !== \"\")) {\r\n                    if (eachClauseValue !== \"\") {\r\n                        clauseList.push({\r\n                            Type: \"Text\",\r\n                            Value: eachClauseValue\r\n                        })\r\n                    }\r\n                    sqlQueryInfo.push({\r\n                        ClauseName: clauseName,\r\n                        Clause: clauseList\r\n                    })\r\n\r\n                    if (startCondition === true) {\r\n                        let boolClause = \"\"\r\n                        clauseList.map((eachInfo, infoIndex) => {\r\n                            if (infoIndex === 0) {\r\n                                boolClause = eachInfo.Value\r\n                            } else {\r\n                                boolClause += \" \" + eachInfo.Value\r\n                            }\r\n                        })\r\n                        booleanQueryInfo.push({\r\n                            ClauseName: booleanQueryInfo.length === 0 ? \"\" : clauseName,\r\n                            ClauseValue: boolClause\r\n                        })\r\n                    }\r\n\r\n                    clauseName = \"\"\r\n                    clauseList = []\r\n                    eachClauseValue = \"\"\r\n                }\r\n                // start row case\r\n                clauseName = eachWord\r\n\r\n                if (eachWord === \"WHERE\" || eachWord === \"JOIN\") {\r\n                    startCondition = true\r\n                }\r\n            } else {\r\n                // skip the word\r\n                // check if the keyword is inner keyword or not\r\n                if (clauseName !== \"\") {\r\n                    if (innerKeywords.includes(eachWord)) {\r\n                        if (eachClauseValue !== \"\") {\r\n                            clauseList.push({\r\n                                Type: \"Text\",\r\n                                Value: eachClauseValue\r\n                            })\r\n                            eachClauseValue = \"\"\r\n                        }\r\n                        clauseList.push({\r\n                            Type: \"ClauseName\",\r\n                            Value: eachWord\r\n                        })\r\n                    } else {\r\n                        if (eachClauseValue === \"\") {\r\n                            eachClauseValue = eachWord\r\n                        } else {\r\n                            eachClauseValue += \" \" + eachWord\r\n                        }\r\n                    }\r\n                } else {\r\n                    // clause empty case\r\n                    console.log(\"empty clause case, so skip word: \", eachWord)\r\n                }\r\n            }\r\n            if (index === spaceSplitArr.length - 1) { // last index case\r\n                if (clauseName !== \"\" && (clauseList.length > 0 || eachClauseValue !== \"\")) {\r\n                    if (eachClauseValue !== \"\") {\r\n                        clauseList.push({\r\n                            Type: \"Text\",\r\n                            Value: eachClauseValue\r\n                        })\r\n                    }\r\n                    sqlQueryInfo.push({\r\n                        ClauseName: clauseName,\r\n                        Clause: clauseList\r\n                    })\r\n\r\n                    // for boolean query\r\n                    if (startCondition === true) {\r\n                        let boolClause = \"\"\r\n                        clauseList.map((eachInfo, infoIndex) => {\r\n                            if (infoIndex === 0) {\r\n                                boolClause = eachInfo.Value\r\n                            } else {\r\n                                boolClause += \" \" + eachInfo.Value\r\n                            }\r\n                        })\r\n                        booleanQueryInfo.push({\r\n                            ClauseName: booleanQueryInfo.length === 0 ? \"\" : clauseName,\r\n                            ClauseValue: boolClause\r\n                        })\r\n                    }\r\n\r\n                    // empty data\r\n                    clauseName = \"\"\r\n                    clauseList = []\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    return {\r\n        sqlQueryInfo,\r\n        booleanQueryInfo\r\n    }\r\n}\r\n\r\nexport const getDescriptionForModuleName = (inputModuleName) => {\r\n    const descriptionHashmap = {\r\n        \"Agreement\": \"Legal contracts or agreements related to intellectual property, such as licensing agreements, assignment agreements, or nondisclosure agreements.\",\r\n        \"Billing\": \"Financial transactions related to intellectual property services, such as billing clients for legal services related to IP matters or paying fees for filing patents or trademarks.\",\r\n        \"Brand\": \"The identity or image of a product, service, or organization, including trademarks, logos, slogans, and other elements used to differentiate it from competitors\",\r\n        \"Contact\": \"Individuals or entities with whom an organization interacts regarding intellectual property matters, such as clients, inventors, attorneys, or representatives from government agencies.\",\r\n        \"Conflict\": \"Individuals or entities with whom an organization interacts regarding intellectual property matters, such as clients, inventors, attorneys, or representatives from government agencies.Disputes or conflicts that may arise regarding intellectual property rights, such as infringement claims, opposition proceedings, or disputes over ownership of IP assets.\",\r\n        \"Design\": \"The visual appearance or ornamental aspects of a product, including shape, configuration, pattern, or ornamentation, eligible for design protection\",\r\n        \"Design Application\": \"A formal request submitted to a patent office to seek protection for a design, typically in the form of a design patent or registration.\",\r\n        \"Invention\": \"A new and useful process, machine, composition of matter, or improvement thereof, eligible for patent protection.\",\r\n    }\r\n    let descriptionValue = \"\"\r\n    if (descriptionHashmap[inputModuleName] !== undefined) {\r\n        descriptionValue = descriptionHashmap[inputModuleName]\r\n    }\r\n    return descriptionValue\r\n}\r\n\r\nexport const getModulesForNestedFilterConditions = (moduleNames, filterConditions) => {\r\n    filterConditions.map(eachCondition => {\r\n        if (eachCondition.Type === \"field\") {\r\n            if (eachCondition.FilterValueInfo.ModuleName) {\r\n                if (!moduleNames.includes(eachCondition.FilterValueInfo.ModuleName)) {\r\n                    moduleNames.push(eachCondition.FilterValueInfo.ModuleName)\r\n                }\r\n            }\r\n        } else {\r\n            if (eachCondition.NestedFilterConditions) {\r\n                moduleNames = getModulesForNestedFilterConditions(moduleNames, eachCondition.NestedFilterConditions)\r\n            }\r\n        }\r\n    })\r\n    return moduleNames\r\n}\r\n\r\nexport const getSameValuePatents = () => {\r\n    let allRows = [\r\n        {\r\n            \"DocumentNo\": \"US10409988B2\",\r\n            \"Actual\": \"a065Y00001vvjfk\",\r\n            \"Predict\": \"a065Y00001vvjfk\"\r\n        }\r\n    ]\r\n    let newRows = []\r\n    let documentMap = {}\r\n    allRows.map(eachRow => {\r\n        if (eachRow.Actual === eachRow.Predict) {\r\n            newRows.push({\r\n                DocumentNo: eachRow.DocumentNo,\r\n                Actual: eachRow.Actual,\r\n                Predict: eachRow.Predict,\r\n            })\r\n            documentMap[eachRow.DocumentNo] = true\r\n        }\r\n    })\r\n    // console.log(\"all patents rows \", allRows.length)\r\n    // console.log(\"same patents rows: \", newRows.length, \" => \", newRows)\r\n    return newRows\r\n}\r\n\r\nexport const getNotIncludePatents = (inputSamePatents) => {\r\n    let allPredictRows = [\r\n        {\r\n            \"DocumentNo\": \"DE102022108867A1\",\r\n            \"Actual\": \"a065Y000023bc9c\",\r\n            \"Predict\": \"a065Y000023bc9c\"\r\n        }\r\n    ]\r\n    let foundHashmap = {}\r\n    allPredictRows.map(eachRow => {\r\n        foundHashmap[eachRow.DocumentNo] = true\r\n    })\r\n    // console.log(\"all fixed Rows: \", allPredictRows.length)\r\n    // console.log(\"fix hashmap: \", foundHashmap)\r\n\r\n    let notIncludeRows = []\r\n    inputSamePatents.map(eachRow => {\r\n        if (foundHashmap[eachRow.DocumentNo] === undefined) {\r\n            notIncludeRows.push(eachRow)\r\n        }\r\n    })\r\n    return notIncludeRows\r\n}\r\n\r\nexport const getDefaultDraftOutlineList = () => {\r\n    return [\r\n        {\r\n            Name: \"Title\",\r\n            Key: \"Title\",\r\n        },\r\n        {\r\n            Name: \"Abstract\",\r\n            Key: \"Abstract\",\r\n        },\r\n        {\r\n            Name: \"Description\",\r\n            Key: \"Description\",\r\n            isExpand: true,\r\n            Children: [\r\n                {\r\n                    Name: \"Technical Field\",\r\n                    Key: \"TechnicalField\",\r\n                },\r\n                {\r\n                    Name: \"Background\",\r\n                    Key: \"Background\",\r\n                },\r\n                {\r\n                    Name: \"Disclosure of the Invention\",\r\n                    Key: \"InventionDisclosure\"\r\n                },\r\n                {\r\n                    Name: \"Novelty Statement\",\r\n                    Key: \"NoveltyStatement\",\r\n                },\r\n                {\r\n                    Name: \"Summary\",\r\n                    Key: \"Summary\",\r\n                },\r\n            ]\r\n        },\r\n        {\r\n            Name: \"Claims\",\r\n            Key: \"Claims\"\r\n        },\r\n        {\r\n            Name: \"Citations\",\r\n            Key: \"Citations\",\r\n        },\r\n    ]\r\n}\r\n\r\nexport const prepareDraftSectionOutlines = (draftSections) => {\r\n    let outlineList = getDefaultDraftOutlineList()\r\n    let newOutlineList = []\r\n    outlineList.map(eachOutline => {\r\n        let outlineKey = eachOutline.Key\r\n        if (eachOutline.Children) {\r\n            let foundChildList = []\r\n            eachOutline.Children.map(eachChild => {\r\n                if (draftSections.includes(eachChild.Key)) {\r\n                    foundChildList.push(eachChild)\r\n                }\r\n            })\r\n            if (foundChildList.length > 0) {\r\n                newOutlineList.push({\r\n                    Name: eachOutline.Name,\r\n                    Key: eachOutline.Key,\r\n                    Children: foundChildList,\r\n                    isExpand: eachOutline.isExpand\r\n                })\r\n            } else {\r\n                if (draftSections.includes(outlineKey)) {\r\n                    newOutlineList.push({\r\n                        Name: eachOutline.Name,\r\n                        Key: eachOutline.Key,\r\n                        Children: [],\r\n                        isExpand: eachOutline.isExpand\r\n                    })\r\n                }\r\n            }\r\n        } else {\r\n            if (draftSections.includes(outlineKey)) {\r\n                newOutlineList.push(eachOutline)\r\n            }\r\n        }\r\n    })\r\n    console.log(\"#drafted outline list: \", newOutlineList)\r\n    return newOutlineList\r\n}\r\n\r\nexport const prepareRemainingDraftSections = (draftSections) => {\r\n    let outlineList = getDefaultDraftOutlineList()\r\n    let newOutlineList = []\r\n    outlineList.map(eachOutline => {\r\n        let outlineKey = eachOutline.Key\r\n        if (eachOutline.Children) {\r\n            let foundChildList = []\r\n            eachOutline.Children.map(eachChild => {\r\n                if (!draftSections.includes(eachChild.Key)) {\r\n                    foundChildList.push(eachChild)\r\n                }\r\n            })\r\n            if (foundChildList.length > 0) {\r\n                newOutlineList.push({\r\n                    Name: eachOutline.Name,\r\n                    Key: eachOutline.Key,\r\n                    Children: foundChildList\r\n                })\r\n            } else {\r\n                if (!draftSections.includes(outlineKey)) {\r\n                    newOutlineList.push({\r\n                        Name: eachOutline.Name,\r\n                        Key: eachOutline.Key,\r\n                        Children: []\r\n                    })\r\n                }\r\n            }\r\n        } else {\r\n            if (!draftSections.includes(outlineKey)) {\r\n                newOutlineList.push(eachOutline)\r\n            }\r\n        }\r\n    })\r\n    console.log(\"#remaining outline list: \", newOutlineList)\r\n    return newOutlineList\r\n}\r\n\r\nexport const getDisplayStatus = (inputStatus) => {\r\n    const statusMap = {\r\n        \"to_be_filed\": \"To Be Filed\",\r\n        \"filed\": \"Filed\",\r\n        \"not_filed\": \"Not Filed\",\r\n        \"granted\": \"Granted\",\r\n    }\r\n    let displayStatus = \"\"\r\n    if (isValidData(statusMap[inputStatus])) {\r\n        displayStatus = statusMap[inputStatus]\r\n    }\r\n    return displayStatus\r\n}\r\n\r\nexport const changeAndUpdateSectionSelection = (sectionList, keyword, value) => {\r\n    let selectedCount = 0\r\n    sectionList.map(eachSection => {\r\n        eachSection[keyword] = value\r\n        if (hasDataList(eachSection.Children)) {\r\n            eachSection.Children.map(eachInfo => {\r\n                eachInfo[keyword] = value\r\n                if (value === true) {\r\n                    selectedCount++\r\n                }\r\n            })\r\n            if (value === true) {\r\n                selectedCount++\r\n            }\r\n        } else {\r\n            if (value === true) {\r\n                selectedCount++\r\n            }\r\n        }\r\n    })\r\n    return {\r\n        sectionList,\r\n        selectedCount\r\n    }\r\n}\r\n\r\nexport const getSelectedDraftedSections = (inventionSectionList) => {\r\n    let sections = []\r\n    inventionSectionList.map(eachInfo => {\r\n        if (hasDataList(eachInfo.Children)) {\r\n            eachInfo.Children.map(eachChild => {\r\n                if (eachChild.isSelected === true) {\r\n                    if (eachChild.Value) {\r\n                        sections.push(eachChild.Value)\r\n                    } else {\r\n                        sections.push(eachChild.Key)\r\n                    }\r\n                }\r\n            })\r\n            if (eachInfo.isSelected === true) {\r\n                if (eachInfo.Value) {\r\n                    sections.push(eachInfo.Value)\r\n                } else {\r\n                    sections.push(eachInfo.Key)\r\n                }\r\n            }\r\n        } else {\r\n            if (eachInfo.isSelected === true) {\r\n                if (eachInfo.Value) {\r\n                    sections.push(eachInfo.Value)\r\n                } else {\r\n                    sections.push(eachInfo.Key)\r\n                }\r\n            }\r\n        }\r\n    })\r\n    console.log(\"#returned sections: \", sections)\r\n    return sections\r\n}\r\n\r\nexport const concatInventionData = (invention) => {\r\n    let textData = \"\"\r\n    if (invention.InventionDescription) {\r\n        textData = invention.InventionDescription\r\n    }\r\n    if (invention.ProblemSolved) {\r\n        textData += \"\\n\" + invention.ProblemSolved\r\n    }\r\n    if (invention.NoveltyAndNonObviousness) {\r\n        textData += \"\\n\" + invention.NoveltyAndNonObviousness\r\n    }\r\n    if (invention.PriorArts) {\r\n        textData += \"\\n\" + invention.PriorArts\r\n    }\r\n    if (invention.CommercializationPotential) {\r\n        textData += \"\\n\" + invention.CommercializationPotential\r\n    }\r\n    return textData\r\n}\r\n\r\nexport const getLastIndexByGivenName = (itemList, filedName, defaultVariableName) => {\r\n    let lastIndex = 0\r\n    itemList.map(eachItem => {\r\n        let splitArr = [];\r\n        if (isValidData(filedName)) {\r\n            if (isValidData(eachItem[filedName])) {\r\n                splitArr = eachItem[filedName].split(defaultVariableName)\r\n            }\r\n        } else {\r\n            if (isValidData(eachItem)) {\r\n                splitArr = eachItem.split(defaultVariableName)\r\n            }\r\n        }\r\n\r\n        if (splitArr.length === 2 && splitArr[0] === \"\") {\r\n            let variableIndexStr = splitArr[1]\r\n            if (!variableIndexStr.includes(\".\")) {\r\n                if (Number.parseInt(variableIndexStr).toString() === variableIndexStr) {\r\n                    let currentIndex = parseInt(variableIndexStr)\r\n                    if (currentIndex > lastIndex) {\r\n                        lastIndex = currentIndex\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    })\r\n    return lastIndex\r\n}\r\n\r\nexport const checkClaimTitle = (value) => {\r\n    let isTitle = false\r\n    if (isValidData(value)) {\r\n        let valueLower = value.toLowerCase()\r\n        if (valueLower.includes(\"independent claim\") || valueLower.includes(\"dependent claim\")) {\r\n            isTitle = true\r\n        }\r\n    }\r\n    return isTitle\r\n}\r\n\r\nconst splitDataArrBySubStr = (textArr, subStr) => {\r\n    // console.log(\"input text arr => \", textArr)\r\n    // console.log(\"input sub str => \", subStr)\r\n    let splitDataArr = []\r\n    textArr.map(eachText => {\r\n        if (eachText.includes(subStr)) {\r\n            let splitArr = eachText.split(subStr)\r\n            if (splitArr.length === 2) {\r\n                if (splitArr[0] === \"\") {\r\n                    splitDataArr = splitDataArr.concat(subStr)\r\n                    splitDataArr = splitDataArr.concat(splitArr[1])\r\n                } else if (splitArr[1] === \"\") {\r\n                    splitDataArr = splitDataArr.concat(splitArr[0])\r\n                    splitDataArr = splitDataArr.concat(subStr)\r\n                } else {\r\n                    splitDataArr = splitDataArr.concat(splitArr[0])\r\n                    splitDataArr = splitDataArr.concat(subStr)\r\n                    splitDataArr = splitDataArr.concat(splitArr[1])\r\n                }\r\n            } else {\r\n                splitArr.map((eachSplitStr, index) => {\r\n                    if (splitArr[0] === \"\") {\r\n                        //first one is empty\r\n                        if (eachSplitStr !== \"\") {\r\n                            if (index !== 0) {\r\n                                splitDataArr = splitDataArr.concat(subStr)\r\n                            }\r\n                            splitDataArr = splitDataArr.concat(eachSplitStr)\r\n                        }\r\n                    } else if (splitArr[splitArr.length - 1] === \"\") {\r\n                        if (eachSplitStr !== \"\") {\r\n                            splitDataArr = splitDataArr.concat(eachSplitStr)\r\n                            if (index !== splitArr.length - 1) {\r\n                                splitDataArr = splitDataArr.concat(subStr)\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (eachSplitStr !== \"\") {\r\n                            splitDataArr = splitDataArr.concat(eachSplitStr)\r\n                            if (index !== splitArr.length - 1) {\r\n                                splitDataArr = splitDataArr.concat(subStr)\r\n                            }\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n        } else {\r\n            splitDataArr = splitDataArr.concat(eachText)\r\n            // console.log(\"not include case\")\r\n        }\r\n    })\r\n    return splitDataArr\r\n}\r\n\r\nexport const convertSentimentDataToStrArr = (textInput, sentimentTextArr) => {\r\n    let convertedStrArr = [textInput]\r\n    sentimentTextArr.map(eachText => {\r\n        convertedStrArr = splitDataArrBySubStr(JSON.parse(JSON.stringify(convertedStrArr)), eachText)\r\n    })\r\n    return convertedStrArr\r\n}\r\n\r\nexport const getDefaultColor = () => {\r\n    let colorList = [\r\n        'rgba(183,236,6,0.8)', \"#F8A690\", \"#7C6FEE\", \"#76A1D5\",\r\n        \"#4BCEBC\", '#eb4039', \"#eb8f39\", \"#d6eb39\",\r\n        \"#34eba9\", \"#5a356b\", \"#349fe9\", \"#9342f9\",\r\n        \"#66664D\", \"#a8328b\", \"#4632a8\", \"#FF99E6\"]\r\n}\r\n\r\nexport const getDefaultUserTypes = () => {\r\n    return [\r\n        {\r\n            Name: \"inventor\",\r\n            DisplayName: \"Inventor\",\r\n        },\r\n        {\r\n            Name: \"r&d_manager\",\r\n            DisplayName: \"R&D Manager\",\r\n        },\r\n        {\r\n            Name: \"attorney\",\r\n            DisplayName: \"Attorney\",\r\n        },\r\n        {\r\n            Name: \"decision_maker\",\r\n            DisplayName: \"Other Decision Makers\",\r\n        },\r\n        // {\r\n        //     Name: \"\",\r\n        //     DisplayName: \"\",\r\n        // },\r\n    ]\r\n}\r\n\r\nexport const getParseData = (inputData) => {\r\n    return JSON.parse(JSON.stringify(inputData))\r\n}\r\n\r\nexport const getMenuIconClass = (icon, disabled) => {\r\n    let negativeIconList = [\"delete\", \"remove\", \"close\"];\r\n    return (\r\n        disabled ?\r\n            \"menu-button disabled\"\r\n            :\r\n            negativeIconList.includes(icon.toLowerCase()) ?\r\n                \"menu-button delete-btn\" : \"menu-button\"\r\n    )\r\n}\r\n\r\nexport const getSeparatedModelNameAndVersion = (inputModelName) => {\r\n    //modelName\r\n    let modelName;\r\n    let version;\r\n    //Semiconductor_2023-11-29_V1\r\n    let splitArr = inputModelName.split(\"_\")\r\n    if (splitArr[splitArr.length - 1].includes(\"-\")) {\r\n        version = splitArr[splitArr.length - 1]\r\n        modelName = inputModelName.split(\"_\" + version)[0]\r\n    } else {\r\n        version = splitArr[splitArr.length - 2]\r\n        modelName = inputModelName.split(\"_\" + version)[0]\r\n    }\r\n\r\n    return {\r\n        modelName,\r\n        version\r\n    }\r\n}\r\n\r\nexport const getOperatorSpecificInfo = (operatorDisplayName) => {\r\n    const operatorInfoHashmap = {\r\n        \"Equals\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Does Not Equal\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Greater than\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Less than\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Greater than or Equals\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Less than or Equals\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Between\": {\r\n            ValidInputCount: 2,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Begins With\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Contains\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Does Not Contain\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Today\": {\r\n            ValidInputCount: 0,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Yesterday\": {\r\n            ValidInputCount: 0,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Is Blank\": {\r\n            ValidInputCount: 0,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Is Not Blank\": { //TODO to confirm with backend, how to pass to backend (as operator or as value))\r\n            ValidInputCount: 0,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Yes\": {\r\n            ValidInputCount: 0,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"No\": {\r\n            ValidInputCount: 0,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"In List\": {\r\n            ValidInputCount: -1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"On or Before\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"On or After\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"Last (N) Days\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"number\", // for required case\r\n        },\r\n        \"YTD\": {\r\n            ValidInputCount: 1,\r\n            InputType: \"number\", // for required case\r\n        },\r\n        \"Any of These\": {\r\n            ValidInputCount: -1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"All of These\": {\r\n            ValidInputCount: -1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"None of Any of These\": {\r\n            ValidInputCount: -1,\r\n            InputType: \"\", // for required case\r\n        },\r\n        \"None of All of These\": {\r\n            ValidInputCount: -1,\r\n            InputType: \"\", // for required case\r\n        },\r\n    }\r\n    let info = {\r\n        ValidInputCount: 1,\r\n        InputType: \"\", // for required case\r\n    }\r\n    if (operatorInfoHashmap[operatorDisplayName]) {\r\n        info = operatorInfoHashmap[operatorDisplayName]\r\n    }\r\n    return info\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}