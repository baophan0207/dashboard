var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * Creates an empty matrix with given rows and columns
 * @param rows - integer, the amount of rows the matrix should have
 * @param columns - integer, the amount of columns the matrix should have
 * @returns an empty matrix with given rows and columns
 */
export function createEmpty(rows, columns) {
    var matrix = Array(rows);
    for (var i = 0; i < rows; i++) {
        matrix[i] = Array(columns);
    }
    return matrix;
}
/** Gets the value at row and column of matrix. */
export function get(point, matrix) {
    var columns = matrix[point.row];
    if (columns === undefined) {
        return undefined;
    }
    return columns[point.column];
}
/** Creates a slice of matrix from startPoint up to, but not including, endPoint. */
export function slice(startPoint, endPoint, matrix) {
    var sliced = [];
    var columns = endPoint.column - startPoint.column;
    for (var row = startPoint.row; row <= endPoint.row; row++) {
        var slicedRow = row - startPoint.row;
        sliced[slicedRow] = sliced[slicedRow] || Array(columns);
        for (var column = startPoint.column; column <= endPoint.column; column++) {
            sliced[slicedRow][column - startPoint.column] = get({ row: row, column: column }, matrix);
        }
    }
    return sliced;
}
/** Sets the value at row and column of matrix. If a row doesn't exist, it's created. */
export function set(point, value, matrix) {
    var nextMatrix = __spreadArray([], __read(matrix), false);
    // Synchronize first row length
    var firstRow = matrix[0];
    var nextFirstRow = firstRow ? __spreadArray([], __read(firstRow), false) : [];
    if (nextFirstRow.length - 1 < point.column) {
        nextFirstRow[point.column] = undefined;
        nextMatrix[0] = nextFirstRow;
    }
    var nextRow = matrix[point.row] ? __spreadArray([], __read(matrix[point.row]), false) : [];
    nextRow[point.column] = value;
    nextMatrix[point.row] = nextRow;
    return nextMatrix;
}
/** Like Matrix.set() but mutates the matrix */
export function mutableSet(point, value, matrix) {
    var firstRow = matrix[0];
    if (!firstRow) {
        firstRow = [];
        matrix[0] = firstRow;
    }
    if (!(point.row in matrix)) {
        matrix[point.row] = [];
    }
    // Synchronize first row length
    if (!(point.column in firstRow)) {
        firstRow[point.column] = undefined;
    }
    matrix[point.row][point.column] = value;
}
/** Removes the coordinate of matrix */
export function unset(point, matrix) {
    if (!has(point, matrix)) {
        return matrix;
    }
    var nextMatrix = __spreadArray([], __read(matrix), false);
    var nextRow = __spreadArray([], __read(matrix[point.row]), false);
    // Avoid deleting to preserve first row length
    nextRow[point.column] = undefined;
    nextMatrix[point.row] = nextRow;
    return nextMatrix;
}
/** Creates an array of values by running each element in collection thru iteratee. */
export function map(func, matrix) {
    var e_1, _a, e_2, _b;
    var newMatrix = [];
    try {
        for (var _c = __values(matrix.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var _e = __read(_d.value, 2), row = _e[0], values = _e[1];
            try {
                for (var _f = (e_2 = void 0, __values(values.entries())), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var _h = __read(_g.value, 2), column = _h[0], value = _h[1];
                    var point = { row: row, column: column };
                    mutableSet(point, func(value, point), newMatrix);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f["return"])) _b.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return newMatrix;
}
/**
 * Converts all elements in row into a string separated by horizontalSeparator and each row string
 * to string separated by verticalSeparator
 */
export function join(matrix, horizontalSeparator, verticalSeparator) {
    if (horizontalSeparator === void 0) { horizontalSeparator = "\t"; }
    if (verticalSeparator === void 0) { verticalSeparator = "\n"; }
    var joined = "";
    var _a = getSize(matrix), rows = _a.rows, columns = _a.columns;
    for (var row = 0; row < rows; row++) {
        if (row) {
            joined += verticalSeparator;
        }
        for (var column = 0; column < columns; column++) {
            if (column) {
                joined += horizontalSeparator;
            }
            if (matrix[row] && column in matrix[row]) {
                joined += String(matrix[row][column]);
            }
        }
    }
    return joined;
}
/**
 * Parses a CSV separated by a horizontalSeparator and verticalSeparator into a
 * Matrix using a transform function
 */
export function split(csv, transform, horizontalSeparator, verticalSeparator) {
    if (horizontalSeparator === void 0) { horizontalSeparator = "\t"; }
    if (verticalSeparator === void 0) { verticalSeparator = /\r\n|\n|\r/; }
    return csv
        .split(verticalSeparator)
        .map(function (row) { return row.split(horizontalSeparator).map(transform); });
}
/** Returns whether the point exists in the matrix or not. */
export function has(point, matrix) {
    var firstRow = matrix[0];
    return (firstRow &&
        // validation
        point.row >= 0 &&
        point.column >= 0 &&
        Number.isInteger(point.row) &&
        Number.isInteger(point.column) &&
        // first row length is in sync with other rows
        point.column < firstRow.length &&
        point.row < matrix.length);
}
/** Gets the size of matrix by returning its number of rows and columns */
export function getSize(matrix) {
    var firstRow = matrix[0];
    return {
        columns: firstRow ? firstRow.length : 0,
        rows: matrix.length
    };
}
/**
 * Pads matrix with empty rows to match given total rows
 * @param matrix - matrix to pad
 * @param totalRows - number of rows the matrix should have
 * @returns the updated matrix
 */
export function padRows(matrix, totalRows) {
    var _a = getSize(matrix), rows = _a.rows, columns = _a.columns;
    if (rows >= totalRows) {
        return matrix;
    }
    var missingRows = totalRows - rows;
    var emptyRow = Array(columns).fill(undefined);
    var emptyRows = Array(missingRows).fill(emptyRow);
    return __spreadArray(__spreadArray([], __read(matrix), false), __read(emptyRows), false);
}
/**
 * Flattens a matrix values to an array
 * @param matrix - the matrix to flatten values from
 * @param transform - optional transform function to apply to each value in the
 * matrix
 * @returns an array of the values from matrix, transformed if a transform
 * function is passed
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function toArray(matrix, transform) {
    var array = [];
    for (var row = 0; row < matrix.length; row++) {
        for (var column = 0; column < matrix.length; column++) {
            var value = matrix[row][column];
            array.push(transform ? transform(value, { row: row, column: column }) : value);
        }
    }
    return array;
}
/** Returns the maximum point in the matrix */
export function maxPoint(matrix) {
    var size = getSize(matrix);
    return { row: size.rows - 1, column: size.columns - 1 };
}
