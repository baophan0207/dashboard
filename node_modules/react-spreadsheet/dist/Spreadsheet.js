var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
import * as React from "react";
import classNames from "classnames";
import * as PointRange from "./point-range";
import * as Actions from "./actions";
import * as PointMap from "./point-map";
import { Parser as FormulaParser } from "hot-formula-parser";
import DefaultTable from "./Table";
import DefaultRow from "./Row";
import DefaultCornerIndicator from "./CornerIndicator";
import DefaultColumnIndicator from "./ColumnIndicator";
import DefaultRowIndicator from "./RowIndicator";
import { Cell as DefaultCell, enhance as enhanceCell } from "./Cell";
import DefaultDataViewer from "./DataViewer";
import DefaultDataEditor from "./DataEditor";
import ActiveCell from "./ActiveCell";
import Selected from "./Selected";
import Copied from "./Copied";
import { getBindingsForCell as defaultGetBindingsForCell } from "./bindings";
import { range, readTextFromClipboard, writeTextToClipboard, getSelectedCSV, calculateSpreadsheetSize, transformCoordToPoint, getCellRangeValue, getCellValue, shouldHandleClipboardEvent, isFocusedWithin, } from "./util";
import reducer, { INITIAL_STATE, hasKeyDownHandler } from "./reducer";
import context from "./context";
import "./Spreadsheet.css";
/**
 * The Spreadsheet component
 */
var Spreadsheet = function (props) {
    var className = props.className, darkMode = props.darkMode, columnLabels = props.columnLabels, rowLabels = props.rowLabels, hideColumnIndicators = props.hideColumnIndicators, hideRowIndicators = props.hideRowIndicators, onKeyDown = props.onKeyDown, _a = props.Table, Table = _a === void 0 ? DefaultTable : _a, _b = props.Row, Row = _b === void 0 ? DefaultRow : _b, _c = props.CornerIndicator, CornerIndicator = _c === void 0 ? DefaultCornerIndicator : _c, _d = props.DataEditor, DataEditor = _d === void 0 ? DefaultDataEditor : _d, _e = props.DataViewer, DataViewer = _e === void 0 ? DefaultDataViewer : _e, _f = props.getBindingsForCell, getBindingsForCell = _f === void 0 ? defaultGetBindingsForCell : _f, _g = props.RowIndicator, RowIndicator = _g === void 0 ? DefaultRowIndicator : _g, _h = props.ColumnIndicator, ColumnIndicator = _h === void 0 ? DefaultColumnIndicator : _h, _j = props.onChange, onChange = _j === void 0 ? function () { } : _j, _k = props.onModeChange, onModeChange = _k === void 0 ? function () { } : _k, _l = props.onSelect, onSelect = _l === void 0 ? function () { } : _l, _m = props.onActivate, onActivate = _m === void 0 ? function () { } : _m, _o = props.onBlur, onBlur = _o === void 0 ? function () { } : _o, _p = props.onCellCommit, onCellCommit = _p === void 0 ? function () { } : _p;
    var initialState = React.useMemo(function () {
        return (__assign(__assign({}, INITIAL_STATE), { data: props.data }));
    }, [props.data]);
    var reducerElements = React.useReducer(reducer, initialState);
    var _q = __read(reducerElements, 2), state = _q[0], dispatch = _q[1];
    var size = React.useMemo(function () {
        return calculateSpreadsheetSize(state.data, rowLabels, columnLabels);
    }, [state.data, rowLabels, columnLabels]);
    var mode = state.mode;
    var rootRef = React.useRef(null);
    var prevStateRef = React.useRef(__assign(__assign({}, INITIAL_STATE), { data: props.data, selected: null, copied: PointMap.from([]), bindings: PointMap.from([]), lastCommit: null }));
    var copy = React.useCallback(function () { return dispatch(Actions.copy()); }, [dispatch]);
    var cut = React.useCallback(function () { return dispatch(Actions.cut()); }, [dispatch]);
    var paste = React.useCallback(function (data) { return dispatch(Actions.paste(data)); }, [dispatch]);
    var onKeyDownAction = React.useCallback(function (event) { return dispatch(Actions.keyDown(event)); }, [dispatch]);
    var onKeyPress = React.useCallback(function (event) { return dispatch(Actions.keyPress(event)); }, [dispatch]);
    var onDragStart = React.useCallback(function () { return dispatch(Actions.dragStart()); }, [dispatch]);
    var onDragEnd = React.useCallback(function () { return dispatch(Actions.dragEnd()); }, [dispatch]);
    var setData = React.useCallback(function (data) { return dispatch(Actions.setData(data)); }, [dispatch]);
    var blur = React.useCallback(function () { return dispatch(Actions.blur()); }, [dispatch]);
    React.useEffect(function () {
        var e_1, _a;
        var prevState = prevStateRef.current;
        if (state.lastCommit && state.lastCommit !== prevState.lastCommit) {
            try {
                for (var _b = __values(state.lastCommit), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var change = _c.value;
                    onCellCommit(change.prevCell, change.nextCell, state.active);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        if (state.data !== prevState.data) {
            // Call on change only if the data change internal
            if (state.data !== props.data) {
                onChange(state.data);
            }
        }
        if (state.mode !== prevState.mode) {
            onModeChange(state.mode);
        }
        if (state.selected !== prevState.selected) {
            var points = state.selected
                ? Array.from(PointRange.iterate(state.selected))
                : [];
            onSelect(points);
        }
        if (state.active !== prevState.active) {
            if (state.active) {
                onActivate(state.active);
            }
            else {
                var root = rootRef.current;
                if (root && isFocusedWithin(root) && document.activeElement) {
                    document.activeElement.blur();
                }
                onBlur();
            }
        }
        prevStateRef.current = state;
    }, [
        props.data,
        state,
        onActivate,
        onBlur,
        onCellCommit,
        onChange,
        onModeChange,
        onSelect,
        rowLabels,
        columnLabels,
    ]);
    React.useEffect(function () {
        var prevState = prevStateRef.current;
        if (props.data !== prevState.data) {
            setData(props.data);
        }
    }, [props.data, setData]);
    var clip = React.useCallback(function (event) {
        var data = state.data, selected = state.selected;
        var csv = getSelectedCSV(selected, data);
        writeTextToClipboard(event, csv);
    }, [state]);
    var handleCut = React.useCallback(function (event) {
        if (shouldHandleClipboardEvent(rootRef.current, mode)) {
            event.preventDefault();
            event.stopPropagation();
            clip(event);
            cut();
        }
    }, [mode, clip, cut]);
    var handleCopy = React.useCallback(function (event) {
        if (shouldHandleClipboardEvent(rootRef.current, mode)) {
            event.preventDefault();
            event.stopPropagation();
            clip(event);
            copy();
        }
    }, [mode, clip, copy]);
    var handlePaste = React.useCallback(function (event) {
        if (shouldHandleClipboardEvent(rootRef.current, mode)) {
            event.preventDefault();
            event.stopPropagation();
            if (event.clipboardData) {
                var text = readTextFromClipboard(event);
                paste(text);
            }
        }
    }, [mode, paste]);
    var handleKeyDown = React.useCallback(function (event) {
        if (onKeyDown) {
            onKeyDown(event);
        }
        // Do not use event in case preventDefault() was called inside onKeyDown
        if (!event.defaultPrevented) {
            // Only disable default behavior if an handler exist
            if (hasKeyDownHandler(state, event)) {
                event.nativeEvent.preventDefault();
            }
            onKeyDownAction(event);
        }
    }, [state, onKeyDown, onKeyDownAction]);
    var handleMouseUp = React.useCallback(function () {
        onDragEnd();
        document.removeEventListener("mouseup", handleMouseUp);
    }, [onDragEnd]);
    var handleMouseMove = React.useCallback(function (event) {
        if (!state.dragging && event.buttons === 1) {
            onDragStart();
            document.addEventListener("mouseup", handleMouseUp);
        }
    }, [state, onDragStart, handleMouseUp]);
    var handleBlur = React.useCallback(function (event) {
        var currentTarget = event.currentTarget;
        setTimeout(function () {
            if (!isFocusedWithin(currentTarget)) {
                blur();
            }
        }, 0);
    }, [blur]);
    var formulaParser = React.useMemo(function () {
        return props.formulaParser || new FormulaParser();
    }, [props.formulaParser]);
    var Cell = React.useMemo(function () {
        // @ts-ignore
        return enhanceCell(props.Cell || DefaultCell);
    }, [props.Cell]);
    React.useEffect(function () {
        document.addEventListener("cut", handleCut);
        document.addEventListener("copy", handleCopy);
        document.addEventListener("paste", handlePaste);
        return function () {
            document.removeEventListener("cut", handleCut);
            document.removeEventListener("copy", handleCopy);
            document.removeEventListener("paste", handlePaste);
        };
    }, [handleCut, handleCopy, handlePaste]);
    React.useEffect(function () {
        formulaParser.on("callCellValue", function (cellCoord, done) {
            var value;
            try {
                var point = transformCoordToPoint(cellCoord);
                var data = state.data;
                value = getCellValue(formulaParser, data, point);
            }
            catch (error) {
                console.error(error);
            }
            finally {
                done(value);
            }
        });
        formulaParser.on("callRangeValue", function (startCellCoord, endCellCoord, done) {
            var startPoint = transformCoordToPoint(startCellCoord);
            var endPoint = transformCoordToPoint(endCellCoord);
            var data = state.data;
            var values;
            try {
                values = getCellRangeValue(formulaParser, data, startPoint, endPoint);
            }
            catch (error) {
                console.error(error);
            }
            finally {
                done(values);
            }
        });
    }, [formulaParser, state, handleCut, handleCopy, handlePaste]);
    var tableNode = React.useMemo(function () { return (React.createElement(Table, { columns: size.columns, hideColumnIndicators: hideColumnIndicators },
        React.createElement(Row, null,
            !hideRowIndicators && !hideColumnIndicators && React.createElement(CornerIndicator, null),
            !hideColumnIndicators &&
                range(size.columns).map(function (columnNumber) {
                    return columnLabels ? (React.createElement(ColumnIndicator, { key: columnNumber, column: columnNumber, label: columnNumber in columnLabels
                            ? columnLabels[columnNumber]
                            : null })) : (React.createElement(ColumnIndicator, { key: columnNumber, column: columnNumber }));
                })),
        range(size.rows).map(function (rowNumber) { return (React.createElement(Row, { key: rowNumber },
            !hideRowIndicators &&
                (rowLabels ? (React.createElement(RowIndicator, { key: rowNumber, row: rowNumber, label: rowNumber in rowLabels ? rowLabels[rowNumber] : null })) : (React.createElement(RowIndicator, { key: rowNumber, row: rowNumber }))),
            range(size.columns).map(function (columnNumber) { return (React.createElement(Cell, { key: columnNumber, row: rowNumber, column: columnNumber, 
                // @ts-ignore
                DataViewer: DataViewer, formulaParser: formulaParser })); }))); }))); }, [
        Table,
        size.rows,
        size.columns,
        hideColumnIndicators,
        Row,
        hideRowIndicators,
        CornerIndicator,
        columnLabels,
        ColumnIndicator,
        rowLabels,
        RowIndicator,
        Cell,
        DataViewer,
        formulaParser,
    ]);
    var activeCellNode = React.useMemo(function () { return (React.createElement(ActiveCell
    // @ts-ignore
    , { 
        // @ts-ignore
        DataEditor: DataEditor, 
        // @ts-ignore
        getBindingsForCell: getBindingsForCell })); }, [DataEditor, getBindingsForCell]);
    var rootNode = React.useMemo(function () { return (React.createElement("div", { ref: rootRef, className: classNames("Spreadsheet", className, {
            "Spreadsheet--dark-mode": darkMode
        }), onKeyPress: onKeyPress, onKeyDown: handleKeyDown, onMouseMove: handleMouseMove, onBlur: handleBlur },
        tableNode,
        activeCellNode,
        React.createElement(Selected, null),
        React.createElement(Copied, null))); }, [
        className,
        darkMode,
        onKeyPress,
        handleKeyDown,
        handleMouseMove,
        handleBlur,
        tableNode,
        activeCellNode,
    ]);
    return (React.createElement(context.Provider, { value: reducerElements }, rootNode));
};
export default Spreadsheet;
