var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import * as PointSet from "./point-set";
import * as PointMap from "./point-map";
import * as PointRange from "./point-range";
import * as Matrix from "./matrix";
import { isActive, normalizeSelected } from "./util";
import { createReducer } from "@reduxjs/toolkit";
import * as Actions from "./actions";
var Direction;
(function (Direction) {
    Direction["Left"] = "Left";
    Direction["Right"] = "Right";
    Direction["Top"] = "Top";
    Direction["Down"] = "Down";
})(Direction || (Direction = {}));
export var INITIAL_STATE = {
    active: null,
    mode: "view",
    rowDimensions: {},
    columnDimensions: {},
    lastChanged: null,
    hasPasted: false,
    cut: false,
    dragging: false,
    data: [],
    selected: null,
    copied: PointMap.from([]),
    bindings: PointMap.from([]),
    lastCommit: null
};
var reducer = createReducer(INITIAL_STATE, function (builder) {
    builder.addCase(Actions.setData, function (state, action) {
        var data = action.payload.data;
        var nextActive = state.active && Matrix.has(state.active, data) ? state.active : null;
        var nextSelected = normalizeSelected(state.selected, data);
        var nextBindings = PointMap.map(function (bindings) {
            return PointSet.filter(function (point) { return Matrix.has(point, data); }, bindings);
        }, PointMap.filter(function (_, point) { return Matrix.has(point, data); }, state.bindings));
        return __assign(__assign({}, state), { data: data, active: nextActive, selected: nextSelected, bindings: nextBindings });
    });
    builder.addCase(Actions.select, function (state, action) {
        var point = action.payload.point;
        if (state.active && !isActive(state.active, point)) {
            return __assign(__assign({}, state), { selected: PointRange.create(point, state.active), mode: "view" });
        }
    });
    builder.addCase(Actions.activate, function (state, action) {
        var point = action.payload.point;
        return __assign(__assign({}, state), { selected: PointRange.create(point, point), active: point, mode: isActive(state.active, point) ? "edit" : "view" });
    });
    builder.addCase(Actions.setCellData, function (state, action) {
        var _a = action.payload, active = _a.active, cellData = _a.data, getBindingsForCell = _a.getBindingsForCell;
        var bindings = getBindingsForCell(cellData, state.data);
        if (isActiveReadOnly(state)) {
            return;
        }
        return __assign(__assign({}, state), { mode: "edit", data: Matrix.set(active, cellData, state.data), lastChanged: active, bindings: PointMap.set(active, PointSet.from(bindings), state.bindings) });
    });
    builder.addCase(Actions.setCellDimensions, function (state, action) {
        var _a, _b;
        var _c = action.payload, point = _c.point, dimensions = _c.dimensions;
        var prevRowDimensions = state.rowDimensions[point.row];
        var prevColumnDimensions = state.columnDimensions[point.column];
        if (prevRowDimensions &&
            prevColumnDimensions &&
            prevRowDimensions.top === dimensions.top &&
            prevRowDimensions.height === dimensions.height &&
            prevColumnDimensions.left === dimensions.left &&
            prevColumnDimensions.width === dimensions.width) {
            return;
        }
        return __assign(__assign({}, state), { rowDimensions: __assign(__assign({}, state.rowDimensions), (_a = {}, _a[point.row] = { top: dimensions.top, height: dimensions.height }, _a)), columnDimensions: __assign(__assign({}, state.columnDimensions), (_b = {}, _b[point.column] = { left: dimensions.left, width: dimensions.width }, _b)) });
    });
    builder.addCase(Actions.paste, function (state, action) {
        var text = action.payload.data;
        var active = state.active;
        if (!active) {
            return;
        }
        var copiedMatrix = Matrix.split(text, function (value) { return ({ value: value }); });
        var copied = PointMap.fromMatrix(copiedMatrix);
        var minPoint = PointSet.min(copied);
        var copiedSize = Matrix.getSize(copiedMatrix);
        var requiredRows = active.row + copiedSize.rows;
        var paddedData = Matrix.padRows(state.data, requiredRows);
        var _a = PointMap.reduce(function (acc, value, point) {
            var commit = acc.commit || [];
            var nextPoint = {
                row: point.row - minPoint.row + active.row,
                column: point.column - minPoint.column + active.column
            };
            var nextData = state.cut ? Matrix.unset(point, acc.data) : acc.data;
            if (state.cut) {
                commit = __spreadArray(__spreadArray([], __read(commit), false), [{ prevCell: value, nextCell: null }], false);
            }
            if (!Matrix.has(nextPoint, paddedData)) {
                return { data: nextData, commit: commit };
            }
            var currentValue = Matrix.get(nextPoint, nextData) || null;
            commit = __spreadArray(__spreadArray([], __read(commit), false), [
                {
                    prevCell: currentValue,
                    nextCell: value
                },
            ], false);
            return {
                data: Matrix.set(nextPoint, __assign(__assign({}, currentValue), value), nextData),
                commit: commit
            };
        }, copied, { data: paddedData, commit: [] }), data = _a.data, commit = _a.commit;
        return __assign(__assign({}, state), { data: data, selected: PointRange.create(active, {
                row: active.row + copiedSize.rows - 1,
                column: active.column + copiedSize.columns - 1
            }), cut: false, hasPasted: true, mode: "view", lastCommit: commit });
    });
    builder.addCase(Actions.edit, edit);
    builder.addCase(Actions.view, view);
    builder.addCase(Actions.clear, clear);
    builder.addCase(Actions.blur, blur);
    builder.addCase(Actions.keyPress, function (state, action) {
        var event = action.payload.event;
        if (isActiveReadOnly(state) || event.metaKey) {
            return;
        }
        if (state.mode === "view" && state.active) {
            return edit(state);
        }
        return;
    });
    builder.addCase(Actions.keyDown, function (state, action) {
        var event = action.payload.event;
        var handler = getKeyDownHandler(state, event);
        if (handler) {
            return __assign(__assign({}, state), handler(state, event));
        }
        return;
    });
    builder.addCase(Actions.dragStart, function (state, action) {
        return __assign(__assign({}, state), { dragging: true });
    });
    builder.addCase(Actions.dragEnd, function (state, action) {
        return __assign(__assign({}, state), { dragging: false });
    });
    builder.addCase(Actions.commit, function (state, action) {
        var changes = action.payload.changes;
        return __assign(__assign({}, state), commit(changes));
    });
    builder.addMatcher(function (action) {
        return action.type === Actions.copy.type || action.type === Actions.cut.type;
    }, function (state, action) {
        var selectedPoints = state.selected
            ? Array.from(PointRange.iterate(state.selected))
            : [];
        return __assign(__assign({}, state), { copied: selectedPoints.reduce(function (acc, point) {
                var cell = Matrix.get(point, state.data);
                return cell === undefined ? acc : PointMap.set(point, cell, acc);
            }, PointMap.from([])), cut: action.type === Actions.cut.type, hasPasted: false });
    });
});
export default reducer;
// Shared reducers
function edit(state) {
    if (isActiveReadOnly(state)) {
        return;
    }
    return __assign(__assign({}, state), { mode: "edit" });
}
function clear(state) {
    if (!state.active) {
        return;
    }
    var selectedPoints = state.selected
        ? Array.from(PointRange.iterate(state.selected))
        : [];
    var changes = selectedPoints.map(function (point) {
        var cell = Matrix.get(point, state.data);
        return __assign(__assign({}, state), { prevCell: cell || null, nextCell: null });
    });
    return __assign(__assign(__assign({}, state), { data: selectedPoints.reduce(function (acc, point) { return Matrix.set(point, undefined, acc); }, state.data) }), commit(changes));
}
function blur(state) {
    return __assign(__assign({}, state), { active: null, selected: null });
}
function view(state) {
    return __assign(__assign({}, state), { mode: "view" });
}
function commit(changes) {
    return { lastCommit: changes };
}
// Utility
export var go = function (rowDelta, columnDelta) {
    return function (state) {
        if (!state.active) {
            return;
        }
        var nextActive = {
            row: state.active.row + rowDelta,
            column: state.active.column + columnDelta
        };
        if (!Matrix.has(nextActive, state.data)) {
            return __assign(__assign({}, state), { mode: "view" });
        }
        return __assign(__assign({}, state), { active: nextActive, selected: PointRange.create(nextActive, nextActive), mode: "view" });
    };
};
var keyDownHandlers = {
    ArrowUp: go(-1, 0),
    ArrowDown: go(+1, 0),
    ArrowLeft: go(0, -1),
    ArrowRight: go(0, +1),
    Tab: go(0, +1),
    Enter: edit,
    Backspace: clear,
    Escape: blur
};
var editKeyDownHandlers = {
    Escape: view,
    Tab: keyDownHandlers.Tab,
    Enter: keyDownHandlers.ArrowDown
};
var editShiftKeyDownHandlers = {
    Tab: go(0, -1)
};
export var modifyEdge = function (edge) {
    return function (state) {
        var _a, _b, _c;
        var active = state.active, selected = state.selected;
        if (!active || !selected) {
            return;
        }
        var field = edge === Direction.Left || edge === Direction.Right ? "column" : "row";
        var key = edge === Direction.Left || edge === Direction.Top ? "start" : "end";
        var delta = key === "start" ? -1 : 1;
        var edgeOffsets = PointRange.has(selected, __assign(__assign({}, active), (_a = {}, _a[field] = active[field] + delta * -1, _a)));
        var keyToModify = edgeOffsets ? (key === "start" ? "end" : "start") : key;
        var nextSelected = __assign(__assign({}, selected), (_b = {}, _b[keyToModify] = __assign(__assign({}, selected[keyToModify]), (_c = {}, _c[field] = selected[keyToModify][field] + delta, _c)), _b));
        return __assign(__assign({}, state), { selected: normalizeSelected(nextSelected, state.data) });
    };
};
var shiftKeyDownHandlers = {
    ArrowUp: modifyEdge(Direction.Top),
    ArrowDown: modifyEdge(Direction.Down),
    ArrowLeft: modifyEdge(Direction.Left),
    ArrowRight: modifyEdge(Direction.Right),
    Tab: go(0, -1)
};
var shiftMetaKeyDownHandlers = {};
var metaKeyDownHandlers = {};
export function getKeyDownHandler(state, event) {
    var key = event.key;
    var handlers;
    // Order matters
    if (state.mode === "edit") {
        if (event.shiftKey) {
            handlers = editShiftKeyDownHandlers;
        }
        else {
            handlers = editKeyDownHandlers;
        }
    }
    else if (event.shiftKey && event.metaKey) {
        handlers = shiftMetaKeyDownHandlers;
    }
    else if (event.shiftKey) {
        handlers = shiftKeyDownHandlers;
    }
    else if (event.metaKey) {
        handlers = metaKeyDownHandlers;
    }
    else {
        handlers = keyDownHandlers;
    }
    return handlers[key];
}
/** Returns whether the reducer has a handler for the given keydown event */
export function hasKeyDownHandler(state, event) {
    return getKeyDownHandler(state, event) !== undefined;
}
/** Returns whether the active cell is read only */
export function isActiveReadOnly(state) {
    var activeCell = getActive(state);
    return Boolean(activeCell === null || activeCell === void 0 ? void 0 : activeCell.readOnly);
}
/** Gets active cell from given state */
export function getActive(state) {
    var activeCell = state.active && Matrix.get(state.active, state.data);
    return activeCell || null;
}
