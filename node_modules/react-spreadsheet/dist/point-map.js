var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/** Sets the value for point in map */
export function set(point, value, map) {
    var _a, _b;
    return __assign(__assign({}, map), (_a = {}, _a[point.row] = __assign(__assign({}, map[point.row]), (_b = {}, _b[point.column] = value, _b)), _a));
}
export function unset(_a, map) {
    var _b;
    var row = _a.row, column = _a.column;
    if (!(row in map) || !(column in map[row])) {
        return map;
    }
    var _c = map, 
    // @ts-ignore
    _d = String(row), 
    // @ts-ignore
    _e = _c[_d], _f = String(column), _ = _e[_f], nextRow = __rest(_e, [typeof _f === "symbol" ? _f : _f + ""]), nextMap = __rest(_c, [typeof _d === "symbol" ? _d : _d + ""]);
    if (Object.keys(nextRow).length === 0) {
        return nextMap;
    }
    return __assign(__assign({}, nextMap), (_b = {}, _b[row] = nextRow, _b));
}
/** Gets the value for point in map */
export function get(point, map) {
    return map[point.row] && map[point.row][point.column];
}
/** Checks if map has point assigned to value */
export function has(point, map) {
    return point.row in map && point.column in map[point.row];
}
/** Get all the values of a certain row */
export function getRow(row, map) {
    return row in map
        ? // @ts-ignore
            Object.keys(map[row]).map(function (column) { return map[row][column]; })
        : [];
}
/** Get all the values of a certain column */
export function getColumn(column, map) {
    return (Object.keys(map)
        // @ts-ignore
        .filter(function (row) { return column in map[row]; })
        // @ts-ignore
        .map(function (row) { return map[row][column]; }));
}
var EMPTY = {};
/** Creates a new PointMap instance from an array-like or iterable object. */
export function from(pairs) {
    return pairs.reduce(function (acc, _a) {
        var _b = __read(_a, 2), point = _b[0], value = _b[1];
        return set(point, value, acc);
    }, EMPTY);
}
/** Creates a new PointMap instance from a Matrix. */
export function fromMatrix(matrix) {
    return matrix.reduce(function (rowAcc, data, row) {
        return data.reduce(function (colAcc, cell, column) {
            return cell ? set({ row: row, column: column }, cell, colAcc) : colAcc;
        }, rowAcc);
    }, EMPTY);
}
/** Returns the number of elements in a PointMap object. */
export function size(map) {
    var acc = 0;
    var _map_keys = Object.keys(map);
    for (var i = 0; i < _map_keys.length; i++) {
        var row = Number(_map_keys[i]);
        var columns = map[row];
        acc += Object.keys(columns).length;
    }
    return acc;
}
/** Applies a function against an accumulator and each value and point in the map (from left to right) to reduce it to a single value */
export function reduce(func, map, initialValue) {
    var acc = initialValue;
    var _map_keys = Object.keys(map);
    for (var i = 0; i < _map_keys.length; i++) {
        var row = Number(_map_keys[i]);
        var columns = map[row];
        var _columns_keys = Object.keys(columns);
        for (var j = 0; j < _columns_keys.length; j++) {
            var column = Number(_columns_keys[j]);
            var value = columns[column];
            acc = func(acc, value, { row: row, column: column });
        }
    }
    return acc;
}
/** Creates a new map with the results of calling a provided function on every value in the calling map */
export function map(func, map) {
    return reduce(function (acc, value, point) { return set(point, func(value), acc); }, map, from([]));
}
/** Creates a new map of all values predicate returns truthy for. The predicate is invoked with two arguments: (value, key) */
export function filter(predicate, map) {
    return reduce(function (acc, value, point) {
        if (predicate(value, point)) {
            return set(point, value, acc);
        }
        return acc;
    }, map, from([]));
}
/** Returns whether map has any points set to value */
export function isEmpty(map) {
    return Object.keys(map).length === 0;
}
