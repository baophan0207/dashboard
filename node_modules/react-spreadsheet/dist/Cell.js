var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from "react";
import classnames from "classnames";
import * as PointSet from "./point-set";
import * as PointMap from "./point-map";
import * as PointRange from "./point-range";
import * as Matrix from "./matrix";
import * as Actions from "./actions";
import { isActive, getOffsetRect } from "./util";
import useDispatch from "./use-dispatch";
import useSelector from "./use-selector";
export var Cell = function (_a) {
    var row = _a.row, column = _a.column, DataViewer = _a.DataViewer, formulaParser = _a.formulaParser, selected = _a.selected, active = _a.active, dragging = _a.dragging, mode = _a.mode, data = _a.data, select = _a.select, activate = _a.activate, setCellDimensions = _a.setCellDimensions;
    var rootRef = React.useRef(null);
    var point = React.useMemo(function () { return ({
        row: row,
        column: column
    }); }, [row, column]);
    var handleMouseDown = React.useCallback(function (event) {
        if (mode === "view") {
            setCellDimensions(point, getOffsetRect(event.currentTarget));
            if (event.shiftKey) {
                select(point);
            }
            else {
                activate(point);
            }
        }
    }, [mode, setCellDimensions, point, select, activate]);
    var handleMouseOver = React.useCallback(function (event) {
        if (dragging) {
            setCellDimensions(point, getOffsetRect(event.currentTarget));
            select(point);
        }
    }, [setCellDimensions, select, dragging, point]);
    React.useEffect(function () {
        var root = rootRef.current;
        if (selected && root) {
            setCellDimensions(point, getOffsetRect(root));
        }
        if (root && active && mode === "view") {
            root.focus();
        }
    }, [setCellDimensions, selected, active, mode, point]);
    if (data && data.DataViewer) {
        // @ts-ignore
        DataViewer = data.DataViewer;
    }
    return (React.createElement("td", { ref: rootRef, className: classnames("Spreadsheet__cell", data === null || data === void 0 ? void 0 : data.className, {
            "Spreadsheet__cell--readonly": data === null || data === void 0 ? void 0 : data.readOnly
        }), onMouseOver: handleMouseOver, onMouseDown: handleMouseDown, tabIndex: 0 },
        React.createElement(DataViewer, { row: row, column: column, cell: data, formulaParser: formulaParser })));
};
export var enhance = function (CellComponent) {
    return function CellWrapper(props) {
        var row = props.row, column = props.column;
        var dispatch = useDispatch();
        var select = React.useCallback(function (point) { return dispatch(Actions.select(point)); }, [dispatch]);
        var activate = React.useCallback(function (point) { return dispatch(Actions.activate(point)); }, [dispatch]);
        var setCellDimensions = React.useCallback(function (point, dimensions) {
            return dispatch(Actions.setCellDimensions(point, dimensions));
        }, [dispatch]);
        var active = useSelector(function (state) {
            return isActive(state.active, {
                row: row,
                column: column
            });
        });
        var mode = useSelector(function (state) { return (active ? state.mode : "view"); });
        var data = useSelector(function (state) {
            return Matrix.get({ row: row, column: column }, state.data);
        });
        var selected = useSelector(function (state) {
            return state.selected ? PointRange.has(state.selected, { row: row, column: column }) : false;
        });
        var dragging = useSelector(function (state) { return state.dragging; });
        var copied = useSelector(function (state) {
            return PointMap.has({ row: row, column: column }, state.copied);
        });
        // Use only to trigger re-render when cell bindings change
        useSelector(function (state) {
            var point = { row: row, column: column };
            var cellBindings = PointMap.get(point, state.bindings);
            return cellBindings &&
                state.lastChanged &&
                PointSet.has(cellBindings, state.lastChanged)
                ? {}
                : null;
        });
        return (React.createElement(CellComponent, __assign({}, props, { selected: selected, active: active, copied: copied, dragging: dragging, mode: mode, data: data, select: select, activate: activate, setCellDimensions: setCellDimensions })));
    };
};
