import * as React from "react";
import classnames from "classnames";
import * as Matrix from "./matrix";
import * as Actions from "./actions";
import useSelector from "./use-selector";
import useDispatch from "./use-dispatch";
import { getCellDimensions } from "./util";
var ActiveCell = function (props) {
    var rootRef = React.useRef(null);
    var getBindingsForCell = props.getBindingsForCell;
    var dispatch = useDispatch();
    var setCellData = React.useCallback(function (active, data) {
        return dispatch(Actions.setCellData(active, data, getBindingsForCell));
    }, [dispatch, getBindingsForCell]);
    var edit = React.useCallback(function () { return dispatch(Actions.edit()); }, [dispatch]);
    var commit = React.useCallback(function (changes) {
        return dispatch(Actions.commit(changes));
    }, [dispatch]);
    var view = React.useCallback(function () {
        dispatch(Actions.view());
    }, [dispatch]);
    var active = useSelector(function (state) { return state.active; });
    var mode = useSelector(function (state) { return state.mode; });
    var cell = useSelector(function (state) {
        return state.active ? Matrix.get(state.active, state.data) : undefined;
    });
    var dimensions = useSelector(function (state) {
        return active
            ? getCellDimensions(active, state.rowDimensions, state.columnDimensions)
            : undefined;
    });
    var hidden = React.useMemo(function () { return !active || !dimensions; }, [active, dimensions]);
    var initialCellRef = React.useRef(undefined);
    var prevActiveRef = React.useRef(null);
    var prevCellRef = React.useRef(undefined);
    var handleChange = React.useCallback(function (cell) {
        if (!active) {
            return;
        }
        setCellData(active, cell);
    }, [setCellData, active]);
    React.useEffect(function () {
        var root = rootRef.current;
        if (!hidden && root) {
            root.focus();
        }
    }, [rootRef, hidden]);
    React.useEffect(function () {
        var prevActive = prevActiveRef.current;
        var prevCell = prevCellRef.current;
        prevActiveRef.current = active;
        prevCellRef.current = cell;
        if (!prevActive || !prevCell) {
            return;
        }
        // Commit
        var coordsChanged = (active === null || active === void 0 ? void 0 : active.row) !== prevActive.row || (active === null || active === void 0 ? void 0 : active.column) !== prevActive.column;
        var exitedEditMode = mode !== "edit";
        if (coordsChanged || exitedEditMode) {
            var initialCell = initialCellRef.current;
            if (prevCell !== initialCell) {
                commit([
                    {
                        prevCell: initialCell || null,
                        nextCell: prevCell
                    },
                ]);
            }
            else if (!coordsChanged && cell !== prevCell) {
                commit([
                    {
                        prevCell: prevCell,
                        nextCell: cell || null
                    },
                ]);
            }
            initialCellRef.current = cell;
        }
    });
    var DataEditor = (cell && cell.DataEditor) || props.DataEditor;
    var readOnly = cell && cell.readOnly;
    return hidden ? null : (React.createElement("div", { ref: rootRef, className: classnames("Spreadsheet__active-cell", "Spreadsheet__active-cell--" + mode), style: dimensions, onClick: mode === "view" && !readOnly ? edit : undefined, tabIndex: 0 }, mode === "edit" && active && (React.createElement(DataEditor, { row: active.row, column: active.column, cell: cell, 
        // @ts-ignore
        onChange: handleChange, exitEditMode: view }))));
};
export default ActiveCell;
