var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as Matrix from "./matrix";
import * as Point from "./point";
import * as PointRange from "./point-range";
import * as PointMap from "./point-map";
import * as PointSet from "./point-set";
import * as Formula from "./formula";
export { createEmpty as createEmptyMatrix } from "./matrix";
export var PLAIN_TEXT_MIME = "text/plain";
export var FOCUS_WITHIN_SELECTOR = ":focus-within";
/** Move the cursor of given input element to the input's end */
export function moveCursorToEnd(el) {
    el.selectionStart = el.selectionEnd = el.value.length;
}
/**
 * Creates an array of numbers (positive and/or negative) progressing from start up to, but not including, end. A step of -1 is used if a negative start is specified without an end or step. If end is not specified, it's set to start with start then set to 0.
 * @param end - an integer number specifying at which position to stop (not included).
 * @param start - An integer number specifying at which position to start.
 * @param step - An integer number specifying the incrementation
 */
export function range(end, start, step) {
    if (start === void 0) { start = 0; }
    if (step === void 0) { step = 1; }
    var array = [];
    if (Math.sign(end - start) === -1) {
        for (var element = start; element > end; element -= step) {
            array.push(element);
        }
        return array;
    }
    for (var element = start; element < end; element += step) {
        array.push(element);
    }
    return array;
}
/** Return whether given point is active */
export function isActive(active, point) {
    return Boolean(active && Point.isEqual(point, active));
}
/** Get the offset values of given element */
export function getOffsetRect(element) {
    return {
        width: element.offsetWidth,
        height: element.offsetHeight,
        left: element.offsetLeft,
        top: element.offsetTop
    };
}
/** Write given data to clipboard with given event */
export function writeTextToClipboard(event, data) {
    var _a;
    (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData(PLAIN_TEXT_MIME, data);
}
/** Read text from given clipboard event */
export function readTextFromClipboard(event) {
    // @ts-ignore
    if (window.clipboardData && window.clipboardData.getData) {
        // @ts-ignore
        return window.clipboardData.getData("Text");
    }
    if (event.clipboardData && event.clipboardData.getData) {
        return event.clipboardData.getData(PLAIN_TEXT_MIME);
    }
    return "";
}
/** Get the dimensions of cell at point from state */
export function getCellDimensions(point, rowDimensions, columnDimensions) {
    var cellRowDimensions = rowDimensions && rowDimensions[point.row];
    var cellColumnDimensions = columnDimensions && columnDimensions[point.column];
    return (cellRowDimensions &&
        cellColumnDimensions && __assign(__assign({}, cellRowDimensions), cellColumnDimensions));
}
/** Get the dimensions of a range of cells */
export function getRangeDimensions(rowDimensions, columnDimensions, range) {
    var startDimensions = getCellDimensions(range.start, rowDimensions, columnDimensions);
    var endDimensions = getCellDimensions(range.end, rowDimensions, columnDimensions);
    return (startDimensions &&
        endDimensions && {
        width: endDimensions.left + endDimensions.width - startDimensions.left,
        height: endDimensions.top + endDimensions.height - startDimensions.top,
        top: startDimensions.top,
        left: startDimensions.left
    });
}
/** Get the computed value of a cell. */
export function getComputedValue(_a) {
    var cell = _a.cell, formulaParser = _a.formulaParser;
    if (cell === undefined) {
        return null;
    }
    if (isFormulaCell(cell)) {
        return getFormulaComputedValue({ cell: cell, formulaParser: formulaParser });
    }
    return cell.value;
}
/** Get the computed value of a formula cell */
export function getFormulaComputedValue(_a) {
    var cell = _a.cell, formulaParser = _a.formulaParser;
    var formula = Formula.extractFormula(cell.value);
    var _b = formulaParser.parse(formula), result = _b.result, error = _b.error;
    return error || result;
}
/** Returns whether given cell contains a formula value */
export function isFormulaCell(cell) {
    return Formula.isFormulaValue(cell.value);
}
/** Normalize given selected range to given data matrix */
export function normalizeSelected(selected, data) {
    var dataRange = getMatrixRange(data);
    return selected && PointRange.mask(selected, dataRange);
}
/** Get the point range of given matrix */
export function getMatrixRange(data) {
    var maxPoint = Matrix.maxPoint(data);
    return PointRange.create(Point.ORIGIN, maxPoint);
}
/** Get given selected range from given data as CSV */
export function getSelectedCSV(selected, data) {
    if (!selected) {
        return "";
    }
    var selectedData = getRangeFromMatrix(selected, data);
    return getCSV(selectedData);
}
/** Get given data as CSV */
export function getCSV(data) {
    var valueMatrix = Matrix.map(function (cell) { return (cell === null || cell === void 0 ? void 0 : cell.value) || ""; }, data);
    return Matrix.join(valueMatrix);
}
export function getRangeFromMatrix(range, matrix) {
    return Matrix.slice(range.start, range.end, matrix);
}
/**
 * Calculate the rows and columns counts of a spreadsheet
 * @param data - the spreadsheet's data
 * @param rowLabels - the spreadsheet's row labels (if defined)
 * @param columnLabels - the spreadsheet's column labels (if defined)
 * @returns the rows and columns counts of a spreadsheet
 */
export function calculateSpreadsheetSize(data, rowLabels, columnLabels) {
    var _a = Matrix.getSize(data), columns = _a.columns, rows = _a.rows;
    return {
        rows: rowLabels ? Math.max(rows, rowLabels.length) : rows,
        columns: columnLabels ? Math.max(columns, columnLabels.length) : columns
    };
}
/** Transform given point map to a point set */
export function convertPointMapToPointSet(map) {
    return PointMap.map(function () { return true; }, map);
}
/** Get the range of copied cells. If none are copied return null */
export function getCopiedRange(copied, hasPasted) {
    if (hasPasted || PointMap.isEmpty(copied)) {
        return null;
    }
    var set = convertPointMapToPointSet(copied);
    return PointSet.toRange(set);
}
/** Tranform given hot-formula-parser coord to Point.Point */
export function transformCoordToPoint(coord) {
    return { row: coord.row.index, column: coord.column.index };
}
/**
 * Get cell value for given point from given spreadsheet data with evaluated
 * cells using given formulaParser
 */
export function getCellValue(formulaParser, data, point) {
    return getComputedValue({
        cell: Matrix.get(point, data),
        formulaParser: formulaParser
    });
}
/**
 * Get cell range value for given start and end points from given spreadsheet
 * data with evaluated cells using given formulaParser
 */
export function getCellRangeValue(formulaParser, data, start, end) {
    return Matrix.toArray(Matrix.slice(start, end, data), function (cell) {
        return getComputedValue({
            cell: cell,
            formulaParser: formulaParser
        });
    });
}
/** Should spreadsheet handle clipboard event */
export function shouldHandleClipboardEvent(root, mode) {
    return root !== null && mode === "view" && isFocusedWithin(root);
}
export function isFocusedWithin(element) {
    return element.matches(FOCUS_WITHIN_SELECTOR);
}
